[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 768
PlayResY: 480

[Aegisub Project Garbage]
Audio File: Programming Like It's 1979 - 6502 Assembly language on the Apple ][.mp4
Video File: Programming Like It's 1979 - 6502 Assembly language on the Apple ][.mp4
Video AR Mode: 4
Video AR Value: 1.600000
Video Zoom Percent: 1.500000
Scroll Position: 120
Active Line: 91
Video Position: 14933

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: 字幕组样式,思源黑体 CN Medium,90,&H00FFFFB9,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,3.6,1.8,2,0,0,15,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:02.78,0:00:07.76,Default,,0,0,0,,我们开始吧。这是Apple //e(Apple 2e) 一切就绪
Dialogue: 0,0:00:08.30,0:00:13.44,Default,,0,0,0,,我想做一个非常简短的视频，大概十分钟左右
Dialogue: 0,0:00:13.44,0:00:16.80,Default,,0,0,0,,介绍一下1981年的编程方式
Dialogue: 0,0:00:16.94,0:00:25.48,Default,,0,0,0,,好像很多观众都特别想知道当时是如何在 Apple 2 上编程的
Dialogue: 0,0:00:25.48,0:00:29.58,Default,,0,0,0,,我会先演示一下没有辅助工具之前的样子
Dialogue: 0,0:00:29.80,0:00:32.56,Default,,0,0,0,,之后再演示一些非常基本的工具
Dialogue: 0,0:00:32.70,0:00:37.22,Default,,0,0,0,,如果有时间的话，我还会展示一下汇编器的样子
Dialogue: 0,0:00:37.44,0:00:42.46,Default,,0,0,0,,这里已经启动了Apple 2e 的模拟器( Windows下可以用 AppleWin )，我将按下重置按钮
Dialogue: 0,0:00:42.70,0:00:49.30,Default,,0,0,0,,因为没有挂载磁盘，我们暂时看不到DOS界面
Dialogue: 0,0:00:49.38,0:00:58.44,Default,,0,0,0,,什么事都干不了，目前只有苹果内置的基础解释器工具
Dialogue: 0,0:00:59.60,0:01:04.80,Default,,0,0,0,,如你所愿，我们可以写一个小的演示程序
Dialogue: 0,0:01:05.44,0:01:10.58,Default,,0,0,0,,和每个人都会编写的基本程序一样，
Dialogue: 0,0:01:12.10,0:01:14.49,Default,,0,0,0,,没啥意思
Dialogue: 0,0:01:14.49,0:01:18.72,Default,,0,0,0,,大家肯定会在 Apple 2 上玩游戏
Dialogue: 0,0:01:18.88,0:01:23.04,Default,,0,0,0,,部分游戏中有BUG，并且当游戏崩溃时
Dialogue: 0,0:01:23.14,0:01:26.24,Default,,0,0,0,,如果它是BASIC游戏，有时可能会回到BASIC界面
Dialogue: 0,0:01:26.28,0:01:33.93,Default,,0,0,0,,但是如果它是用机器语言编写的，可能会出现一个不常见的星号提示符
Dialogue: 0,0:01:33.93,0:01:37.80,Default,,0,0,0,,实际上它长这样，显示时通常伴随着"哔"的声音。
Dialogue: 0,0:01:38.06,0:01:42.50,Default,,0,0,0,,这个提示符有什么用？我们可以尝试获得一些帮助，
Dialogue: 0,0:01:42.62,0:01:46.78,Default,,0,0,0,,发出了一个"哔"声，我们可以输入help和H
Dialogue: 0,0:01:46.84,0:01:49.76,Default,,0,0,0,,就像UNIX系统中的VI编辑器一样
Dialogue: 0,0:01:49.94,0:01:54.88,Default,,0,0,0,,这是Apple2 机器语言的监视器
Dialogue: 0,0:01:55.06,0:02:06.18,Default,,0,0,0,,这意味着你可以查看并修改内存中的值，所以先尝试输入一个数字
Dialogue: 0,0:02:06.86,0:02:10.70,Default,,0,0,0,,实际上这是内存中的第0个字节
Dialogue: 0,0:02:10.80,0:02:12.14,Default,,0,0,0,,你也可以这么做
Dialogue: 0,0:02:12.34,0:02:15.88,Default,,0,0,0,,可以看到它的值是4C
Dialogue: 0,0:02:16.06,0:02:22.52,Default,,0,0,0,,我们可以查看内存中的其他区域，最大地址好像是ffff
Dialogue: 0,0:02:22.58,0:02:27.36,Default,,0,0,0,,实际上在ROM而不是RAM中（FFFF存储IRQ/BRK中断的MSB）
Dialogue: 0,0:02:27.48,0:02:35.94,Default,,0,0,0,,可以用.的方式来一次查看内存中的多个字节
Dialogue: 0,0:02:36.22,0:02:39.10,Default,,0,0,0,,如果你之前用过hexdump
Dialogue: 0,0:02:39.28,0:02:46.46,Default,,0,0,0,,你可能会认出这个输出显示了第一行是第0到第7字节
Dialogue: 0,0:02:46.54,0:02:50.18,Default,,0,0,0,,字节0的值是4C，字节1的值是3C
Dialogue: 0,0:02:50.38,0:02:54.46,Default,,0,0,0,,显示方式很好，但我们怎么操作它呢
Dialogue: 0,0:02:54.54,0:03:01.18,Default,,0,0,0,,我们不仅能观察内存值，以0800处的内存为例
Dialogue: 0,0:03:01.20,0:03:03.74,Default,,0,0,0,,顺便说一下，这些数字在这里都是十六进制的
Dialogue: 0,0:03:03.82,0:03:12.96,Default,,0,0,0,,我们还能修改它。比如将0800处字节的值从0改为99
Dialogue: 0,0:03:13.02,0:03:18.10,Default,,0,0,0,,再次查看0800，可以看到内存被修改了
Dialogue: 0,0:03:20.76,0:03:23.80,Default,,0,0,0,,给地址为640的字节赋一个值
Dialogue: 0,0:03:30.42,0:03:37.04,Default,,0,0,0,,这里还是把620字节的值改为55更好
Dialogue: 0,0:03:37.22,0:03:42.32,Default,,0,0,0,,您应该会在屏幕顶部看到一个闪烁的U
Dialogue: 0,0:03:42.38,0:03:48.54,Default,,0,0,0,,这是哪来的? 让我们重复一次，让我们把相同的值再次赋值给原来的位置
Dialogue: 0,0:03:48.56,0:03:49.52,Default,,0,0,0,,出现了另一个闪烁的U
Dialogue: 0,0:03:49.52,0:03:50.56,Default,,0,0,0,,发生了什么？
Dialogue: 0,0:03:50.70,0:03:56.76,Default,,0,0,0,,不像现在的现代计算机有所谓的"受保护的内存"
Dialogue: 0,0:03:57.12,0:04:03.56,Default,,0,0,0,,在类似Apple2 这样的8位计算机上，你有权限访问系统中的所有内存
Dialogue: 0,0:04:04.01,0:04:08.76,Default,,0,0,0,,这意味着你可能会让你心态爆炸或者把系统玩崩
Dialogue: 0,0:04:08.84,0:04:13.38,Default,,0,0,0,,但大多数设备将内存映射到内存中的某个区域
Dialogue: 0,0:04:13.38,0:04:18.75,Default,,0,0,0,,所以我们在这里看到的屏幕文本实际上是从
Dialogue: 0,0:04:18.75,0:04:25.28,Default,,0,0,0,,可能是400到7ff的值，大概是这样
Dialogue: 0,0:04:25.80,0:04:27.86,Default,,0,0,0,,通常情况，你需要去查一下具体的地址值。
Dialogue: 0,0:04:27.90,0:04:36.70,Default,,0,0,0,,当我把620字节的值改为55时，那个闪烁的U就代表55这个值
Dialogue: 0,0:04:37.20,0:04:44.02,Default,,0,0,0,,将值修改为56，现在就显示一个闪烁的V字母
Dialogue: 0,0:04:44.02,0:04:46.38,Default,,0,0,0,, 如果我们修改多个字节的值
Dialogue: 0,0:04:46.65,0:04:55.53,Default,,0,0,0,,如果把610字节及其之后的内存值分别改为53 54 55 56 57 58，就可以看到闪烁的STUVW
Dialogue: 0,0:04:55.53,0:05:01.77,Default,,0,0,0,,我们可以查看和修改内存，你可能会觉得这没什么了不起的
Dialogue: 0,0:05:02.20,0:05:06.86,Default,,0,0,0,,这个监视器实际上可以做一些更有趣的事情
Dialogue: 0,0:05:07.06,0:05:11.22,Default,,0,0,0,,特别地，它可以执行反汇编操作
Dialogue: 0,0:05:11.44,0:05:18.09,Default,,0,0,0,,来看一下800内存地址处，这通常是程序开始执行的入口
Dialogue: 0,0:05:18.09,0:05:26.66,Default,,0,0,0,,不要直接按回车，而是在末尾添加一个L
Dialogue: 0,0:05:27.54,0:05:37.46,Default,,0,0,0,,可以看到监视器试图反汇编代码中的这些字节（例如6502的机器语言）
Dialogue: 0,0:05:37.56,0:05:41.46,Default,,0,0,0,,这些数据也许不一定是6502的机器代码，
Dialogue: 0,0:05:41.46,0:05:46.86,Default,,0,0,0,,通常情况下可能只是普通的数据，就像我之前输入的值一样
Dialogue: 0,0:05:47.02,0:05:54.98,Default,,0,0,0,,只是因为解释器刚好能将这些数据当做6502的汇编代码来输出
Dialogue: 0,0:05:55.10,0:05:57.84,Default,,0,0,0,,让我们实际操作一下
Dialogue: 0,0:05:57.92,0:06:02.40,Default,,0,0,0,,先在监视器里现场写一些汇编代码
Dialogue: 0,0:06:02.62,0:06:05.16,Default,,0,0,0,,先把这些数据清理掉
Dialogue: 0,0:06:05.28,0:06:10.82,Default,,0,0,0,,这里一大堆的 00 都被翻译为BRK指令
Dialogue: 0,0:06:10.88,0:06:13.16,Default,,0,0,0,,有种更快的方法可以一次修改一段内存
Dialogue: 0,0:06:13.20,0:06:16.58,Default,,0,0,0,,老实说我有点忘了，毕竟已经过去了30年
Dialogue: 0,0:06:16.66,0:06:18.88,Default,,0,0,0,,可以看到这段内存都被显示为了BRK
Dialogue: 0,0:06:19.84,0:06:25.48,Default,,0,0,0,,如果没有汇编程序和其他工具，你要怎么做呢
Dialogue: 0,0:06:25.52,0:06:34.52,Default,,0,0,0,,你会拿到一本笔记本，还可能有一张速查卡，其中列出了6502指令集的操作码
Dialogue: 0,0:06:35.04,0:06:38.18,Default,,0,0,0,,然后使用汇编语言编写程序
Dialogue: 0,0:06:38.24,0:06:42.26,Default,,0,0,0,,在一页的左侧位置上书写要实现的功能
Dialogue: 0,0:06:42.32,0:06:48.64,Default,,0,0,0,,在同一页的右侧，先要查找操作码，就像在计算尺上查找对数一样
Dialogue: 0,0:06:48.82,0:06:51.82,Default,,0,0,0,,之后将操作码写在右侧
Dialogue: 0,0:06:51.86,0:06:54.60,Default,,0,0,0,,实际上，还有专门的帮助手册
Dialogue: 0,0:06:54.60,0:06:58.74,Default,,0,0,0,,因为当时8位计算机是非常普遍的
Dialogue: 0,0:06:59.82,0:07:02.34,Default,,0,0,0,,现在来编写一个没有具体作用的程序
Dialogue: 0,0:07:02.62,0:07:06.60,Default,,0,0,0,,只是几行没有具体功能的汇编代码
Dialogue: 0,0:07:06.72,0:07:11.20,Default,,0,0,0,,我其实准备了一些后续的程序，但我不打算在这期视频中说太多
Dialogue: 0,0:07:11.58,0:07:20.96,Default,,0,0,0,,写入我的内存的一个操作码是A9，代表加载累加器立即数模式（LDA）
Dialogue: 0,0:07:21.10,0:07:24.34,Default,,0,0,0,,可以取一个值，比如55
Dialogue: 0,0:07:24.80,0:07:29.28,Default,,0,0,0,,如果我们看一下反汇编这段代码的结果
Dialogue: 0,0:07:29.34,0:07:37.46,Default,,0,0,0,,在屏幕顶端我们可以看见左侧是A9 55 右侧是 LDA #$55（十六进制）
Dialogue: 0,0:07:37.52,0:07:39.90,Default,,0,0,0,,表示向累加器加载值0x55
Dialogue: 0,0:07:41.18,0:07:46.86,Default,,0,0,0,,让我们再增加一些数据 (40年后的苹果手机铃声)
Dialogue: 0,0:07:47.37,0:07:55.00,Default,,0,0,0,,记不清是8D还是85了，先试下8D
Dialogue: 0,0:07:56.48,0:08:02.54,Default,,0,0,0,,...40 06 希望这是一个有效的操作码
Dialogue: 0,0:08:02.62,0:08:09.60,Default,,0,0,0,,我没有使用速查卡，只是随意浏览一下
Dialogue: 0,0:08:09.60,0:08:17.68,Default,,0,0,0,,好了，可以看到在802地址中的指令已经将累加器的值存储在640这个内存地址中
Dialogue: 0,0:08:17.74,0:08:25.66,Default,,0,0,0,,继续向累加器载入值，比如42
Dialogue: 0,0:08:26.00,0:08:30.06,Default,,0,0,0,,可以继续在当前行输入值
Dialogue: 0,0:08:30.10,0:08:34.98,Default,,0,0,0,,这些值还是会写入之后的内存，我们将其存储在41 06地址中
Dialogue: 0,0:08:35.38,0:08:39.72,Default,,0,0,0,,这两个字节的先后顺序和实际值是相反的，原因是处理器的字节序（小端）
Dialogue: 0,0:08:39.88,0:08:46.38,Default,,0,0,0,,我们的汇编程序现在有四行代码，再加一行BRK指令作为结尾
Dialogue: 0,0:08:47.92,0:08:53.12,Default,,0,0,0,,然后就可以从Apple2监视器运行程序了
Dialogue: 0,0:08:53.28,0:08:56.80,Default,,0,0,0,,动手运行吧
Dialogue: 0,0:08:56.94,0:09:02.97,Default,,0,0,0,,聊天室里的Patrick说他现在能理解我为什么能忍受 Space Camp这种游戏了。的确如此。
Dialogue: 0,0:09:02.97,0:09:07.66,Default,,0,0,0,,用G来运行程序，例如800G
Dialogue: 0,0:09:07.92,0:09:12.84,Default,,0,0,0,,我们运行了刚才的程序，它没什么具体作用，只是返回了一些状态标志
Dialogue: 0,0:09:13.32,0:09:18.18,Default,,0,0,0,,展示了6502的寄存器，先说前三个
Dialogue: 0,0:09:18.34,0:09:27.48,Default,,0,0,0,,A是累加器，用于算术运算。X Y寄存器通常用于索引、循环和指针操作
Dialogue: 0,0:09:27.86,0:09:30.60,Default,,0,0,0,,P是状态标志
Dialogue: 0,0:09:30.68,0:09:35.85,Default,,0,0,0,,这是一个非常复杂的话题，今天就先不深入了
Dialogue: 0,0:09:35.85,0:09:39.52,Default,,0,0,0,,下次有机会再说吧。S是堆栈指针。
Dialogue: 0,0:09:40.68,0:09:49.70,Default,,0,0,0,,可以在标记为814的行上看到，00 BRK，然后是闪烁的UB字符
Dialogue: 0,0:09:49.96,0:09:56.42,Default,,0,0,0,,这就是我们刚才改变的内存位置，我们给它赋了个新值
Dialogue: 0,0:09:56.72,0:10:00.36,Default,,0,0,0,,如果查看那段内存，那些值还没有保存到内存里
Dialogue: 0,0:10:00.48,0:10:08.52,Default,,0,0,0,,因为我将它们输入到文本域或者叫文本视图映射的内存区域
Dialogue: 0,0:10:08.56,0:10:12.06,Default,,0,0,0,,我们正在改变的就是映射的内存区域，所以才能看到修改
Dialogue: 0,0:10:12.18,0:10:17.10,Default,,0,0,0,,这是就最基本的监视器功能
Dialogue: 0,0:10:17.18,0:10:23.32,Default,,0,0,0,,但我们还能做得更好，因为苹果很快就做了一点改进
Dialogue: 0,0:10:23.46,0:10:26.82,Default,,0,0,0,,他们实现了一个叫 mini汇编器 的程序
Dialogue: 0,0:10:27.04,0:10:31.58,Default,,0,0,0,,每个人都知道监视器，因为迟早会由于程序崩溃而进入监视器界面
Dialogue: 0,0:10:31.78,0:10:34.66,Default,,0,0,0,,但很少人知道 mini汇编器
Dialogue: 0,0:10:36.14,0:10:44.44,Default,,0,0,0,,mini汇编程序可以协助我们完成刚才的编程，免去查找操作码的麻烦
Dialogue: 0,0:10:44.66,0:10:47.02,Default,,0,0,0,,尝试进入mini汇编器
Dialogue: 0,0:10:47.18,0:10:51.30,Default,,0,0,0,,我觉得现在无法进入mini汇编器，因为我已经加载了一张磁盘
Dialogue: 0,0:10:51.46,0:10:54.62,Default,,0,0,0,,哦其实运行成功了，因为我们现在用的是Apple 2e
Dialogue: 0,0:10:54.70,0:11:02.50,Default,,0,0,0,,如果用的是Apple 2 或者plus ,就需要加载磁盘。但我们现在可以直接开始
Dialogue: 0,0:11:02.56,0:11:08.84,Default,,0,0,0,,让我们输入一些内容
Dialogue: 0,0:11:09.60,0:11:14.74,Default,,0,0,0,,补充一下，我刚才输入了800：
Dialogue: 0,0:11:14.82,0:11:25.16,Default,,0,0,0,,然后是A9 99，它立即将其翻译成操作码并显示出结果
Dialogue: 0,0:11:25.82,0:11:31.72,Default,,0,0,0,,我觉得如果输入冒号，就可以继续操作后续的内存。试试对不对
Dialogue: 0,0:11:32.26,0:11:36.06,Default,,0,0,0,,让我们看看是否正确，让我们尝试将其存储在地址为300的内存中
Dialogue: 0,0:11:36.16,0:11:38.22,Default,,0,0,0,,不行
Dialogue: 0,0:11:40.08,0:11:41.90,Default,,0,0,0,,哦原来只要输入一个空格就好了
Dialogue: 0,0:11:42.02,0:11:49.10,Default,,0,0,0,,我们将0x99存储在地址为300的内存中，之后加载值88
Dialogue: 0,0:11:51.02,0:11:55.58,Default,,0,0,0,,将a转移到X寄存器
Dialogue: 0,0:11:55.86,0:12:03.64,Default,,0,0,0,,将X寄存器的值保存到地址为301的内存中，目前的操作还比较无趣
Dialogue: 0,0:12:04.62,0:12:10.36,Default,,0,0,0,,我觉得要按下“重置”按钮（模拟器中是Ctrl+F2）离开mini汇编器
Dialogue: 0,0:12:10.54,0:12:13.00,Default,,0,0,0,,这就是我们的程序了
Dialogue: 0,0:12:13.06,0:12:18.06,Default,,0,0,0,,在运行之前，先看下 300和301内存
Dialogue: 0,0:12:19.04,0:12:24.20,Default,,0,0,0,,它们的值是FF。然后运行程序
Dialogue: 0,0:12:24.30,0:12:31.68,Default,,0,0,0,,再次查看内存300 301，可以看到它们的值是99和88
Dialogue: 0,0:12:33.16,0:12:37.90,Default,,0,0,0,,mini汇编器实际上只是一个翻译程序，它可以动态翻译
Dialogue: 0,0:12:37.94,0:12:43.40,Default,,0,0,0,,可以输入注释，但汇编器不会保留注释，也没有文件管理功能
Dialogue: 0,0:12:43.59,0:12:46.72,Default,,0,0,0,,要么写入，要么丢失
Dialogue: 0,0:12:46.82,0:12:52.12,Default,,0,0,0,,如果需要写代码量很多的大程序
Dialogue: 0,0:12:52.22,0:12:59.86,Default,,0,0,0,,就需要一个真正的汇编器，包括支持注释的编辑器
Dialogue: 0,0:12:59.96,0:13:03.96,Default,,0,0,0,,还要能支持元数据，这样就可以编写变量。
Dialogue: 0,0:13:04.00,0:13:13.02,Default,,0,0,0,,如果你在1978年买了一台苹果电脑，就只能用这些基础功能。当时还没有为其开发的优秀软件。
Dialogue: 0,0:13:13.12,0:13:15.20,Default,,0,0,0,,在当时，你只能这么编程
Dialogue: 0,0:13:15.30,0:13:18.80,Default,,0,0,0,,但这已经是一次像KIM-1那样的飞跃了，因为
Dialogue: 0,0:13:19.12,0:13:23.42,Default,,0,0,0,,因为它可以显示出操作代码
Dialogue: 0,0:13:25.18,0:13:28.98,Default,,0,0,0,,这些就是我想给出的基本介绍了
Dialogue: 0,0:13:29.08,0:13:34.66,Default,,0,0,0,,很少涉及汇编语言编程，因为这方面的资源已经很多了。
Dialogue: 0,0:13:34.84,0:13:41.64,Default,,0,0,0,,只是让大家感受一下在没有编程工具时如何编程
Dialogue: 0,0:13:41.76,0:13:50.28,Default,,0,0,0,,如果有下一期的话，我打算加载一个我可能用到的汇编器
Dialogue: 0,0:13:50.38,0:13:54.06,Default,,0,0,0,,叫做Merlin 并展示它
Dialogue: 0,0:13:54.30,0:13:57.74,Default,,0,0,0,,要我现在演示吗?还是下次再说？（作者在Twitch直播）
Dialogue: 0,0:13:59.30,0:14:03.94,Default,,0,0,0,,那继续吧，上传YouTube的内容可能就到此为止了
Dialogue: 0,0:14:04.86,0:14:08.24,Default,,0,0,0,,就当做直播观众的独家内容好了
Dialogue: 0,0:14:08.38,0:14:14.34,Default,,0,0,0,,插入磁盘，希望能用
Dialogue: 0,0:14:14.44,0:14:17.24,Default,,0,0,0,,我大概有八个版本的Merlin
Dialogue: 0,0:14:32.18,0:14:33.38,Default,,0,0,0,,等待加载中
Dialogue: 0,0:14:33.42,0:14:41.40,Default,,0,0,0,,我把仿真程序的处理速度设置为Apple 2的实际速度，所以慢得离谱
Dialogue: 0,0:14:41.68,0:14:49.60,Default,,0,0,0,,这就是Merlin的界面了，可以看到这里有各种处理文件的选项，让我们深入一下
Dialogue: 0,0:14:49.94,0:14:56.56,Default,,0,0,0,,按e编辑文件，进入一个至少算得上行编辑器的程序
Dialogue: 0,0:14:57.05,0:15:03.10,Default,,0,0,0,,按a添加一行，增加程序入口
Dialogue: 0,0:15:03.38,0:15:07.28,Default,,0,0,0,,写一个和刚才功能一样的程序
Dialogue: 0,0:15:07.36,0:15:11.68,Default,,0,0,0,,输入 空格 ORG $0800
Dialogue: 0,0:15:12.02,0:15:16.86,Default,,0,0,0,,这不是一个6502指令集的操作码，只是一个给汇编程序的提示符
Dialogue: 0,0:15:17.88,0:15:29.66,Default,,0,0,0,,还可以自定义一些符号，比如head等于0300 tail等于0301
Dialogue: 0,0:15:30.58,0:15:38.92,Default,,0,0,0,,还能增加注释
Dialogue: 0,0:15:39.14,0:15:42.68,Default,,0,0,0,,然后就按你自己的习惯写代码
Dialogue: 0,0:15:42.80,0:15:52.62,Default,,0,0,0,,最难的部分其实是使用这样的行编辑器，这比写汇编更让人烦躁
Dialogue: 0,0:15:52.78,0:15:55.84,Default,,0,0,0,,因为我们已经习惯了使用现代的全屏幕编辑器了
Dialogue: 0,0:15:56.08,0:16:01.76,Default,,0,0,0,,我想把它保存在地址为300的内存中，所以使用自定义的符号名称
Dialogue: 0,0:16:03.02,0:16:10.64,Default,,0,0,0,,值为88，然后转移到寄存器Y
Dialogue: 0,0:16:10.80,0:16:15.98,Default,,0,0,0,,将寄存器Y的值存储在tail地址，然后用BRK结束这段代码。
Dialogue: 0,0:16:16.22,0:16:21.63,Default,,0,0,0,,不是个很有趣的程序，但我喜欢探索不同的方式
Dialogue: 0,0:16:21.63,0:16:24.86,Default,,0,0,0,,在空白行处换行
Dialogue: 0,0:16:24.98,0:16:27.56,Default,,0,0,0,,这样就可以汇编代码了
Dialogue: 0,0:16:28.22,0:16:32.24,Default,,0,0,0,,因为我阅读过文档，所以我知道能这么做
Dialogue: 0,0:16:32.90,0:16:40.82,Default,,0,0,0,,顺便提一句，缺少在线帮助是早期的Apple 2程序的一致特点
Dialogue: 0,0:16:41.00,0:16:47.24,Default,,0,0,0,,没有手册就无法完成任何事情
Dialogue: 0,0:16:47.52,0:16:56.30,Default,,0,0,0,,那时电脑上的内存非常有限，因此大多数程序都没有内置在线帮助功能
Dialogue: 0,0:16:56.30,0:16:58.46,Default,,0,0,0,,没有足够空间给你的程序使用
Dialogue: 0,0:16:58.62,0:17:01.96,Default,,0,0,0,,执行汇编，这个问题选择“否”
Dialogue: 0,0:17:01.98,0:17:09.34,Default,,0,0,0,,可以看到上面有一堆操作码，展示了整个程序的样子，还显示了一些自定义符号
Dialogue: 0,0:17:10.76,0:17:17.34,Default,,0,0,0,,现在应该退出，这样就可以保存源代码
Dialogue: 0,0:17:17.54,0:17:21.96,Default,,0,0,0,,文件名就叫TESTPROG
Dialogue: 0,0:17:23.08,0:17:30.81,Default,,0,0,0,,这样就储存为TESTPROG.S，S代表汇编语言。接下来保存目标代码
Dialogue: 0,0:17:30.81,0:17:35.57,Default,,0,0,0,,这是我们将要实际运行的程序
Dialogue: 0,0:17:35.65,0:17:43.48,Default,,0,0,0,,但愿能跑。我要退出Merlin了，让我们来看一下磁盘
Dialogue: 0,0:17:44.84,0:17:47.32,Default,,0,0,0,,一堆代码
Dialogue: 0,0:17:48.36,0:17:52.44,Default,,0,0,0,,我把它直接保存在了汇编器的磁盘上，不是很讲究
Dialogue: 0,0:17:52.86,0:18:00.79,Default,,0,0,0,,返回监视器，确保程序不在内存中。可以看到它确实不在内存里
Dialogue: 0,0:18:01.58,0:18:07.90,Default,,0,0,0,,一堆BRK语句，所以内存是空的，让我们运行程序
Dialogue: 0,0:18:08.04,0:18:12.06,Default,,0,0,0,,用BRUN运行，它将一次运行所有名叫TESTPROG的程序
Dialogue: 0,0:18:17.44,0:18:24.64,Default,,0,0,0,,寄存器的值看起来是正确的，我们的程序实现了预期的功能
Dialogue: 0,0:18:30.72,0:18:38.58,Default,,0,0,0,,这些工具的优缺点如上所述。1978年到1982年的编程工具就是这样的。
Dialogue: 0,0:18:38.64,0:18:41.40,Default,,0,0,0,,随着时间的推移，工具越来越完善
Dialogue: 0,0:18:41.52,0:18:49.62,Default,,0,0,0,,如果去对比Apple 2 disk archives 上不同版本的Merlin，就可以看到它是如何逐渐改进的。
Dialogue: 0,0:18:49.74,0:18:55.38,Default,,0,0,0,,最终从行编辑器变成真正的全屏编辑器
Dialogue: 0,0:18:55.48,0:18:58.18,Default,,0,0,0,,这确实是两个截然不同的领域
Dialogue: 0,0:18:58.30,0:19:03.30,Default,,0,0,0,,如果再出一个类似的视频，我将会写一个实际的程序
Dialogue: 0,0:19:03.48,0:19:09.32,Default,,0,0,0,,尝试解释6502的一些变化
Dialogue: 0,0:19:09.58,0:19:19.50,Default,,0,0,0,,即使在汇编语言层面上，该CPU上的编程也不同于其他拥有更完善功能的CPU
Dialogue: 0,0:19:19.70,0:19:25.04,Default,,0,0,0,,我还会试着让你感受当时的各种困难条件
Dialogue: 0,0:19:25.16,0:19:31.12,Default,,0,0,0,,一言以蔽之 Apple 2 太慢了
Dialogue: 0,0:19:31.26,0:19:37.92,Default,,0,0,0,,因此，任何通过直接的汇编编程带来的速度优势都是非常有价值的
Dialogue: 0,0:19:38.04,0:19:40.42,Default,,0,0,0,,我们下次可以举一个例子来说明
Dialogue: 0,0:19:40.84,0:19:42.90,Default,,0,0,0,,这就是本次全部内容了，感谢收看
Dialogue: 0,0:19:42.98,0:19:53.03,Default,,0,0,0,,和各位一起在[内存受限的]小道上闲逛感觉很不错，我们下次再见！
