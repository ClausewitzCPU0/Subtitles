[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1152
PlayResY: 720

[Aegisub Project Garbage]
Audio File: How Do Python Coroutines Work.mp4
Video File: How Do Python Coroutines Work.mp4
Video AR Mode: 4
Video AR Value: 1.600000
Video Zoom Percent: 0.500000
Scroll Position: 575
Active Line: 594
Video Position: 81213

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,26,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:04.38,0:00:08.13,Default,,0,0,0,,大家好，我是A. Jesse Jiryu Davis
Dialogue: 0,0:00:08.13,0:00:12.66,Default,,0,0,0,,我将解释Python协程是如何工作的
Dialogue: 0,0:00:14.52,0:00:15.54,Default,,0,0,0,,介绍一下我自己
Dialogue: 0,0:00:15.54,0:00:25.98,Default,,0,0,0,,我是MongoDB的一名高级工程师，职责是为MongoDB写Python和C的驱动。
Dialogue: 0,0:00:25.98,0:00:32.10,Default,,0,0,0,,是的,我们正在招聘。我强烈推荐来MongoDB工作
Dialogue: 0,0:00:32.10,0:00:40.44,Default,,0,0,0,,访问bit.ly/mongo-jobs了解所有的工作机会
Dialogue: 0,0:00:41.40,0:00:44.58,Default,,0,0,0,,如果你想了解更多关于这个话题的信息
Dialogue: 0,0:00:44.58,0:00:49.71,Default,,0,0,0,,我在bit.ly/coroutines中新增了一个页面
Dialogue: 0,0:00:49.71,0:00:56.37,Default,,0,0,0,,你可以在链接里找到本视频的代码
Dialogue: 0,0:00:56.37,0:01:05.64,Default,,0,0,0,,同时，在即将发布的《开源应用程序架构》书中
Dialogue: 0,0:01:05.94,0:01:16.05,Default,,0,0,0,,我和Guido(Python创始人)合著了一章，其中深入地阐述了python协程工作的细节
Dialogue: 0,0:01:17.16,0:01:22.83,Default,,0,0,0,,这个示例的主题是
Dialogue: 0,0:01:26.55,0:01:29.88,Default,,0,0,0,,基于回调的异步框架
Dialogue: 0,0:01:29.88,0:01:35.40,Default,,0,0,0,,写完之后，我们会看到它非常有效，但也有些混乱
Dialogue: 0,0:01:35.40,0:01:42.54,Default,,0,0,0,,所以我们最后要把它改写成一个基于协程的框架
Dialogue: 0,0:01:44.22,0:01:48.72,Default,,0,0,0,,因此 从一个基于回调的异步框架入手
Dialogue: 0,0:01:48.72,0:01:51.99,Default,,0,0,0,,它使用非阻塞socket
Dialogue: 0,0:01:52.98,0:01:54.81,Default,,0,0,0,,使用回调函数
Dialogue: 0,0:01:54.81,0:01:55.56,Default,,0,0,0,,当然
Dialogue: 0,0:01:55.56,0:01:58.98,Default,,0,0,0,,它还使用一个事件循环
Dialogue: 0,0:02:00.42,0:02:02.85,Default,,0,0,0,,至于协程
Dialogue: 0,0:02:02.85,0:02:05.46,Default,,0,0,0,,到时候再说吧
Dialogue: 0,0:02:06.51,0:02:09.00,Default,,0,0,0,,编码之前有一些准备工作
Dialogue: 0,0:02:09.00,0:02:14.49,Default,,0,0,0,,我写了一个简单的web服务器(Github代码中的server.py)
Dialogue: 0,0:02:18.75,0:02:21.06,Default,,0,0,0,,它可以响应http请求
Dialogue: 0,0:02:22.44,0:02:27.51,Default,,0,0,0,,我为本地的python会议"PyGotham 2015"写了这篇文章
Dialogue: 0,0:02:27.51,0:02:32.73,Default,,0,0,0,,所以你可以看到它向所有那些了不起的人们致意
Dialogue: 0,0:02:32.73,0:02:37.02,Default,,0,0,0,,这个框架的另一个有趣之处是它有点慢
Dialogue: 0,0:02:38.52,0:02:42.30,Default,,0,0,0,,这个web服务器返回非常简单的响应
Dialogue: 0,0:02:42.30,0:02:47.61,Default,,0,0,0,,但我故意增加了一些sleep代码 所以要花差不多一秒的时间响应
Dialogue: 0,0:02:47.61,0:02:50.55,Default,,0,0,0,,这么做的重要性将会在后面体现
Dialogue: 0,0:02:50.55,0:02:54.39,Default,,0,0,0,,因为这是最适合用异步优化的场景：
Dialogue: 0,0:02:54.39,0:03:00.45,Default,,0,0,0,,与速度较慢的服务器或者客户端进行有效率的通信
Dialogue: 0,0:03:02.49,0:03:04.38,Default,,0,0,0,,让我们看看
Dialogue: 0,0:03:04.38,0:03:11.28,Default,,0,0,0,,我们怎样才能以典型的python方式获取URL
Dialogue: 0,0:03:14.61,0:03:19.62,Default,,0,0,0,,所以我们先导入socket
Dialogue: 0,0:03:21.24,0:03:22.35,Default,,0,0,0,,然后
Dialogue: 0,0:03:30.66,0:03:34.11,Default,,0,0,0,,绑定到合适的域名和端口
Dialogue: 0,0:03:35.64,0:03:36.90,Default,,0,0,0,,格式化一个请求
Dialogue: 0,0:03:48.87,0:03:50.58,Default,,0,0,0,,把它发送到服务器
Dialogue: 0,0:03:51.75,0:03:54.27,Default,,0,0,0,,我用的python3环境
Dialogue: 0,0:03:54.27,0:03:59.82,Default,,0,0,0,,所以对那些通过网络传输的所有内容进行编码是很重要的
Dialogue: 0,0:03:59.82,0:04:00.00,Default,,0,0,0,,哦
Dialogue: 0,0:04:00.00,0:04:02.13,Default,,0,0,0,,另一个需要记住的重要的事情是
Dialogue: 0,0:04:04.59,0:04:12.75,Default,,0,0,0,,每个HTTP请求头部以两个回车换行符分隔
Dialogue: 0,0:04:12.75,0:04:19.35,Default,,0,0,0,,所以一旦我们发送了请求就会收到响应 它会以分块的形式返回给我们
Dialogue: 0,0:04:19.35,0:04:23.31,Default,,0,0,0,,所以我们要把它们收集到一个列表中
Dialogue: 0,0:04:28.65,0:04:30.81,Default,,0,0,0,,收集最多1000个分块(口胡)
Dialogue: 0,0:04:30.81,0:04:33.21,Default,,0,0,0,,一次接收1000字节
Dialogue: 0,0:04:33.21,0:04:35.40,Default,,0,0,0,,只要我们接收完一个分块
Dialogue: 0,0:04:39.45,0:04:44.07,Default,,0,0,0,,就将它加到列表中，如果我们得到一个空的块
Dialogue: 0,0:04:44.07,0:04:46.32,Default,,0,0,0,,我们就知道服务器断开了
Dialogue: 0,0:04:46.32,0:04:49.86,Default,,0,0,0,,所以数据就接收完毕了
Dialogue: 0,0:04:49.86,0:04:52.92,Default,,0,0,0,,所以响应内容将会是
Dialogue: 0,0:04:56.16,0:04:59.64,Default,,0,0,0,,我们将用空字节类型来连接所有的块
Dialogue: 0,0:05:00.75,0:05:03.90,Default,,0,0,0,,然后我们会解码
Dialogue: 0,0:05:05.82,0:05:07.29,Default,,0,0,0,,默认是utf-8
Dialogue: 0,0:05:08.49,0:05:17.28,Default,,0,0,0,,然后我们把响应内容的第一行打印出来
Dialogue: 0,0:05:19.98,0:05:21.48,Default,,0,0,0,,所以
Dialogue: 0,0:05:21.48,0:05:23.13,Default,,0,0,0,,因为我们在死循环中
Dialogue: 0,0:05:23.13,0:05:24.27,Default,,0,0,0,,我们需要返回
Dialogue: 0,0:05:24.27,0:05:29.26,Default,,0,0,0,,这就是我们的get函数。如果我们get参数/foo
Dialogue: 0,0:05:29.54,0:05:39.45,Default,,0,0,0,,运行程序,可以看到响应的第一行是http 200 OK
Dialogue: 0,0:05:40.98,0:05:41.58,Default,,0,0,0,,然后
Dialogue: 0,0:05:42.48,0:05:43.56,Default,,0,0,0,,让我们看看
Dialogue: 0,0:05:45.18,0:05:46.32,Default,,0,0,0,,整个过程的运行时间
Dialogue: 0,0:06:00.60,0:06:04.38,Default,,0,0,0,,这需要大约一秒钟的时间 因为还有Python解释器的一点开销
Dialogue: 0,0:06:05.49,0:06:11.07,Default,,0,0,0,,这种方法的问题是 如果我们想要访问两个url
Dialogue: 0,0:06:11.07,0:06:15.42,Default,,0,0,0,,就需要两秒钟 因为我们是串行地获取URL
Dialogue: 0,0:06:17.07,0:06:24.63,Default,,0,0,0,,典型方法是在两个线程上启动这两个get操作
Dialogue: 0,0:06:24.63,0:06:31.23,Default,,0,0,0,,但如果我们等待数百个缓慢的请求，效率可能会变得非常低
Dialogue: 0,0:06:31.23,0:06:34.77,Default,,0,0,0,,因为我们不得不为这些请求创建数百个线程
Dialogue: 0,0:06:34.77,0:06:36.96,Default,,0,0,0,,有很多的开销是不必要的
Dialogue: 0,0:06:36.96,0:06:41.40,Default,,0,0,0,,所以我们将尝试写一个异步的框架来代替它
Dialogue: 0,0:06:41.40,0:06:49.05,Default,,0,0,0,,这样我们就不需要为了执行数百次缓慢的I/O请求而创建数百个线程了
Dialogue: 0,0:06:49.05,0:06:51.36,Default,,0,0,0,,我们想要比这更有效率的办法
Dialogue: 0,0:06:51.36,0:06:51.93,Default,,0,0,0,,所以
Dialogue: 0,0:06:53.07,0:07:00.75,Default,,0,0,0,,异步框架可以使用非阻塞socket，python中实现非阻塞的基本框架非常简单
Dialogue: 0,0:07:01.77,0:07:04.80,Default,,0,0,0,,如果我们运行程序，将会发生什么
Dialogue: 0,0:07:05.88,0:07:07.95,Default,,0,0,0,,我们会得到一个异常，因为
Dialogue: 0,0:07:09.54,0:07:15.39,Default,,0,0,0,,一个非阻塞socket的意思是任何会阻塞的操作
Dialogue: 0,0:07:15.39,0:07:22.08,Default,,0,0,0,,就像连接操作，要么立即成功 要么抛出异常
Dialogue: 0,0:07:22.08,0:07:22.35,Default,,0,0,0,,对
Dialogue: 0,0:07:22.35,0:07:23.79,Default,,0,0,0,,它是不允许阻塞的
Dialogue: 0,0:07:23.79,0:07:27.03,Default,,0,0,0,,不允许一直等待直到程序成功完成操作
Dialogue: 0,0:07:28.05,0:07:34.14,Default,,0,0,0,,所以我们需要一些方法来等待它完成
Dialogue: 0,0:07:35.49,0:07:37.41,Default,,0,0,0,,我们用Python来做这个
Dialogue: 0,0:07:38.55,0:07:39.09,Default,,0,0,0,,嗯
Dialogue: 0,0:07:39.09,0:07:39.63,Default,,0,0,0,,首先
Dialogue: 0,0:07:39.63,0:07:47.37,Default,,0,0,0,,我们可以先忽略这个错误
Dialogue: 0,0:07:48.51,0:07:50.36,Default,,0,0,0,,但这没有太大帮助
Dialogue: 0,0:07:50.42,0:07:56.22,Default,,0,0,0,,一旦我们试着给socket发送数据，就会报错：socket未连接
Dialogue: 0,0:07:56.32,0:08:00.00,Default,,0,0,0,,当我们调用connect时
Dialogue: 0,0:08:00.00,0:08:02.79,Default,,0,0,0,,非阻塞socket开始执行操作
Dialogue: 0,0:08:02.79,0:08:05.13,Default,,0,0,0,,但它并没有等待操作完成
Dialogue: 0,0:08:05.13,0:08:06.90,Default,,0,0,0,,因此我们还没有准备好发送数据
Dialogue: 0,0:08:07.86,0:08:12.87,Default,,0,0,0,,那么，我们怎么知道何时才能准备好发送一个操作呢
Dialogue: 0,0:08:14.22,0:08:15.45,Default,,0,0,0,,嗯
Dialogue: 0,0:08:15.45,0:08:16.62,Default,,0,0,0,,python3
Dialogue: 0,0:08:19.05,0:08:21.57,Default,,0,0,0,,有一个易于使用的包叫做selectors
Dialogue: 0,0:08:24.36,0:08:28.35,Default,,0,0,0,,在每一个远古版本的操作系统中
Dialogue: 0,0:08:28.35,0:08:34.44,Default,,0,0,0,,就有一些方法可以在非阻塞socket上等待某些事件
Dialogue: 0,0:08:34.44,0:08:35.10,Default,,0,0,0,,最初
Dialogue: 0,0:08:35.10,0:08:37.86,Default,,0,0,0,,有系统调用select
Dialogue: 0,0:08:37.86,0:08:39.06,Default,,0,0,0,,随着时间的推移
Dialogue: 0,0:08:39.06,0:08:43.26,Default,,0,0,0,,越来越多的可扩展的新版select已经被发明出来了
Dialogue: 0,0:08:43.26,0:08:46.08,Default,,0,0,0,,比如Linux上的poll
Dialogue: 0,0:08:46.08,0:08:50.46,Default,,0,0,0,,BSD和Mac上的epoll以及windows上的kqueue
Dialogue: 0,0:08:50.46,0:08:52.86,Default,,0,0,0,,这些都是I/O完成端口
Dialogue: 0,0:08:54.21,0:08:56.40,Default,,0,0,0,,Python3.4的优点是
Dialogue: 0,0:08:57.99,0:09:03.39,Default,,0,0,0,,你可以获取一个默认选择器
Dialogue: 0,0:09:03.39,0:09:14.16,Default,,0,0,0,,它会识别你当前使用的系统，给你最匹配的selector
Dialogue: 0,0:09:14.16,0:09:16.62,Default,,0,0,0,,所以我们要做一个这样的程序：
Dialogue: 0,0:09:18.12,0:09:21.00,Default,,0,0,0,,在我们试着给socket发送任何东西之前
Dialogue: 0,0:09:22.17,0:09:24.84,Default,,0,0,0,,我们将等待它到可读状态
Dialogue: 0,0:09:24.84,0:09:28.38,Default,,0,0,0,,我们会等着它准备好要发送的内容
Dialogue: 0,0:09:28.38,0:09:30.30,Default,,0,0,0,,为了做到这一点
Dialogue: 0,0:09:30.30,0:09:34.23,Default,,0,0,0,,我们注册了socket文件号
Dialogue: 0,0:09:34.23,0:09:36.81,Default,,0,0,0,,就是一个整型
Dialogue: 0,0:09:36.81,0:09:38.82,Default,,0,0,0,,它只是一个文件描述符
Dialogue: 0,0:09:38.82,0:09:44.70,Default,,0,0,0,,这将告诉selector，这是一个我们在事件发生时关注的文件号
Dialogue: 0,0:09:44.80,0:09:52.72,Default,,0,0,0,,我们关注的事件则是socket何时处于可写状态
Dialogue: 0,0:09:52.72,0:09:57.04,Default,,0,0,0,,pycharm可以自动为我们导入那个常量(win: Alt+Enter)
Dialogue: 0,0:09:59.34,0:10:00.80,Default,,0,0,0,,我们要做的下一件事是
Dialogue: 0,0:10:00.88,0:10:06.48,Default,,0,0,0,,到目前为止，所做的一切都表明我们关注这个事件中的文件描述符
Dialogue: 0,0:10:06.48,0:10:13.08,Default,,0,0,0,,如果我们调用select 它会等待我们要求的事件发生
Dialogue: 0,0:10:14.13,0:10:15.12,Default,,0,0,0,,所以
Dialogue: 0,0:10:15.12,0:10:16.62,Default,,0,0,0,,一旦这种情况发生
Dialogue: 0,0:10:16.62,0:10:20.16,Default,,0,0,0,,我们可以注销文件号
Dialogue: 0,0:10:21.51,0:10:22.83,Default,,0,0,0,,此时
Dialogue: 0,0:10:24.99,0:10:25.86,Default,,0,0,0,,s(socket)是可写的
Dialogue: 0,0:10:27.93,0:10:31.56,Default,,0,0,0,,这意味着我们可以合法地调用send
Dialogue: 0,0:10:31.56,0:10:33.00,Default,,0,0,0,,如果我现在调用这个
Dialogue: 0,0:10:35.07,0:10:38.04,Default,,0,0,0,,你会看到程序已经越过这行
Dialogue: 0,0:10:38.04,0:10:45.09,Default,,0,0,0,,但是现在这里抛出一个异常，因为这个socket是可写的
Dialogue: 0,0:10:45.09,0:10:52.17,Default,,0,0,0,,但是它还没有变得可读 我们还没有等待服务器开始发送它的响应
Dialogue: 0,0:10:53.49,0:10:55.14,Default,,0,0,0,,所以为了等待服务器
Dialogue: 0,0:10:55.14,0:10:59.55,Default,,0,0,0,,我们必须再做一次同样的操作
Dialogue: 0,0:10:59.55,0:11:04.32,Default,,0,0,0,,这一次我们对可读情况感兴趣而不是可写情况
Dialogue: 0,0:11:04.32,0:11:08.58,Default,,0,0,0,,这里可以用pycharm的自动导入（win: Alt + Enter）
Dialogue: 0,0:11:10.17,0:11:12.03,Default,,0,0,0,,再次等待socket
Dialogue: 0,0:11:12.03,0:11:15.96,Default,,0,0,0,,一旦这个调用完成
Dialogue: 0,0:11:15.96,0:11:20.37,Default,,0,0,0,,那我们就注销文件号
Dialogue: 0,0:11:20.37,0:11:22.42,Default,,0,0,0,,现在我们可以接收数据了
Dialogue: 0,0:11:22.50,0:11:25.17,Default,,0,0,0,,如果我现在运行，它可以正常工作
Dialogue: 0,0:11:25.17,0:11:29.64,Default,,0,0,0,,但我们还没有得到真正想要的效果，还是需要两秒
Dialogue: 0,0:11:29.64,0:11:33.06,Default,,0,0,0,,我们只是把代码弄得一团糟
Dialogue: 0,0:11:33.06,0:11:37.59,Default,,0,0,0,,但我们还没有获得任何效率的提升
Dialogue: 0,0:11:43.20,0:11:44.64,Default,,0,0,0,,那么下一步做什么呢
Dialogue: 0,0:11:46.41,0:11:51.99,Default,,0,0,0,,在使用了非阻塞socket之后的步骤
Dialogue: 0,0:11:51.99,0:11:53.49,Default,,0,0,0,,是回调
Dialogue: 0,0:11:55.08,0:11:56.52,Default,,0,0,0,,我将解释它是如何工作的
Dialogue: 0,0:11:57.60,0:12:07.41,Default,,0,0,0,,回调是一种允许多个操作并发等待I/O操作的方法
Dialogue: 0,0:12:11.76,0:12:13.35,Default,,0,0,0,,首先以这个get函数为例
Dialogue: 0,0:12:14.37,0:12:16.53,Default,,0,0,0,,当开始连接时
Dialogue: 0,0:12:16.53,0:12:23.61,Default,,0,0,0,,一旦socket可写时，注册的回调将被执行
Dialogue: 0,0:12:23.61,0:12:24.92,Default,,0,0,0,,之后它需要返回
Dialogue: 0,0:12:24.98,0:12:33.93,Default,,0,0,0,,这样当我们在等待连接这个socket的时候，就可以开始获取另一个URL
Dialogue: 0,0:12:33.93,0:12:38.46,Default,,0,0,0,,我们需要某种并发手段来优化这两秒的时间
Dialogue: 0,0:12:39.87,0:12:41.19,Default,,0,0,0,,我们来看看它是如何工作的
Dialogue: 0,0:12:42.51,0:12:46.26,Default,,0,0,0,,我们可以先写回调的主体
Dialogue: 0,0:12:46.26,0:12:47.82,Default,,0,0,0,,所以我将它命名为connected函数
Dialogue: 0,0:12:47.82,0:12:49.08,Default,,0,0,0,,这将会执行
Dialogue: 0,0:12:50.19,0:12:54.81,Default,,0,0,0,,一旦socket已连接，它就会执行下一步
Dialogue: 0,0:12:55.98,0:12:58.41,Default,,0,0,0,,但问题是
Dialogue: 0,0:12:58.41,0:13:01.41,Default,,0,0,0,,你可以看到PyCharm有错误提示了
Dialogue: 0,0:13:01.41,0:13:10.95,Default,,0,0,0,,因为在这个新函数中有两个变量没有声明，因为我们在get函数中创建了它们
Dialogue: 0,0:13:12.33,0:13:17.40,Default,,0,0,0,,这两个变量是s和request
Dialogue: 0,0:13:17.40,0:13:21.36,Default,,0,0,0,,假设这些变量通过某种方式传递给connected函数
Dialogue: 0,0:13:23.34,0:13:27.24,Default,,0,0,0,,解决办法是
Dialogue: 0,0:13:27.24,0:13:33.33,Default,,0,0,0,,我们将使用lambda来创建一个闭包来捕获这两个值
Dialogue: 0,0:13:33.33,0:13:35.16,Default,,0,0,0,,所以我们要创建一个Lambda表达式
Dialogue: 0,0:13:36.30,0:13:43.44,Default,,0,0,0,,这样调用Lambda执行connected函数就可以使用这两个变量了
Dialogue: 0,0:13:43.44,0:13:46.44,Default,,0,0,0,,我们把这个叫做lambda回调
Dialogue: 0,0:13:48.21,0:13:50.52,Default,,0,0,0,,现在我们如何使用这个回调？
Dialogue: 0,0:13:50.52,0:13:54.06,Default,,0,0,0,,selector.register
Dialogue: 0,0:13:54.06,0:14:00.87,Default,,0,0,0,,它有特别的隐藏参数，有点像*b-side(唱片的B面，指没被选入专辑的歌)
Dialogue: 0,0:14:00.87,0:14:03.21,Default,,0,0,0,,它被称为data
Dialogue: 0,0:14:03.21,0:14:06.36,Default,,0,0,0,,所以我们要把回调作为data的参数传递给调用者
Dialogue: 0,0:14:06.40,0:14:08.16,Default,,0,0,0,,因为这是Python(动态语言)
Dialogue: 0,0:14:09.75,0:14:15.12,Default,,0,0,0,,data可以是任何东西，所以我们要把lambda作为data参数传入
Dialogue: 0,0:14:17.37,0:14:17.94,Default,,0,0,0,,然后
Dialogue: 0,0:14:19.95,0:14:24.51,Default,,0,0,0,,我们要等到connected被调用时才注销那个文件号
Dialogue: 0,0:14:24.51,0:14:25.47,Default,,0,0,0,,现在
Dialogue: 0,0:14:25.47,0:14:26.97,Default,,0,0,0,,如果我们这样做
Dialogue: 0,0:14:30.45,0:14:32.13,Default,,0,0,0,,不幸的是
Dialogue: 0,0:14:32.13,0:14:33.72,Default,,0,0,0,,我们实际上并没有完成任何工作
Dialogue: 0,0:14:34.86,0:14:36.84,Default,,0,0,0,,因为我们的回调从来没有真正执行过
Dialogue: 0,0:14:37.83,0:14:48.93,Default,,0,0,0,,那么我们如何确保在等待的事件发生的时候，立即执行这个回调呢
Dialogue: 0,0:14:48.93,0:14:53.25,Default,,0,0,0,,为了解决这个问题，我们需要异步框架的第三部分
Dialogue: 0,0:14:53.25,0:14:54.57,Default,,0,0,0,,我们需要一个事件循环
Dialogue: 0,0:14:56.55,0:14:58.17,Default,,0,0,0,,我在这里把它写出来
Dialogue: 0,0:15:00.45,0:15:05.13,Default,,0,0,0,,get函数将首先运行，它会启动一个socket连接
Dialogue: 0,0:15:05.13,0:15:10.23,Default,,0,0,0,,然后它会注册一个回调 当socket是可写的时候就会执行
Dialogue: 0,0:15:10.23,0:15:14.16,Default,,0,0,0,,一旦foo执行完成了，bar也做同样的操作
Dialogue: 0,0:15:14.16,0:15:19.74,Default,,0,0,0,,现在我们有两个非阻塞的socket在连接的过程中
Dialogue: 0,0:15:19.74,0:15:24.45,Default,,0,0,0,,它们都已经在selector中注册了
Dialogue: 0,0:15:24.45,0:15:29.55,Default,,0,0,0,,所以我先运行一个简略的事件循环
Dialogue: 0,0:15:29.55,0:15:33.78,Default,,0,0,0,,写下selector.select
Dialogue: 0,0:15:35.13,0:15:41.49,Default,,0,0,0,,现在让我们用调试器运行到这里，看看select实际返回的是什么
Dialogue: 0,0:15:41.49,0:15:44.61,Default,,0,0,0,,所以我设置了一个断点
Dialogue: 0,0:15:44.61,0:15:47.82,Default,,0,0,0,,现在我们有了这个事件列表
Dialogue: 0,0:15:47.82,0:15:49.98,Default,,0,0,0,,如果我查看这个事件列表
Dialogue: 0,0:15:49.98,0:15:51.96,Default,,0,0,0,,你会看到它是一个列表
Dialogue: 0,0:15:51.96,0:15:53.58,Default,,0,0,0,,它有两个元素
Dialogue: 0,0:15:53.58,0:15:56.64,Default,,0,0,0,,我们来看看第一个元素是什么
Dialogue: 0,0:15:56.64,0:15:58.26,Default,,0,0,0,,它有
Dialogue: 0,0:15:58.26,0:16:00.45,Default,,0,0,0,,它是一个有两个值的元组
Dialogue: 0,0:16:00.45,0:16:02.13,Default,,0,0,0,,第二个值不是很有趣
Dialogue: 0,0:16:02.13,0:16:06.99,Default,,0,0,0,,这只是我们一开始传递的mask
Dialogue: 0,0:16:06.99,0:16:11.04,Default,,0,0,0,,它等于常量EVENT_WRITE的值
Dialogue: 0,0:16:11.04,0:16:15.84,Default,,0,0,0,,但我们已经知道了 因为那是我们唯一感兴趣的事件
Dialogue: 0,0:16:15.84,0:16:18.96,Default,,0,0,0,,它是元组的第一个元素
Dialogue: 0,0:16:18.96,0:16:22.53,Default,,0,0,0,,这个SelectorKey很有趣
Dialogue: 0,0:16:22.53,0:16:28.92,Default,,0,0,0,,当我调用寄存器时 你会看到我传递的数据值
Dialogue: 0,0:16:28.92,0:16:37.08,Default,,0,0,0,,在这个事件列表中得到了这个对象，它的内容是我注册为回调的lambda表达式
Dialogue: 0,0:16:37.10,0:16:41.55,Default,,0,0,0,,让我们执行它
Dialogue: 0,0:16:43.44,0:16:44.91,Default,,0,0,0,,写一个循环
Dialogue: 0,0:16:46.14,0:16:48.00,Default,,0,0,0,,
Dialogue: 0,0:16:49.38,0:16:50.94,Default,,0,0,0,,Mask是我们不关心的东西
Dialogue: 0,0:16:50.94,0:16:51.75,Default,,0,0,0,,它的值是2
Dialogue: 0,0:16:51.75,0:16:53.97,Default,,0,0,0,,它等于常量EVENT_WRITE的值
Dialogue: 0,0:16:53.97,0:16:55.89,Default,,0,0,0,,但是这个事件
Dialogue: 0,0:16:59.61,0:17:04.82,Default,,0,0,0,,它的数据字段是我们之前注册的回调
Dialogue: 0,0:17:04.84,0:17:06.39,Default,,0,0,0,,所以我要叫它cb
Dialogue: 0,0:17:06.39,0:17:08.04,Default,,0,0,0,,然后调用它
Dialogue: 0,0:17:09.60,0:17:14.76,Default,,0,0,0,,现在运行程序,看看会发生什么 这样就可以进入函数内部(F7)
Dialogue: 0,0:17:15.69,0:17:18.36,Default,,0,0,0,,你会发现我们进入这个lambda表达式
Dialogue: 0,0:17:18.36,0:17:26.91,Default,,0,0,0,,而lambda调用connected函数，这个函数的参数有socket和request
Dialogue: 0,0:17:26.91,0:17:27.87,Default,,0,0,0,,request的值是GET /foo
Dialogue: 0,0:17:29.46,0:17:30.99,Default,,0,0,0,,我们运行这个
Dialogue: 0,0:17:33.30,0:17:38.70,Default,,0,0,0,,我们需要在这里做同样的转换
Dialogue: 0,0:17:40.65,0:17:41.70,Default,,0,0,0,,我们来修改一下
Dialogue: 0,0:17:44.04,0:17:45.27,Default,,0,0,0,,我们可以说
Dialogue: 0,0:17:48.75,0:17:49.71,Default,,0,0,0,,回调
Dialogue: 0,0:17:51.12,0:17:52.44,Default,,0,0,0,,因为当socket是可读时
Dialogue: 0,0:17:52.44,0:17:54.18,Default,,0,0,0,,将函数命名为readable
Dialogue: 0,0:17:54.34,0:18:07.02,Default,,0,0,0,,和connected函数需要接收参数的方式是一样的
Dialogue: 0,0:18:07.36,0:18:09.33,Default,,0,0,0,,在这个函数中仍然需要socket参数
Dialogue: 0,0:18:09.33,0:18:11.34,Default,,0,0,0,,它不需要请求 我们已经完成了
Dialogue: 0,0:18:11.34,0:18:13.35,Default,,0,0,0,,但它确实需要一个分块的列表
Dialogue: 0,0:18:14.79,0:18:19.05,Default,,0,0,0,,所以它会把这两个作为参数
Dialogue: 0,0:18:19.05,0:18:21.93,Default,,0,0,0,,当它被执行时
Dialogue: 0,0:18:21.93,0:18:25.50,Default,,0,0,0,,它知道s在这个时候是可读的
Dialogue: 0,0:18:26.58,0:18:31.71,Default,,0,0,0,,所以它可以注销它的文件描述符并接收一个分块
Dialogue: 0,0:18:31.71,0:18:33.15,Default,,0,0,0,,我们知道这个分块
Dialogue: 0,0:18:34.11,0:18:34.74,Default,,0,0,0,,嗯
Dialogue: 0,0:18:34.74,0:18:39.72,Default,,0,0,0,,我们知道这不会引发异常 因为select调用
Dialogue: 0,0:18:40.71,0:18:45.87,Default,,0,0,0,,在这里确保了我们在这个socket上等待的事件都准备好了
Dialogue: 0,0:18:46.80,0:18:53.25,Default,,0,0,0,,所以这里不会出现资源不可用或其他异常
Dialogue: 0,0:18:54.33,0:18:58.71,Default,,0,0,0,,数据块要么包含一些内容 或者服务器已经关闭
Dialogue: 0,0:18:58.71,0:19:00.42,Default,,0,0,0,,那么这个分块就是空的
Dialogue: 0,0:19:00.42,0:19:01.41,Default,,0,0,0,,我们知道我们已经传完数据了
Dialogue: 0,0:19:03.84,0:19:06.15,Default,,0,0,0,,在这里
Dialogue: 0,0:19:06.15,0:19:08.22,Default,,0,0,0,,这意味着我们不调用select
Dialogue: 0,0:19:08.22,0:19:12.30,Default,,0,0,0,,因为这是事件循环的工作
Dialogue: 0,0:19:12.30,0:19:15.15,Default,,0,0,0,,但我们确实需要创建回调
Dialogue: 0,0:19:16.02,0:19:20.53,Default,,0,0,0,,它和我们之前创建的回调非常相似
Dialogue: 0,0:19:20.53,0:19:24.24,Default,,0,0,0,,还是一个由lambda表达式创建的闭包
Dialogue: 0,0:19:24.24,0:19:25.65,Default,,0,0,0,,当我们执行它的时候
Dialogue: 0,0:19:27.03,0:19:29.73,Default,,0,0,0,,我们要传入socket和chunks变量
Dialogue: 0,0:19:29.73,0:19:31.89,Default,,0,0,0,,这不再是一个循环
Dialogue: 0,0:19:31.89,0:19:32.94,Default,,0,0,0,,我们只是注册
Dialogue: 0,0:19:35.97,0:19:37.89,Default,,0,0,0,,回调一次 然后我们就做完了
Dialogue: 0,0:19:40.05,0:19:41.34,Default,,0,0,0,,这意味着
Dialogue: 0,0:19:41.34,0:19:43.96,Default,,0,0,0,,既然我们没有死循环了
Dialogue: 0,0:19:44.18,0:19:47.64,Default,,0,0,0,,如果在这里我们有分块
Dialogue: 0,0:19:47.64,0:19:51.60,Default,,0,0,0,,我们需要等待剩下的部分
Dialogue: 0,0:19:51.60,0:19:52.95,Default,,0,0,0,,所以我们不能就这样离开这里
Dialogue: 0,0:19:52.95,0:19:53.73,Default,,0,0,0,,我们还要做些工作
Dialogue: 0,0:19:55.80,0:19:59.19,Default,,0,0,0,,给Callback赋值另一个闭包
Dialogue: 0,0:19:59.19,0:20:06.98,Default,,0,0,0,,这将引起对readable函数的二次调用
Dialogue: 0,0:20:07.12,0:20:13.58,Default,,0,0,0,,我们要在这里重新注册刚才注销的socket
Dialogue: 0,0:20:13.58,0:20:16.59,Default,,0,0,0,,这里的return就没有必要了
Dialogue: 0,0:20:18.12,0:20:19.44,Default,,0,0,0,,如果我们运行这个
Dialogue: 0,0:20:21.15,0:20:22.02,Default,,0,0,0,,我们会看到的
Dialogue: 0,0:20:23.70,0:20:26.22,Default,,0,0,0,,我们的两个请求现在都完成了
Dialogue: 0,0:20:26.22,0:20:27.54,Default,,0,0,0,,这是坠吼的
Dialogue: 0,0:20:27.54,0:20:29.07,Default,,0,0,0,,但不幸的是
Dialogue: 0,0:20:30.12,0:20:36.87,Default,,0,0,0,,我们看不到她的最终输出 因为我们在这个死循环里
Dialogue: 0,0:20:36.87,0:20:42.06,Default,,0,0,0,,所以我们被阻塞在这个selector上，因为没有什么可以做的了
Dialogue: 0,0:20:42.06,0:20:44.43,Default,,0,0,0,,但是我们还没有让循环完成
Dialogue: 0,0:20:44.43,0:20:46.44,Default,,0,0,0,,如果我们点击这里的停止
Dialogue: 0,0:20:46.44,0:20:47.16,Default,,0,0,0,,我们会看到的
Dialogue: 0,0:20:49.02,0:20:50.91,Default,,0,0,0,,我们卡在这行语句上了
Dialogue: 0,0:20:53.04,0:21:02.28,Default,,0,0,0,,所以我认为结束这个循环的正确方法是 搞清楚任务何时完成，然后退出循环
Dialogue: 0,0:21:02.28,0:21:06.54,Default,,0,0,0,,所以我设置了任务数这个变量
Dialogue: 0,0:21:07.47,0:21:10.50,Default,,0,0,0,,这个变量贯穿整个执行过程
Dialogue: 0,0:21:12.54,0:21:13.89,Default,,0,0,0,,刚开始时
Dialogue: 0,0:21:13.89,0:21:14.85,Default,,0,0,0,,没有任务在执行
Dialogue: 0,0:21:16.14,0:21:17.97,Default,,0,0,0,,一旦我们调用get函数
Dialogue: 0,0:21:24.45,0:21:29.97,Default,,0,0,0,,就会增加任务数
Dialogue: 0,0:21:30.99,0:21:37.77,Default,,0,0,0,,当我们读完服务器的响应时
Dialogue: 0,0:21:40.29,0:21:45.15,Default,,0,0,0,,就可以把任务数减1了
Dialogue: 0,0:21:47.25,0:21:52.22,Default,,0,0,0,,所以当我们调用get foo的时候把任务数增加到1
Dialogue: 0,0:21:52.24,0:21:56.01,Default,,0,0,0,,当调用get bar 时，任务数又加1
Dialogue: 0,0:21:56.01,0:21:56.55,Default,,0,0,0,,然后
Dialogue: 0,0:21:56.55,0:22:00.42,Default,,0,0,0,,当回调链都结束时
Dialogue: 0,0:22:00.42,0:22:02.01,Default,,0,0,0,,就将任务数减1
Dialogue: 0,0:22:02.01,0:22:08.91,Default,,0,0,0,,直到这个事件循环的n_tasks为零时退出
Dialogue: 0,0:22:10.50,0:22:12.15,Default,,0,0,0,,如果我们运行这个
Dialogue: 0,0:22:12.15,0:22:22.08,Default,,0,0,0,,然后我们会看到这两个请求都完成了 奇迹般地只花了一秒而不是两秒
Dialogue: 0,0:22:22.08,0:22:24.30,Default,,0,0,0,,我们可以做到
Dialogue: 0,0:22:26.04,0:22:26.40,Default,,0,0,0,,哦
Dialogue: 0,0:22:29.58,0:22:35.94,Default,,0,0,0,,更多的并发请求 还是只需要一秒
Dialogue: 0,0:22:36.87,0:22:40.68,Default,,0,0,0,,这样做的原因是服务器太慢了
Dialogue: 0,0:22:40.74,0:22:48.36,Default,,0,0,0,,与从服务器上等待下一个分段的时间相比
Dialogue: 0,0:22:48.56,0:22:53.07,Default,,0,0,0,,（本地）客户端不用消耗大量的CPU资源去处理每一个响应
Dialogue: 0,0:22:53.07,0:22:57.92,Default,,0,0,0,,服务器需要整整1秒才能返回几百字节的数据
Dialogue: 0,0:22:58.38,0:23:03.54,Default,,0,0,0,,而客户端所做的只是将这些数据块插入到一个列表中
Dialogue: 0,0:23:03.54,0:23:07.36,Default,,0,0,0,,因此 客户端几乎没有CPU开销
Dialogue: 0,0:23:07.44,0:23:13.44,Default,,0,0,0,,而在绝大多数时间内都是在等待I/O
Dialogue: 0,0:23:13.89,0:23:18.66,Default,,0,0,0,,这就是异步优化的应用场景
Dialogue: 0,0:23:18.66,0:23:26.50,Default,,0,0,0,,我们可以用一个简单的框架来做几十个甚至上百个并发的请求
Dialogue: 0,0:23:26.78,0:23:33.75,Default,,0,0,0,,而不用在运算上损失大量的时间
Dialogue: 0,0:23:33.75,0:23:39.66,Default,,0,0,0,,它非常高效 因为它不需要保持空闲线程就可以达到同样的效果
Dialogue: 0,0:23:41.76,0:23:43.14,Default,,0,0,0,,这很好
Dialogue: 0,0:23:43.14,0:23:44.19,Default,,0,0,0,,它非常高效
Dialogue: 0,0:23:44.19,0:23:52.23,Default,,0,0,0,,但你也会发现 与简单的初始get函数相比，现在就是一团乱麻
Dialogue: 0,0:23:52.23,0:23:55.53,Default,,0,0,0,,我们现在写了一堆乱七八糟的东西
Dialogue: 0,0:23:55.53,0:23:57.48,Default,,0,0,0,,我们现在需要三个函数
Dialogue: 0,0:23:57.48,0:23:58.83,Default,,0,0,0,,原来只需要一个
Dialogue: 0,0:24:00.03,0:24:01.44,Default,,0,0,0,,这三个函数
Dialogue: 0,0:24:02.76,0:24:07.74,Default,,0,0,0,,关于它们的特别之处在于 每当一个函数退出时
Dialogue: 0,0:24:07.74,0:24:17.10,Default,,0,0,0,,它失去了所有的局部变量，例如s、request和chunks
Dialogue: 0,0:24:17.50,0:24:26.28,Default,,0,0,0,,当一个回调函数完成时，需要将下一个回调注册到调用链中
Dialogue: 0,0:24:26.28,0:24:34.08,Default,,0,0,0,,它必须手动将它的状态复制到一个闭包中 这样就可以在调用链的下一个回调中使用这个状态
Dialogue: 0,0:24:35.28,0:24:44.46,Default,,0,0,0,,语言提供给我们的基础设施，比如堆栈和局部变量
Dialogue: 0,0:24:44.46,0:24:48.69,Default,,0,0,0,,在我们的异步框架中，必须手动重新创建它们
Dialogue: 0,0:24:48.69,0:24:56.85,Default,,0,0,0,,在维持I/O状态时，语言特性对我们来说基本上没有帮助
Dialogue: 0,0:24:58.41,0:25:01.68,Default,,0,0,0,,所以问题的解决方案来到了下一个阶段
Dialogue: 0,0:25:01.68,0:25:03.27,Default,,0,0,0,,协程
Dialogue: 0,0:25:04.44,0:25:08.82,Default,,0,0,0,,协程建立在Future类上
Dialogue: 0,0:25:10.41,0:25:15.03,Default,,0,0,0,,这是我们稍后在介绍python生成器时看到的类
Dialogue: 0,0:25:16.71,0:25:20.07,Default,,0,0,0,,我们稍后将会看到另一个叫做Task的类
Dialogue: 0,0:25:21.24,0:25:24.57,Default,,0,0,0,,现在很多协程的概念
Dialogue: 0,0:25:24.57,0:25:26.67,Default,,0,0,0,,协程这个概念其实很早就有了
Dialogue: 0,0:25:26.67,0:25:31.54,Default,,0,0,0,,协程在不同的语言中有不同的实现
Dialogue: 0,0:25:32.81,0:25:36.12,Default,,0,0,0,,在Python3的asyncio中
Dialogue: 0,0:25:36.12,0:25:38.10,Default,,0,0,0,,当我们说协程的时候
Dialogue: 0,0:25:39.90,0:25:43.68,Default,,0,0,0,,指的是基于生成器的协程
Dialogue: 0,0:25:45.84,0:25:49.35,Default,,0,0,0,,Greenlet在Python3.5中也被称作协程
Dialogue: 0,0:25:49.35,0:25:56.85,Default,,0,0,0,,现在有了新的原生协程 可以利用新的async和await关键字
Dialogue: 0,0:25:56.85,0:26:00.48,Default,,0,0,0,,它们本质上是基于生成器的语法糖
Dialogue: 0,0:26:00.48,0:26:04.20,Default,,0,0,0,,所以如果你理解了我们之后讨论的内容
Dialogue: 0,0:26:04.20,0:26:09.63,Default,,0,0,0,,就能同时了解Python3.5中原生协程的工作方式
Dialogue: 0,0:26:09.63,0:26:13.53,Default,,0,0,0,,尽管它们是内置在解释器里而不是直接用生成器写的
Dialogue: 0,0:26:13.53,0:26:14.55,Default,,0,0,0,,这是我们现在要做的（用生成器实现）
Dialogue: 0,0:26:16.83,0:26:17.25,Default,,0,0,0,,所以
Dialogue: 0,0:26:18.72,0:26:21.93,Default,,0,0,0,,我们首先需要的是一个future类
Dialogue: 0,0:26:22.83,0:26:25.59,Default,,0,0,0,,稍后，你们会明白为什么它很有用
Dialogue: 0,0:26:25.59,0:26:29.76,Default,,0,0,0,,我先把它写出来
Dialogue: 0,0:26:29.76,0:26:34.35,Default,,0,0,0,,你现在只需要相信这将会是一个有用的东西
Dialogue: 0,0:26:34.35,0:26:41.16,Default,,0,0,0,,future类代表着一些我们正在等待但尚未完成的事件
Dialogue: 0,0:26:42.24,0:26:48.90,Default,,0,0,0,,它有一个事件发生时将要被执行的回调列表
Dialogue: 0,0:26:48.90,0:26:53.88,Default,,0,0,0,,当事件发生时，会调用resolve函数，
Dialogue: 0,0:26:57.96,0:27:02.16,Default,,0,0,0,,future类会执行所有等待该事件的回调
Dialogue: 0,0:27:02.16,0:27:03.48,Default,,0,0,0,,这就是我们的future类
Dialogue: 0,0:27:04.65,0:27:12.36,Default,,0,0,0,,我们要简单地修改代码，而不是直接用selector来注册和回调
Dialogue: 0,0:27:12.36,0:27:14.10,Default,,0,0,0,,我们要注册futures类
Dialogue: 0,0:27:24.63,0:27:29.19,Default,,0,0,0,,所以我们将回调添加到future的回调列表中
Dialogue: 0,0:27:29.19,0:27:33.33,Default,,0,0,0,,等待这个future来执行回调 而不是直接注册回调
Dialogue: 0,0:27:34.29,0:27:35.79,Default,,0,0,0,,我们注册future
Dialogue: 0,0:27:37.56,0:27:42.21,Default,,0,0,0,,这里也做相同操作
Dialogue: 0,0:27:45.48,0:27:46.50,Default,,0,0,0,,最后
Dialogue: 0,0:27:46.50,0:27:51.03,Default,,0,0,0,,我们必须再做一次麻烦的重构
Dialogue: 0,0:27:54.69,0:27:57.06,Default,,0,0,0,,在我们注册回调的三个地方
Dialogue: 0,0:27:57.06,0:28:00.72,Default,,0,0,0,,我们现在给futures加入回调，并对futures进行了注册
Dialogue: 0,0:28:02.01,0:28:05.28,Default,,0,0,0,,这意味着在我们的事件循环中
Dialogue: 0,0:28:06.54,0:28:11.52,Default,,0,0,0,,data不再是回调，而是future对象
Dialogue: 0,0:28:11.52,0:28:12.99,Default,,0,0,0,,所以我们不直接调用它
Dialogue: 0,0:28:12.99,0:28:15.33,Default,,0,0,0,,而是调用它的resolve方法
Dialogue: 0,0:28:16.62,0:28:19.14,Default,,0,0,0,,所以你可以预测一下
Dialogue: 0,0:28:19.14,0:28:22.62,Default,,0,0,0,,进行简单的修改之后，很可能得到正确的结果
Dialogue: 0,0:28:22.62,0:28:26.13,Default,,0,0,0,,看上去我做到了
Dialogue: 0,0:28:26.13,0:28:31.44,Default,,0,0,0,,到目前为止，我们所做的一切都把代码变的又杂乱又冗长
Dialogue: 0,0:28:31.44,0:28:35.34,Default,,0,0,0,,程序的性能和之前的一样
Dialogue: 0,0:28:36.57,0:28:44.64,Default,,0,0,0,,所以下一步就是用future类和生成器来实现协程
Dialogue: 0,0:28:46.98,0:28:51.98,Default,,0,0,0,,所以我要快速复习一下生成器
Dialogue: 0,0:28:52.10,0:28:55.62,Default,,0,0,0,,生成器有一些难以理解的特性
Dialogue: 0,0:28:55.62,0:28:59.07,Default,,0,0,0,,即使对经验丰富的python程序员来说也是如此
Dialogue: 0,0:29:00.51,0:29:05.32,Default,,0,0,0,,生成器是用生成器函数创建的
Dialogue: 0,0:29:05.56,0:29:12.87,Default,,0,0,0,,生成器函数是任何包含的yield表达式的函数
Dialogue: 0,0:29:13.98,0:29:16.89,Default,,0,0,0,,所以这个生成器函数将会打印start和1
Dialogue: 0,0:29:18.66,0:29:19.20,Default,,0,0,0,,Middle
Dialogue: 0,0:29:20.58,0:29:21.06,Default,,0,0,0,,还有2
Dialogue: 0,0:29:23.37,0:29:24.06,Default,,0,0,0,,最后打印done
Dialogue: 0,0:29:25.92,0:29:31.53,Default,,0,0,0,,生成器函数的有趣之处在于 当你执行它时
Dialogue: 0,0:29:31.53,0:29:32.94,Default,,0,0,0,,它实际上并没有运行它的代码
Dialogue: 0,0:29:33.99,0:29:36.12,Default,,0,0,0,,它没有打印start middle或done
Dialogue: 0,0:29:36.32,0:29:40.72,Default,,0,0,0,,而是创建了一个生成器对象
Dialogue: 0,0:29:41.20,0:29:50.52,Default,,0,0,0,,这个生成器对象包含一个代码对象,即用来表示这些内容的字节码（co_code）
Dialogue: 0,0:29:51.45,0:29:52.08,Default,,0,0,0,,然后
Dialogue: 0,0:29:53.13,0:29:59.48,Default,,0,0,0,,它有44个字节
Dialogue: 0,0:29:59.48,0:30:02.82,Default,,0,0,0,,生成器自身也有一个栈帧
Dialogue: 0,0:30:03.93,0:30:05.61,Default,,0,0,0,,它有一个指令指针
Dialogue: 0,0:30:05.61,0:30:07.89,Default,,0,0,0,,初始值为-1
Dialogue: 0,0:30:07.89,0:30:11.70,Default,,0,0,0,,也就是说它还没有执行任何指令
Dialogue: 0,0:30:12.69,0:30:16.53,Default,,0,0,0,,这就是为什么我们没有看到这些print语句的输出
Dialogue: 0,0:30:17.85,0:30:22.47,Default,,0,0,0,,运行一个生成器的方法是对它调用next函数
Dialogue: 0,0:30:23.73,0:30:25.32,Default,,0,0,0,,如果你这样做
Dialogue: 0,0:30:25.32,0:30:30.72,Default,,0,0,0,,然后你会看到它执行了最初的一些字节码
Dialogue: 0,0:30:30.72,0:30:32.52,Default,,0,0,0,,所以它打印start
Dialogue: 0,0:30:32.68,0:30:36.78,Default,,0,0,0,,1 实际上是next语句的返回值
Dialogue: 0,0:30:36.92,0:30:42.36,Default,,0,0,0,,因为next()的返回值由next执行的yield语句决定
Dialogue: 0,0:30:43.35,0:30:50.34,Default,,0,0,0,,现在 指令指针暂停在第13个字节处
Dialogue: 0,0:30:51.51,0:30:54.22,Default,,0,0,0,,所以如果我们再次调用next
Dialogue: 0,0:30:54.22,0:31:00.96,Default,,0,0,0,,我要保存它的返回值 这样你就能看到它打印出middle
Dialogue: 0,0:31:02.64,0:31:05.64,Default,,0,0,0,,但它返回2
Dialogue: 0,0:31:06.60,0:31:11.55,Default,,0,0,0,,这是下一个yield语句传递出的值
Dialogue: 0,0:31:12.90,0:31:17.04,Default,,0,0,0,,现在我们的堆栈指针(口误)
Dialogue: 0,0:31:17.04,0:31:17.40,Default,,0,0,0,,对不起
Dialogue: 0,0:31:17.40,0:31:20.34,Default,,0,0,0,,我们的指示指针来到第28字节
Dialogue: 0,0:31:21.57,0:31:24.84,Default,,0,0,0,,如果我们再次调用next
Dialogue: 0,0:31:25.83,0:31:28.95,Default,,0,0,0,,然后我们将看到停止迭代异常
Dialogue: 0,0:31:28.95,0:31:30.15,Default,,0,0,0,,这说明
Dialogue: 0,0:31:31.05,0:31:38.64,Default,,0,0,0,,它已经完成了 lasti指针已经被删除了
Dialogue: 0,0:31:40.38,0:31:46.74,Default,,0,0,0,,这就是生成器如何在Python2.5及之前版本的中工作的
Dialogue: 0,0:31:49.02,0:31:52.53,Default,,0,0,0,,那么我们如何用它来实现协程呢
Dialogue: 0,0:31:54.60,0:31:55.02,Default,,0,0,0,,嗯
Dialogue: 0,0:31:55.02,0:31:56.25,Default,,0,0,0,,先做一个设想
Dialogue: 0,0:31:57.81,0:31:59.67,Default,,0,0,0,,我们的想法是这样的
Dialogue: 0,0:32:00.87,0:32:02.79,Default,,0,0,0,,这个get函数
Dialogue: 0,0:32:04.95,0:32:10.26,Default,,0,0,0,,需要创建一个闭包 以捕获他的局部变量
Dialogue: 0,0:32:12.03,0:32:13.92,Default,,0,0,0,,将其命名为callback
Dialogue: 0,0:32:14.94,0:32:20.58,Default,,0,0,0,,向future增加回调 然后注册future到selector
Dialogue: 0,0:32:21.93,0:32:25.38,Default,,0,0,0,,这个回调完全可以简化
Dialogue: 0,0:32:26.94,0:32:29.64,Default,,0,0,0,,所以我要删除回调
Dialogue: 0,0:32:29.64,0:32:31.71,Default,,0,0,0,,删除回调主体
Dialogue: 0,0:32:34.02,0:32:39.08,Default,,0,0,0,,但我们需要暂停直至socket可写
Dialogue: 0,0:32:39.20,0:32:47.40,Default,,0,0,0,,在我们注销它之前，这里是可写的。当socket可写时，就可以调用send
Dialogue: 0,0:32:47.76,0:32:51.87,Default,,0,0,0,,我们的想法是
Dialogue: 0,0:32:51.87,0:32:53.49,Default,,0,0,0,,通过yield f
Dialogue: 0,0:32:53.49,0:32:54.96,Default,,0,0,0,,这个我们刚刚创建的future对象
Dialogue: 0,0:32:56.49,0:33:05.01,Default,,0,0,0,,我们可以用某种方式暂停这个生成器 直到我们感兴趣的事件发生
Dialogue: 0,0:33:07.95,0:33:11.61,Default,,0,0,0,,如果我们认为这个设想可行
Dialogue: 0,0:33:12.63,0:33:20.85,Default,,0,0,0,,然后 我们可以将两个函数合并成包含yield语句的单一生成器函数
Dialogue: 0,0:33:22.74,0:33:28.74,Default,,0,0,0,,但这个设想还没有实现,因为如果我运行这个
Dialogue: 0,0:33:28.74,0:33:30.21,Default,,0,0,0,,它将花费0秒
Dialogue: 0,0:33:30.21,0:33:31.71,Default,,0,0,0,,它没有输出
Dialogue: 0,0:33:31.71,0:33:33.03,Default,,0,0,0,,没有实现想要的效果
Dialogue: 0,0:33:34.80,0:33:35.82,Default,,0,0,0,,为什么呢
Dialogue: 0,0:33:35.82,0:33:36.66,Default,,0,0,0,,这里发生了什么
Dialogue: 0,0:33:38.64,0:33:39.21,Default,,0,0,0,,嗯
Dialogue: 0,0:33:39.21,0:33:42.03,Default,,0,0,0,,回想一下 当你执行一个生成器函数时
Dialogue: 0,0:33:42.03,0:33:46.50,Default,,0,0,0,,它会返回生成器，实际上并不运行它的任何代码
Dialogue: 0,0:33:46.50,0:33:49.92,Default,,0,0,0,,现在我在这里添加了一个yield语句
Dialogue: 0,0:33:49.92,0:33:51.81,Default,,0,0,0,,这意味着这里的get语句
Dialogue: 0,0:33:54.36,0:33:55.83,Default,,0,0,0,,只返回了一个生成器
Dialogue: 0,0:33:57.66,0:33:59.67,Default,,0,0,0,,实际上什么都没做
Dialogue: 0,0:33:59.67,0:34:00.57,Default,,0,0,0,,这里也是一样
Dialogue: 0,0:34:01.80,0:34:09.09,Default,,0,0,0,,那么我们要怎么执行它呢
Dialogue: 0,0:34:09.09,0:34:10.65,Default,,0,0,0,,如何对它执行next方法呢
Dialogue: 0,0:34:12.66,0:34:22.14,Default,,0,0,0,,这就是这个基于协程的异步框架的第三个部分：Task类
Dialogue: 0,0:34:23.37,0:34:24.48,Default,,0,0,0,,Task类
Dialogue: 0,0:34:26.25,0:34:31.20,Default,,0,0,0,,它负责在生成器上调用next
Dialogue: 0,0:34:32.34,0:34:34.98,Default,,0,0,0,,我们来看看它是什么样的
Dialogue: 0,0:34:34.98,0:34:37.23,Default,,0,0,0,,同时使用future和task类时
Dialogue: 0,0:34:37.23,0:34:45.15,Default,,0,0,0,,现在写的这些内容非常简单，或者说过于简单了，而且实现并不完善
Dialogue: 0,0:34:45.15,0:34:48.99,Default,,0,0,0,,不过这些想法在许多框架中得到了充分体现
Dialogue: 0,0:34:48.99,0:35:00.21,Default,,0,0,0,,尤其是tornado和python3.4标准库中的asyncio
Dialogue: 0,0:35:01.59,0:35:08.10,Default,,0,0,0,,所以我的丐版Task类的实现如下：
Dialogue: 0,0:35:09.54,0:35:12.90,Default,,0,0,0,,我们将用生成器初始化它
Dialogue: 0,0:35:14.61,0:35:15.60,Default,,0,0,0,,我将保存它
Dialogue: 0,0:35:17.28,0:35:20.79,Default,,0,0,0,,然后我们会有一个叫做Step的函数
Dialogue: 0,0:35:20.79,0:35:24.36,Default,,0,0,0,,这个术语是从asyncio那里借来的
Dialogue: 0,0:35:24.36,0:35:28.32,Default,,0,0,0,,step函数的任务就是在生成器上调用next
Dialogue: 0,0:35:30.18,0:35:35.10,Default,,0,0,0,,生成器将会yield一个future对象
Dialogue: 0,0:35:36.87,0:35:40.77,Default,,0,0,0,,这就变成了next()的返回值
Dialogue: 0,0:35:40.77,0:35:43.71,Default,,0,0,0,,我们来捕获它
Dialogue: 0,0:35:46.02,0:35:46.68,Default,,0,0,0,,然后
Dialogue: 0,0:35:48.33,0:35:51.00,Default,,0,0,0,,当这个future执行完回调时 我们想要达成什么目的？
Dialogue: 0,0:35:51.93,0:35:56.79,Default,,0,0,0,,我们需要给future增加一些回调
Dialogue: 0,0:35:56.79,0:35:59.82,Default,,0,0,0,,这是我们想要在future就绪时执行的动作
Dialogue: 0,0:35:59.96,0:36:07.47,Default,,0,0,0,,让我们把self.step作为回调
Dialogue: 0,0:36:07.47,0:36:09.90,Default,,0,0,0,,所以一旦这个future完成之后
Dialogue: 0,0:36:09.90,0:36:13.47,Default,,0,0,0,,就会回到这里 然后再次对self.gen执行next
Dialogue: 0,0:36:15.00,0:36:18.33,Default,,0,0,0,,当再次对self.gen执行next时
Dialogue: 0,0:36:18.33,0:36:20.76,Default,,0,0,0,,程序这将在这里恢复执行
Dialogue: 0,0:36:24.42,0:36:28.65,Default,,0,0,0,,因此我们知道我们可以注销socket文件号
Dialogue: 0,0:36:28.65,0:36:30.00,Default,,0,0,0,,现在socket是可写的
Dialogue: 0,0:36:31.35,0:36:35.52,Default,,0,0,0,,所以如果我们运行它 它仍然不会起作用
Dialogue: 0,0:36:37.11,0:36:38.73,Default,,0,0,0,,原因是
Dialogue: 0,0:36:41.16,0:36:45.06,Default,,0,0,0,,我们需要对self.step做一个初始的调用
Dialogue: 0,0:36:45.06,0:36:54.09,Default,,0,0,0,,我们给self.gen做了一个初始的调用(预激)这样我们就启动了get函数
Dialogue: 0,0:36:54.09,0:36:55.95,Default,,0,0,0,,它会连接socket 等等
Dialogue: 0,0:36:55.95,0:36:58.83,Default,,0,0,0,,我们在这里改一下
Dialogue: 0,0:36:58.83,0:36:59.64,Default,,0,0,0,,在构造函数中
Dialogue: 0,0:37:02.49,0:37:09.87,Default,,0,0,0,,然后是这个修改的最后一步，下面这里
Dialogue: 0,0:37:09.87,0:37:14.90,Default,,0,0,0,,我们需要用task把这些get调用包起来
Dialogue: 0,0:37:15.00,0:37:18.15,Default,,0,0,0,,当get返回一个生成器时，task对象会把它包起来
Dialogue: 0,0:37:19.74,0:37:23.84,Default,,0,0,0,,保存到self.gen中，然后调用self.step
Dialogue: 0,0:37:23.92,0:37:34.50,Default,,0,0,0,,之后就会调用next，真正地执行代码直至第一个yield语句
Dialogue: 0,0:37:34.50,0:37:35.70,Default,,0,0,0,,如果我运行这个
Dialogue: 0,0:37:38.34,0:37:39.12,Default,,0,0,0,,在某种程度上
Dialogue: 0,0:37:39.12,0:37:41.19,Default,,0,0,0,,你会看到我们已经有些进步了
Dialogue: 0,0:37:42.15,0:37:45.57,Default,,0,0,0,,因为我们在这里抛出了一个停止迭代异常
Dialogue: 0,0:37:47.19,0:37:49.38,Default,,0,0,0,,所以这确实是个好消息
Dialogue: 0,0:37:49.38,0:37:55.80,Default,,0,0,0,,因为这意味着这个get生成器实际上已经运行到结束了
Dialogue: 0,0:37:55.80,0:37:59.70,Default,,0,0,0,,它完成了它所要做的工作
Dialogue: 0,0:37:59.70,0:38:01.41,Default,,0,0,0,,所以
Dialogue: 0,0:38:01.41,0:38:02.37,Default,,0,0,0,,如果我们
Dialogue: 0,0:38:04.08,0:38:04.98,Default,,0,0,0,,catch一下异常
Dialogue: 0,0:38:05.94,0:38:07.14,Default,,0,0,0,,我们想在这里做什么
Dialogue: 0,0:38:07.14,0:38:07.47,Default,,0,0,0,,嗯
Dialogue: 0,0:38:07.47,0:38:08.43,Default,,0,0,0,,task完成了
Dialogue: 0,0:38:08.43,0:38:10.11,Default,,0,0,0,,直接返回
Dialogue: 0,0:38:11.34,0:38:12.93,Default,,0,0,0,,如果我们执行这个版本
Dialogue: 0,0:38:14.37,0:38:15.54,Default,,0,0,0,,实际上已经成功了
Dialogue: 0,0:38:16.53,0:38:22.80,Default,,0,0,0,,吼啊 我们还有一些零散的回调
Dialogue: 0,0:38:23.67,0:38:24.63,Default,,0,0,0,,所以
Dialogue: 0,0:38:25.62,0:38:28.98,Default,,0,0,0,,我们可以删去这些，在这里做同样的修改
Dialogue: 0,0:38:30.33,0:38:32.43,Default,,0,0,0,,所以在这里做同样的操作
Dialogue: 0,0:38:32.43,0:38:33.33,Default,,0,0,0,,所以我们要
Dialogue: 0,0:38:33.33,0:38:34.95,Default,,0,0,0,,我们再也不需要这个调用了
Dialogue: 0,0:38:35.94,0:38:37.50,Default,,0,0,0,,你不需要把它加到future中
Dialogue: 0,0:38:38.46,0:38:46.68,Default,,0,0,0,,我们仍然需要说明我们关注的事件，并注册future对象
Dialogue: 0,0:38:46.68,0:38:50.01,Default,,0,0,0,,但是我们可以删除回调定义
Dialogue: 0,0:38:51.06,0:38:55.71,Default,,0,0,0,,因为我们在之前的同一个函数中
Dialogue: 0,0:38:55.71,0:38:59.01,Default,,0,0,0,,我们不需要一个冗余的全局声明
Dialogue: 0,0:39:00.27,0:39:06.48,Default,,0,0,0,,如果我们简单地yield我们新定义的future
Dialogue: 0,0:39:06.48,0:39:07.44,Default,,0,0,0,,这意味着
Dialogue: 0,0:39:08.76,0:39:09.42,Default,,0,0,0,,到目前为止
Dialogue: 0,0:39:09.42,0:39:13.71,Default,,0,0,0,,当task恢复的时候
Dialogue: 0,0:39:13.71,0:39:14.88,Default,,0,0,0,,这个socket现在是可读的
Dialogue: 0,0:39:17.97,0:39:21.57,Default,,0,0,0,,这是最后一个回调
Dialogue: 0,0:39:21.57,0:39:22.80,Default,,0,0,0,,我们可以把它删掉
Dialogue: 0,0:39:24.00,0:39:29.46,Default,,0,0,0,,我们可以yield我们的future 而不是注册一个回调
Dialogue: 0,0:39:36.72,0:39:42.18,Default,,0,0,0,,当我们收到下一个分块时 我们要做什么
Dialogue: 0,0:39:42.18,0:39:42.78,Default,,0,0,0,,换句话说
Dialogue: 0,0:39:42.78,0:39:45.39,Default,,0,0,0,,当socket再次处于可读状态
Dialogue: 0,0:39:46.68,0:39:50.46,Default,,0,0,0,,我们想要得到下一个分块，对吧？
Dialogue: 0,0:39:50.46,0:39:54.12,Default,,0,0,0,,所以我们最后要做的是
Dialogue: 0,0:39:54.24,0:40:05.13,Default,,0,0,0,,借鉴在教程刚开始的时候写的死循环
Dialogue: 0,0:40:05.13,0:40:08.10,Default,,0,0,0,,那时我们只写了一个简单的阻塞get函数
Dialogue: 0,0:40:09.06,0:40:10.83,Default,,0,0,0,,所以它看起来是这样的
Dialogue: 0,0:40:14.07,0:40:18.18,Default,,0,0,0,,我们要把这个放在循环中
Dialogue: 0,0:40:19.65,0:40:22.68,Default,,0,0,0,,每次执行循环时
Dialogue: 0,0:40:22.68,0:40:25.89,Default,,0,0,0,,我想从socket上读取数据
Dialogue: 0,0:40:25.89,0:40:28.14,Default,,0,0,0,,所以等待这个future执行完毕
Dialogue: 0,0:40:29.13,0:40:32.37,Default,,0,0,0,,然后从selector中注销socket
Dialogue: 0,0:40:32.37,0:40:33.12,Default,,0,0,0,,得到当前的分块
Dialogue: 0,0:40:34.05,0:40:40.86,Default,,0,0,0,,如果有分块，那就加入到列表中 这个部分是多余的
Dialogue: 0,0:40:42.69,0:40:46.11,Default,,0,0,0,,这个循环会重复 在这里重复做这些
Dialogue: 0,0:40:46.11,0:40:47.52,Default,,0,0,0,,如果没有分块
Dialogue: 0,0:40:47.52,0:40:48.42,Default,,0,0,0,,这意味着
Dialogue: 0,0:40:50.07,0:40:51.96,Default,,0,0,0,,我们已经接收完服务器响应
Dialogue: 0,0:40:51.96,0:40:53.64,Default,,0,0,0,,所以我们可以
Dialogue: 0,0:40:55.26,0:40:56.46,Default,,0,0,0,,连接各个分块
Dialogue: 0,0:40:56.46,0:40:59.85,Default,,0,0,0,,打印第一行 减去任务数
Dialogue: 0,0:40:59.85,0:41:02.94,Default,,0,0,0,,从现在开始 我们又回到了一个无限循环
Dialogue: 0,0:41:02.94,0:41:05.37,Default,,0,0,0,,在这里 我们需要立即返回
Dialogue: 0,0:41:07.74,0:41:08.16,Default,,0,0,0,,现在
Dialogue: 0,0:41:08.16,0:41:10.29,Default,,0,0,0,,如果一切顺利 我运行这个
Dialogue: 0,0:41:10.29,0:41:14.34,Default,,0,0,0,,它仍然只花了一秒
Dialogue: 0,0:41:14.34,0:41:19.44,Default,,0,0,0,,它还是做了所有的工作
Dialogue: 0,0:41:19.80,0:41:26.25,Default,,0,0,0,,我们可以把它扩展到能够执行大量的任务而不损失任何性能
Dialogue: 0,0:41:26.25,0:41:32.16,Default,,0,0,0,,因为发起10个或15个协程的资源消耗实在是太低廉了
Dialogue: 0,0:41:32.16,0:41:36.36,Default,,0,0,0,,大概只和一堆回调差不多
Dialogue: 0,0:41:37.44,0:41:40.52,Default,,0,0,0,,所以协程差不多是几种办法中最好的
Dialogue: 0,0:41:40.66,0:41:44.98,Default,,0,0,0,,资源消耗和回调一样少，比线程更是不知道少到哪里去了
Dialogue: 0,0:41:45.24,0:41:50.58,Default,,0,0,0,,我在我的系统上测量了一个协程..
Dialogue: 0,0:41:51.54,0:41:57.15,Default,,0,0,0,,大约需要6K的内存，而线程需要30K
Dialogue: 0,0:41:57.15,0:42:04.74,Default,,0,0,0,,此外 我做了一个小实验：我有可以启动超过十万个协程
Dialogue: 0,0:42:04.74,0:42:12.03,Default,,0,0,0,,它们的限制仅仅是Python进程允许分配的内存总量
Dialogue: 0,0:42:12.93,0:42:14.10,Default,,0,0,0,,对比线程
Dialogue: 0,0:42:14.10,0:42:18.03,Default,,0,0,0,,除了简单的内存限制之外 线程还受到其他限制
Dialogue: 0,0:42:18.03,0:42:24.63,Default,,0,0,0,,各种用户和操作系统限制了一个进程被允许启动线程数量
Dialogue: 0,0:42:24.63,0:42:29.67,Default,,0,0,0,,这个问题在很多情况下都很难解决
Dialogue: 0,0:42:29.67,0:42:34.90,Default,,0,0,0,,线程占用空间和操作系统的数据结构，以及操作系统调度器
Dialogue: 0,0:42:35.02,0:42:39.18,Default,,0,0,0,,最终导致它们的开销变得非常大
Dialogue: 0,0:42:40.35,0:42:49.24,Default,,0,0,0,,他们所做的一切只是在等待一些缓慢的I/O操作。这实际上不需要非常多的CPU资源
Dialogue: 0,0:42:49.30,0:42:55.02,Default,,0,0,0,,相较于协程在这个程序中的应用
Dialogue: 0,0:42:55.02,0:42:59.38,Default,,0,0,0,,这将花费很少的时间用于CPU计算
Dialogue: 0,0:42:59.54,0:43:08.01,Default,,0,0,0,,并且绝大多数时间都花在等待一个缓慢的服务器或者 客户端的缓慢socket上
Dialogue: 0,0:43:08.01,0:43:11.58,Default,,0,0,0,,在这种情况下协程有效率的多
Dialogue: 0,0:43:11.58,0:43:16.29,Default,,0,0,0,,但是和回调相比 它们的简单得多 因为
Dialogue: 0,0:43:17.46,0:43:23.25,Default,,0,0,0,,你可以把协程的所有的代码放在一个函数里
Dialogue: 0,0:43:23.25,0:43:29.25,Default,,0,0,0,,所以你不需要声明并注册整个调用链
Dialogue: 0,0:43:29.25,0:43:34.17,Default,,0,0,0,,你可以重复使用你的局部变量 就像你原来的习惯
Dialogue: 0,0:43:36.27,0:43:47.13,Default,,0,0,0,,这就是Tornado或asyncio风格，这些基于协程的异步框架的开端。
Dialogue: 0,0:43:50.13,0:43:52.71,Default,,0,0,0,,如果你想了解更多
Dialogue: 0,0:43:52.71,0:43:57.84,Default,,0,0,0,,访问bit.ly/coroutines 我创建了一个页面
Dialogue: 0,0:43:57.98,0:44:03.09,Default,,0,0,0,,你可以在那里看到我刚才写的代码
Dialogue: 0,0:44:03.09,0:44:07.74,Default,,0,0,0,,那里也可以看到我和Guido(Python之父)合写的一章
Dialogue: 0,0:44:07.78,0:44:12.84,Default,,0,0,0,,这章将会出现在开源应用程序架构系列的下一本书中
Dialogue: 0,0:44:12.84,0:44:25.50,Default,,0,0,0,,这一章深入地介绍了在Python3.4的标准库中，基于生成器的协程的实现细节
Dialogue: 0,0:44:25.50,0:44:36.82,Default,,0,0,0,,特别是它详细描述协程如何利用基于python3的生成器特性
Dialogue: 0,0:44:37.38,0:44:43.56,Default,,0,0,0,,以及asyncio库中如何运用异步队列类
Dialogue: 0,0:44:43.56,0:44:52.35,Default,,0,0,0,,以一种惯用线程的工作者非常熟悉的方式来使用协程
Dialogue: 0,0:44:53.58,0:44:55.53,Default,,0,0,0,,提醒一下
Dialogue: 0,0:44:55.53,0:45:00.21,Default,,0,0,0,,如果你想和我这样的人在一家开源公司工作
Dialogue: 0,0:45:00.21,0:45:05.40,Default,,0,0,0,,非常热情、多元、充实以及有技术挑战的工作
Dialogue: 0,0:45:05.40,0:45:07.08,Default,,0,0,0,,Mongodb正在招聘
Dialogue: 0,0:45:07.08,0:45:11.07,Default,,0,0,0,,我们在纽约的帕罗奥多和世界各地都设有办事处
Dialogue: 0,0:45:11.07,0:45:14.16,Default,,0,0,0,,访问bit.ly/mongo-jobs
Dialogue: 0,0:45:14.16,0:45:15.09,Default,,0,0,0,,我将很荣幸与你共事
