[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1152
PlayResY: 720

[Aegisub Project Garbage]
Audio File: How Do Python Coroutines Work.mp4
Video File: How Do Python Coroutines Work.mp4
Video AR Mode: 4
Video AR Value: 1.600000
Video Zoom Percent: 0.375000
Scroll Position: 545
Active Line: 562
Video Position: 75347

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,26,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2.3,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:04.38,0:00:08.13,Default,,0,0,0,,大家好，我是A. Jesse Jiryu Davis\NHi, I'm A. Jesse Jiryu Davis
Dialogue: 0,0:00:08.13,0:00:12.66,Default,,0,0,0,,我将解释Python协程是如何工作的\Nand I'm going to tell you how Python coroutines work.
Dialogue: 0,0:00:14.52,0:00:15.54,Default,,0,0,0,,介绍一下我自己\NLittle about me,
Dialogue: 0,0:00:15.54,0:00:25.98,Default,,0,0,0,,我是MongoDB的一名高级工程师，职责是为MongoDB写Python和C的驱动。\NI work for a MongoDB,I'm a staff engineer, there work on the Python and the C drivers for MongoDB.
Dialogue: 0,0:00:25.98,0:00:32.10,Default,,0,0,0,,是的,我们正在招聘。我强烈推荐来MongoDB工作\NYes, we are hiring and I highly recommend working for MongoDB.
Dialogue: 0,0:00:32.10,0:00:40.44,Default,,0,0,0,,访问bit.ly/mongo-jobs了解所有的工作机会\NYou can go to Mongo-jobs to see all of the jobs that we've got open.
Dialogue: 0,0:00:41.40,0:00:44.58,Default,,0,0,0,,如果你想了解更多关于这个话题的信息\NAnd if you want more information about this talk,
Dialogue: 0,0:00:44.58,0:00:49.71,Default,,0,0,0,,我在bit.ly/coroutines中新增了一个页面\NI've set up a landing pages at bit.ly/coroutines
Dialogue: 0,0:00:49.71,0:00:56.37,Default,,0,0,0,,你可以在链接里找到本视频的代码\NYou can find links there to the code that I'm going to write right now,
Dialogue: 0,0:00:56.37,0:01:05.64,Default,,0,0,0,,同时，在即将发布的《开源应用程序架构》书中\Nand also to a chapter in the upcoming architecture of open source applications book
Dialogue: 0,0:01:05.94,0:01:16.05,Default,,0,0,0,,我和Guido(Python创始人)合著了一章，其中深入地阐述了python协程工作的细节\Nthat I co-wrote with Guido Van Rossum that goes into far more depth and is a very detailed exposition of python coroutines work.
Dialogue: 0,0:01:17.16,0:01:22.83,Default,,0,0,0,,这个示例的主题是\NSo the agenda for this demo is going to be a
Dialogue: 0,0:01:26.55,0:01:29.88,Default,,0,0,0,,基于回调的异步框架\Ncallback-based async framework,
Dialogue: 0,0:01:29.88,0:01:35.40,Default,,0,0,0,,写完之后，我们会看到它非常有效，但也有些混乱\Nand once we've written that we're going to see that it's very efficient but also kind of a mess,
Dialogue: 0,0:01:35.40,0:01:42.54,Default,,0,0,0,,所以我们最后要把它改写成一个基于协程的框架\Nand so we're going to adapt that to a coroutine based framework instead.
Dialogue: 0,0:01:44.22,0:01:48.72,Default,,0,0,0,,因此 从一个基于回调的异步框架入手\NSo to begin with a callback based async framework,
Dialogue: 0,0:01:48.72,0:01:51.99,Default,,0,0,0,,它使用非阻塞socket\NIt uses non-blocking sockets.
Dialogue: 0,0:01:52.98,0:01:54.81,Default,,0,0,0,,使用回调函数\Nuses the callbacks,
Dialogue: 0,0:01:54.81,0:01:55.56,Default,,0,0,0,,当然\Nof course,
Dialogue: 0,0:01:55.56,0:01:58.98,Default,,0,0,0,,它还使用一个事件循环\Nand it also uses an event loop.
Dialogue: 0,0:02:00.42,0:02:02.85,Default,,0,0,0,,至于协程\NAnd as for coroutines,
Dialogue: 0,0:02:02.85,0:02:05.46,Default,,0,0,0,,到时候再说吧\Nwell, we'll cross that bridge when we come to it.
Dialogue: 0,0:02:06.51,0:02:09.00,Default,,0,0,0,,编码之前有一些准备工作\NSo a little bit of setup,
Dialogue: 0,0:02:09.00,0:02:14.49,Default,,0,0,0,,我写了一个简单的web服务器(Github代码中的server.py)\NI've written a simple web server and.
Dialogue: 0,0:02:18.75,0:02:21.06,Default,,0,0,0,,它可以响应http请求\NIt can respond to an HTTP request.
Dialogue: 0,0:02:22.44,0:02:27.51,Default,,0,0,0,,我为本地的python会议"PyGotham 2015"写了这篇文章\NI wrote this for a local python conference PyGotham 2015,
Dialogue: 0,0:02:27.51,0:02:32.73,Default,,0,0,0,,所以你可以看到它向所有那些了不起的人们致意\Nso you can see that it says hello to all of the incredible people there.
Dialogue: 0,0:02:32.73,0:02:37.02,Default,,0,0,0,,这个框架的另一个有趣之处是它有点慢\NAnd the other interesting thing about this framework is its kind of slow.
Dialogue: 0,0:02:38.52,0:02:42.30,Default,,0,0,0,,这个web服务器返回非常简单的响应\NThis web server returns very simple response,
Dialogue: 0,0:02:42.30,0:02:47.61,Default,,0,0,0,,但我故意增加了一些sleep代码 所以要花差不多一秒的时间响应\Nbut I've coded it so that it takes almost a second to reply.
Dialogue: 0,0:02:47.61,0:02:50.55,Default,,0,0,0,,这么做的重要性将会在后面体现\NAnd so that's going to end up being very important,
Dialogue: 0,0:02:50.55,0:02:54.39,Default,,0,0,0,,因为这是最适合用异步优化的场景：\Nbecause that's the sort of thing that async is optimized for.
Dialogue: 0,0:02:54.39,0:03:00.45,Default,,0,0,0,,与速度较慢的服务器或者客户端进行有效率的通信\NIs for talking too slow servers or slow clients efficiently.
Dialogue: 0,0:03:02.49,0:03:04.38,Default,,0,0,0,,让我们看看\NSo let's see,
Dialogue: 0,0:03:04.38,0:03:11.28,Default,,0,0,0,,我们怎样才能以典型的python方式获取URL\Nhow would we fetch a URL in the kind of typical python way.
Dialogue: 0,0:03:14.61,0:03:19.62,Default,,0,0,0,,所以我们先导入socket\Nso we would need to import socket right?
Dialogue: 0,0:03:21.24,0:03:22.35,Default,,0,0,0,,然后\NAnd?
Dialogue: 0,0:03:30.66,0:03:34.11,Default,,0,0,0,,绑定到合适的域名和端口\NConnected to the proper domain and port.
Dialogue: 0,0:03:35.64,0:03:36.90,Default,,0,0,0,,格式化一个请求\Nwe format a request
Dialogue: 0,0:03:48.87,0:03:50.58,Default,,0,0,0,,把它发送到服务器\Nthen we would send it to the server.
Dialogue: 0,0:03:51.75,0:03:54.27,Default,,0,0,0,,我用的python3环境\NAnd I'm going to do this in Python 3
Dialogue: 0,0:03:54.27,0:03:59.82,Default,,0,0,0,,所以对那些通过网络传输的所有内容进行编码是很重要的\Nand so it's important to encode everything that we're going to send over the wire.
Dialogue: 0,0:03:59.82,0:04:00.00,Default,,0,0,0,,哦\NOh,
Dialogue: 0,0:04:00.00,0:04:02.13,Default,,0,0,0,,另一个需要记住的重要的事情是\Nand the other important thing to remember is that.
Dialogue: 0,0:04:04.59,0:04:12.75,Default,,0,0,0,,每个HTTP请求头部以两个回车换行符分隔\NEach HTTP requests end in a double carriage return to a new line
Dialogue: 0,0:04:12.75,0:04:19.35,Default,,0,0,0,,所以一旦我们发送了请求就会收到响应 它会以分块的形式返回给我们\Nso once we've sent the request were going to receive the response and that'll come back to us in chunks.
Dialogue: 0,0:04:19.35,0:04:23.31,Default,,0,0,0,,所以我们要把它们收集到一个列表中\Nso we're just going to collect those in a list.
Dialogue: 0,0:04:28.65,0:04:30.81,Default,,0,0,0,,收集最多1000个分块(口胡)\NReceive them up to a thousand chunks
Dialogue: 0,0:04:30.81,0:04:33.21,Default,,0,0,0,,一次接收1000字节\Na thousand bytes at a time,
Dialogue: 0,0:04:33.21,0:04:35.40,Default,,0,0,0,,只要我们接收完一个分块\Nand as long as we've got a chunk.
Dialogue: 0,0:04:39.45,0:04:44.07,Default,,0,0,0,,就将它加到列表中，如果我们得到一个空的块\Nwill append it to the list and if we get an empty chunk,
Dialogue: 0,0:04:44.07,0:04:46.32,Default,,0,0,0,,我们就知道服务器断开了\Nthen we know that the server is hung up on us.
Dialogue: 0,0:04:46.32,0:04:49.86,Default,,0,0,0,,所以数据就接收完毕了\Nso our reception is complete,
Dialogue: 0,0:04:49.86,0:04:52.92,Default,,0,0,0,,所以响应内容将会是\Nand so the body is going to be....
Dialogue: 0,0:04:56.16,0:04:59.64,Default,,0,0,0,,我们将用空字节类型来连接所有的块\NWe'll use the empty bye to join all the chunks.
Dialogue: 0,0:05:00.75,0:05:03.90,Default,,0,0,0,,然后我们会解码\NAnd then we'll decode that.
Dialogue: 0,0:05:05.82,0:05:07.29,Default,,0,0,0,,默认是utf-8\NThe utf-8 by default.
Dialogue: 0,0:05:08.49,0:05:17.28,Default,,0,0,0,,然后我们把响应内容的第一行打印出来\NAnd then let's just prints the first line of the body.
Dialogue: 0,0:05:19.98,0:05:21.48,Default,,0,0,0,,所以\NSo,
Dialogue: 0,0:05:21.48,0:05:23.13,Default,,0,0,0,,因为我们在死循环中\Nand since we're in an infinite loop,
Dialogue: 0,0:05:23.13,0:05:24.27,Default,,0,0,0,,我们需要返回\Nwe need to return,
Dialogue: 0,0:05:24.27,0:05:29.26,Default,,0,0,0,,这就是我们的get函数。如果我们get参数/foo\Nso that's our get function and if we get that path Foo
Dialogue: 0,0:05:29.54,0:05:39.45,Default,,0,0,0,,运行程序,可以看到响应的第一行是http 200 OK\Nand if I run this, you'll see that the first line of the response is an http 200 OK.
Dialogue: 0,0:05:40.98,0:05:41.58,Default,,0,0,0,,然后\NAnd?
Dialogue: 0,0:05:42.48,0:05:43.56,Default,,0,0,0,,让我们看看\NLet's also see.
Dialogue: 0,0:05:45.18,0:05:46.32,Default,,0,0,0,,整个过程的运行时间\NHow long that took
Dialogue: 0,0:06:00.60,0:06:04.38,Default,,0,0,0,,这需要大约一秒钟的时间 因为还有Python解释器的一点开销\NSo it takes about a second because there's a little bit of overhead in the Python interpreter.
Dialogue: 0,0:06:05.49,0:06:11.07,Default,,0,0,0,,这种方法的问题是 如果我们想要访问两个url\Nthe problem with this approach is that if we want to get 2 Urls,
Dialogue: 0,0:06:11.07,0:06:15.42,Default,,0,0,0,,就需要两秒钟 因为我们是串行地获取URL\Nit's going to take two seconds because we get them serially.
Dialogue: 0,0:06:17.07,0:06:24.63,Default,,0,0,0,,典型方法是在两个线程上启动这两个get操作\NAnd the typical approach to this might be to launch these two operations on two threads,
Dialogue: 0,0:06:24.63,0:06:31.23,Default,,0,0,0,,但如果我们等待数百个缓慢的请求，效率可能会变得非常低\Nbut that might become inefficient if we're waiting for hundreds of slow requests,
Dialogue: 0,0:06:31.23,0:06:34.77,Default,,0,0,0,,因为我们不得不为这些请求创建数百个线程\Nand we have to spawn hundreds of threads for them.
Dialogue: 0,0:06:34.77,0:06:36.96,Default,,0,0,0,,有很多的开销是不必要的\NThere's a lot of overhead though it's not necessary,
Dialogue: 0,0:06:36.96,0:06:41.40,Default,,0,0,0,,所以我们将尝试写一个异步的框架来代替它\Nso we're going to try out making an async framework to do it instead,
Dialogue: 0,0:06:41.40,0:06:49.05,Default,,0,0,0,,这样我们就不需要为了执行数百次缓慢的I/O请求而创建数百个线程了\Nso that we don't have to spawn hundreds of threads in order to do hundreds of slow i/o operations,
Dialogue: 0,0:06:49.05,0:06:51.36,Default,,0,0,0,,我们想要比这更有效率的办法\Nwe want to be more efficient than that.
Dialogue: 0,0:06:51.36,0:06:51.93,Default,,0,0,0,,所以\NSo.
Dialogue: 0,0:06:53.07,0:07:00.75,Default,,0,0,0,,异步框架可以使用非阻塞socket，python中实现非阻塞的基本框架非常简单\NA async framework could uses non-blocking sockets and in python making socket non blocking is very simple.
Dialogue: 0,0:07:01.77,0:07:04.80,Default,,0,0,0,,如果我们运行程序，将会发生什么\NNow what's going to happen if we run this?
Dialogue: 0,0:07:05.88,0:07:07.95,Default,,0,0,0,,我们会得到一个异常，因为\NWe're going to get an exception because.
Dialogue: 0,0:07:09.54,0:07:15.39,Default,,0,0,0,,一个非阻塞socket的意思是任何会阻塞的操作\NA non blocking socket what that means is any operation that would block,
Dialogue: 0,0:07:15.39,0:07:22.08,Default,,0,0,0,,就像连接操作，要么立即成功 要么抛出异常\Nlike connecting,either succeeds immediately or raises an exception.
Dialogue: 0,0:07:22.08,0:07:22.35,Default,,0,0,0,,对\NRight.
Dialogue: 0,0:07:22.35,0:07:23.79,Default,,0,0,0,,它是不允许阻塞的\NIt's not allowed to block.
Dialogue: 0,0:07:23.79,0:07:27.03,Default,,0,0,0,,不允许一直等待直到程序成功完成操作\Nit's not allowed to wait for success.
Dialogue: 0,0:07:28.05,0:07:34.14,Default,,0,0,0,,所以我们需要一些方法来等待它完成\NSo we need some way to wait for that to complete.
Dialogue: 0,0:07:35.49,0:07:37.41,Default,,0,0,0,,我们用Python来做这个\NAnd the way we do that in Python.
Dialogue: 0,0:07:38.55,0:07:39.09,Default,,0,0,0,,嗯\NWell,
Dialogue: 0,0:07:39.09,0:07:39.63,Default,,0,0,0,,首先\Nfirst of all,
Dialogue: 0,0:07:39.63,0:07:47.37,Default,,0,0,0,,我们可以先忽略这个错误\Nwe can just ignore that error.
Dialogue: 0,0:07:48.51,0:07:50.36,Default,,0,0,0,,但这没有太大帮助\NBut that's not going to get us very far
Dialogue: 0,0:07:50.42,0:07:56.22,Default,,0,0,0,,一旦我们试着给socket发送数据，就会报错：socket未连接\Nbecause as soon as we tried to send something of the socket is going to say that it's not connected yet right
Dialogue: 0,0:07:56.32,0:08:00.00,Default,,0,0,0,,当我们调用connect时\Nbecause when we called connect,
Dialogue: 0,0:08:00.00,0:08:02.79,Default,,0,0,0,,非阻塞socket开始执行操作\Nthe non-blocking socket began the operation.
Dialogue: 0,0:08:02.79,0:08:05.13,Default,,0,0,0,,但它并没有等待操作完成\NBut it didn't wait for the operation to complete.
Dialogue: 0,0:08:05.13,0:08:06.90,Default,,0,0,0,,因此我们还没有准备好发送数据\NAnd so we're not ready to send it yet.
Dialogue: 0,0:08:07.86,0:08:12.87,Default,,0,0,0,,那么，我们怎么知道何时才能准备好发送一个操作呢\NSo how do we know when we're ready to send an operation?
Dialogue: 0,0:08:14.22,0:08:15.45,Default,,0,0,0,,嗯\NWell,
Dialogue: 0,0:08:15.45,0:08:16.62,Default,,0,0,0,,python3\Npython 3.
Dialogue: 0,0:08:19.05,0:08:21.57,Default,,0,0,0,,有一个易于使用的包叫做selectors\NThere's this handy module called selectors.
Dialogue: 0,0:08:24.36,0:08:28.35,Default,,0,0,0,,在每一个远古版本的操作系统中\NIn every operating system since time immemorial,
Dialogue: 0,0:08:28.35,0:08:34.44,Default,,0,0,0,,就有一些方法可以在非阻塞socket上等待某些事件\Nthere has been some way to wait for some event on a non blocking socket.
Dialogue: 0,0:08:34.44,0:08:35.10,Default,,0,0,0,,最初\NOriginally,
Dialogue: 0,0:08:35.10,0:08:37.86,Default,,0,0,0,,有系统调用select\Nthere was the system call select,
Dialogue: 0,0:08:37.86,0:08:39.06,Default,,0,0,0,,随着时间的推移\Nand then over time,
Dialogue: 0,0:08:39.06,0:08:43.26,Default,,0,0,0,,越来越多的可扩展的新版select已经被发明出来了\Nmore and more scalable versions of select have been invented.
Dialogue: 0,0:08:43.26,0:08:46.08,Default,,0,0,0,,比如Linux上的poll\NLike poll on Linux,
Dialogue: 0,0:08:46.08,0:08:50.46,Default,,0,0,0,,BSD和Mac上的epoll以及windows上的kqueue\Nepoll on Bsd and Mac kqueue on windows.
Dialogue: 0,0:08:50.46,0:08:52.86,Default,,0,0,0,,这些都是I/O完成端口\Nthere's these I/O completion ports.
Dialogue: 0,0:08:54.21,0:08:56.40,Default,,0,0,0,,Python3.4的优点是\NThe nice thing about Python 3.4
Dialogue: 0,0:08:57.99,0:09:03.39,Default,,0,0,0,,你可以获取一个默认选择器\NIs that you can just ask it for a default selector,
Dialogue: 0,0:09:03.39,0:09:14.16,Default,,0,0,0,,它会识别你当前使用的系统，给你最匹配的selector\Nand it will figure out what your running and give you the most efficient selector for your platform,
Dialogue: 0,0:09:14.16,0:09:16.62,Default,,0,0,0,,所以我们要做一个这样的程序：\Nso we'll make one of those and.
Dialogue: 0,0:09:18.12,0:09:21.00,Default,,0,0,0,,在我们试着给socket发送任何东西之前\NBefore we try to send anything on the socket.
Dialogue: 0,0:09:22.17,0:09:24.84,Default,,0,0,0,,我们将等待它到可读状态\NWe're going to wait for it to be readable.
Dialogue: 0,0:09:24.84,0:09:28.38,Default,,0,0,0,,我们会等着它准备好要发送的内容\NWe're going to wait for it to be ready for something to be sent,
Dialogue: 0,0:09:28.38,0:09:30.30,Default,,0,0,0,,为了做到这一点\Nso to do that,
Dialogue: 0,0:09:30.30,0:09:34.23,Default,,0,0,0,,我们注册了socket文件号\Nwe register the sockets file number,
Dialogue: 0,0:09:34.23,0:09:36.81,Default,,0,0,0,,就是一个整型\Nwhich is just an integer.
Dialogue: 0,0:09:36.81,0:09:38.82,Default,,0,0,0,,它只是一个文件描述符\Nit's just a file descriptor.
Dialogue: 0,0:09:38.82,0:09:44.70,Default,,0,0,0,,这将告诉selector，这是一个我们在事件发生时关注的文件号\NAnd we're going to tell the selector that this is a file number that we're interested in events on
Dialogue: 0,0:09:44.80,0:09:52.72,Default,,0,0,0,,我们关注的事件则是socket何时处于可写状态\Nand the specific event that we're interested in is we want to know when the socket is writable
Dialogue: 0,0:09:52.72,0:09:57.04,Default,,0,0,0,,pycharm可以自动为我们导入那个常量(win: Alt+Enter)\Nand pycharm can auto import that constant for us.
Dialogue: 0,0:09:59.34,0:10:00.80,Default,,0,0,0,,我们要做的下一件事是\NThe next thing we do
Dialogue: 0,0:10:00.88,0:10:06.48,Default,,0,0,0,,到目前为止，所做的一切都表明我们关注这个事件中的文件描述符\Nso all we have done so far said I'm interested in this event on this file descriptor.
Dialogue: 0,0:10:06.48,0:10:13.08,Default,,0,0,0,,如果我们调用select 它会等待我们要求的事件发生\NAnd then if we call select that will wait for some event that we've asked about to happen.
Dialogue: 0,0:10:14.13,0:10:15.12,Default,,0,0,0,,所以\NSo,
Dialogue: 0,0:10:15.12,0:10:16.62,Default,,0,0,0,,一旦这种情况发生\Nonce that happens,
Dialogue: 0,0:10:16.62,0:10:20.16,Default,,0,0,0,,我们可以注销文件号\Nwe can unregistered the file number.
Dialogue: 0,0:10:21.51,0:10:22.83,Default,,0,0,0,,此时\NAnd by this point.
Dialogue: 0,0:10:24.99,0:10:25.86,Default,,0,0,0,,s(socket)是可写的\Ns is writable.
Dialogue: 0,0:10:27.93,0:10:31.56,Default,,0,0,0,,这意味着我们可以合法地调用send\NSo that means that we can legally now call send on it.
Dialogue: 0,0:10:31.56,0:10:33.00,Default,,0,0,0,,如果我现在调用这个\NSo if I call this now.
Dialogue: 0,0:10:35.07,0:10:38.04,Default,,0,0,0,,你会看到程序已经越过这行\NYou'll see that I get past this line,
Dialogue: 0,0:10:38.04,0:10:45.09,Default,,0,0,0,,但是现在这里抛出一个异常，因为这个socket是可写的\Nbut now we're throwing an exception down here because the socket is writable,
Dialogue: 0,0:10:45.09,0:10:52.17,Default,,0,0,0,,但是它还没有变得可读 我们还没有等待服务器开始发送它的响应\Nbut it hasn't become readable yet We haven't waited for the server to start sending its response.
Dialogue: 0,0:10:53.49,0:10:55.14,Default,,0,0,0,,所以为了等待服务器\NSo in order to wait for that,
Dialogue: 0,0:10:55.14,0:10:59.55,Default,,0,0,0,,我们必须再做一次同样的操作\Nwe have to do the same dance again,
Dialogue: 0,0:10:59.55,0:11:04.32,Default,,0,0,0,,这一次我们对可读情况感兴趣而不是可写情况\Nand this time we're not interested in write ability we're interested in readability.
Dialogue: 0,0:11:04.32,0:11:08.58,Default,,0,0,0,,这里可以用pycharm的自动导入（win: Alt + Enter）\NSo we have the pycharm auto inputs that
Dialogue: 0,0:11:10.17,0:11:12.03,Default,,0,0,0,,再次等待socket\NWe wait for it again,
Dialogue: 0,0:11:12.03,0:11:15.96,Default,,0,0,0,,一旦这个调用完成\Nand once this call completes,
Dialogue: 0,0:11:15.96,0:11:20.37,Default,,0,0,0,,那我们就注销文件号\Nthen we'll unregistered the file number,
Dialogue: 0,0:11:20.37,0:11:22.42,Default,,0,0,0,,现在我们可以接收数据了\Nand now we're allowed to receive
Dialogue: 0,0:11:22.50,0:11:25.17,Default,,0,0,0,,如果我现在运行，它可以正常工作\Nso if I run this code now it completes,
Dialogue: 0,0:11:25.17,0:11:29.64,Default,,0,0,0,,但我们还没有得到真正想要的效果，还是需要两秒\Nbut we haven't really won anything right still took two seconds.
Dialogue: 0,0:11:29.64,0:11:33.06,Default,,0,0,0,,我们只是把代码弄得一团糟\NWe just kind of made a small mess in our code.
Dialogue: 0,0:11:33.06,0:11:37.59,Default,,0,0,0,,但我们还没有获得任何效率的提升\NBut we haven't gained any efficiency improvements yet.
Dialogue: 0,0:11:43.20,0:11:44.64,Default,,0,0,0,,那么下一步做什么呢\NSo what's the next step?
Dialogue: 0,0:11:46.41,0:11:51.99,Default,,0,0,0,,在使用了非阻塞socket之后的步骤\NThe next step after we've started to use non blocking sockets,
Dialogue: 0,0:11:51.99,0:11:53.49,Default,,0,0,0,,是回调\Nis callbacks.
Dialogue: 0,0:11:55.08,0:11:56.52,Default,,0,0,0,,我将解释它是如何工作的\NSo I'll explain how that works.
Dialogue: 0,0:11:57.60,0:12:07.41,Default,,0,0,0,,回调是一种允许多个操作并发等待I/O操作的方法\NCallbacks are a way of allowing multiple operations to be waiting concurrently for i/o operations.
Dialogue: 0,0:12:11.76,0:12:13.35,Default,,0,0,0,,首先以这个get函数为例\NTo begin with, this get.
Dialogue: 0,0:12:14.37,0:12:16.53,Default,,0,0,0,,当开始连接时\NWhen it starts connecting,
Dialogue: 0,0:12:16.53,0:12:23.61,Default,,0,0,0,,一旦socket可写时，注册的回调将被执行\Nit needs to register callback to be executed once the socket is writable,
Dialogue: 0,0:12:23.61,0:12:24.92,Default,,0,0,0,,之后它需要返回\Nand then it needs to return
Dialogue: 0,0:12:24.98,0:12:33.93,Default,,0,0,0,,这样当我们在等待连接这个socket的时候，就可以开始获取另一个URL\Nso that work can begin on getting the other URL while we're waiting to connect this socket right,
Dialogue: 0,0:12:33.93,0:12:38.46,Default,,0,0,0,,我们需要某种并发手段来优化这两秒的时间\Nwe need some sort of concurrency in order to get past this two seconds.
Dialogue: 0,0:12:39.87,0:12:41.19,Default,,0,0,0,,我们来看看它是如何工作的\NSo let's see how that would work.
Dialogue: 0,0:12:42.51,0:12:46.26,Default,,0,0,0,,我们可以先写回调的主体\NWe can begin by writing the body of that call back,
Dialogue: 0,0:12:46.26,0:12:47.82,Default,,0,0,0,,所以我将它命名为connected函数\Nso I'm gonna call it connected.
Dialogue: 0,0:12:47.82,0:12:49.08,Default,,0,0,0,,这将会执行\NThis is going to execute.
Dialogue: 0,0:12:50.19,0:12:54.81,Default,,0,0,0,,一旦socket已连接，它就会执行下一步\NOnce the socket is connected and it's going to do the next step.
Dialogue: 0,0:12:55.98,0:12:58.41,Default,,0,0,0,,但问题是\NBut the problem is,
Dialogue: 0,0:12:58.41,0:13:01.41,Default,,0,0,0,,你可以看到PyCharm有错误提示了\Nyou can see that right now PyCharm is sort of losing its mind
Dialogue: 0,0:13:01.41,0:13:10.95,Default,,0,0,0,,因为在这个新函数中有两个变量没有声明，因为我们在get函数中创建了它们\Nbecause there's two variables that are not bound in this new function because we created them up here in get.
Dialogue: 0,0:13:12.33,0:13:17.40,Default,,0,0,0,,这两个变量是s和request\NAnd the two variables are s and request.
Dialogue: 0,0:13:17.40,0:13:21.36,Default,,0,0,0,,假设这些变量通过某种方式传递给connected函数\NSo let's say that those are passed into connected somehow.
Dialogue: 0,0:13:23.34,0:13:27.24,Default,,0,0,0,,解决办法是\NAnd that somehow is going to be.
Dialogue: 0,0:13:27.24,0:13:33.33,Default,,0,0,0,,我们将使用lambda来创建一个闭包来捕获这两个值\NWe're going to use a lambda to create a closure to capture those two values.
Dialogue: 0,0:13:33.33,0:13:35.16,Default,,0,0,0,,所以我们要创建一个Lambda表达式\Nso we'll create a Lambda.
Dialogue: 0,0:13:36.30,0:13:43.44,Default,,0,0,0,,这样调用Lambda执行connected函数就可以使用这两个变量了\NAnd we'll say that calling the Lambda executes connected with the socket and the request,
Dialogue: 0,0:13:43.44,0:13:46.44,Default,,0,0,0,,我们把这个叫做lambda回调\Nand we'll call this lambda callback.
Dialogue: 0,0:13:48.21,0:13:50.52,Default,,0,0,0,,现在我们如何使用这个回调？\NNow what do we do with this callback?
Dialogue: 0,0:13:50.52,0:13:54.06,Default,,0,0,0,,selector.register\NWell selector.register,
Dialogue: 0,0:13:54.06,0:14:00.87,Default,,0,0,0,,它有特别的隐藏参数，有点像*b-side(唱片的B面，指没被选入专辑的歌)\Nit has this special hidden argument sort of a b-side,
Dialogue: 0,0:14:00.87,0:14:03.21,Default,,0,0,0,,它被称为data\Nand it's called data,
Dialogue: 0,0:14:03.21,0:14:06.36,Default,,0,0,0,,所以我们要把回调作为data的参数传递给调用者\Nso we're going to pass the callback again as data.
Dialogue: 0,0:14:06.40,0:14:08.16,Default,,0,0,0,,因为这是Python(动态语言)\Nbecause this is Python,
Dialogue: 0,0:14:09.75,0:14:15.12,Default,,0,0,0,,data可以是任何东西，所以我们要把lambda作为data参数传入\NThe data can be anything so we're going to pass in our lambda as the data.
Dialogue: 0,0:14:17.37,0:14:17.94,Default,,0,0,0,,然后\NAnd?
Dialogue: 0,0:14:19.95,0:14:24.51,Default,,0,0,0,,我们要等到connected被调用时才注销那个文件号\NWe're going to wait until connected is called to actually unregistered that file number.
Dialogue: 0,0:14:24.51,0:14:25.47,Default,,0,0,0,,现在\NNow,
Dialogue: 0,0:14:25.47,0:14:26.97,Default,,0,0,0,,如果我们这样做\Nif we do this.
Dialogue: 0,0:14:30.45,0:14:32.13,Default,,0,0,0,,不幸的是\NUnfortunately,
Dialogue: 0,0:14:32.13,0:14:33.72,Default,,0,0,0,,我们实际上并没有完成任何工作\Nwe don't actually get any work done.
Dialogue: 0,0:14:34.86,0:14:36.84,Default,,0,0,0,,因为我们的回调从来没有真正执行过\NBecause our callback is never actually executed.
Dialogue: 0,0:14:37.83,0:14:48.93,Default,,0,0,0,,那么我们如何确保在等待的事件发生的时候，立即执行这个回调呢\NSo how do we make sure that this callback is actually run, once the event that it's waiting for has been executed?
Dialogue: 0,0:14:48.93,0:14:53.25,Default,,0,0,0,,为了解决这个问题，我们需要异步框架的第三部分\NWell for that we need the third part of our async framework.
Dialogue: 0,0:14:53.25,0:14:54.57,Default,,0,0,0,,我们需要一个事件循环\NWe need an event loop.
Dialogue: 0,0:14:56.55,0:14:58.17,Default,,0,0,0,,我在这里把它写出来\Nso I'm going to code that down here.
Dialogue: 0,0:15:00.45,0:15:05.13,Default,,0,0,0,,get函数将首先运行，它会启动一个socket连接\Nget is going to run first and it's going to start a socket connecting,
Dialogue: 0,0:15:05.13,0:15:10.23,Default,,0,0,0,,然后它会注册一个回调 当socket是可写的时候就会执行\Nand then it's going to register a callback to be executed when the socket is writable.
Dialogue: 0,0:15:10.23,0:15:14.16,Default,,0,0,0,,一旦foo执行完成了，bar也做同样的操作\Nand once foo has done that it returns and bar does the same thing.
Dialogue: 0,0:15:14.16,0:15:19.74,Default,,0,0,0,,现在我们有两个非阻塞的socket在连接的过程中\NSo now we've got to two non blocking sockets that are open and in the midst of connected,
Dialogue: 0,0:15:19.74,0:15:24.45,Default,,0,0,0,,它们都已经在selector中注册了\Nand they've both been registered with the selector.
Dialogue: 0,0:15:24.45,0:15:29.55,Default,,0,0,0,,所以我先运行一个简略的事件循环\NSo I'm going to run a *dirt simple little event loop here,
Dialogue: 0,0:15:29.55,0:15:33.78,Default,,0,0,0,,写下selector.select\Nand it's going to say selector dot select.
Dialogue: 0,0:15:35.13,0:15:41.49,Default,,0,0,0,,现在让我们用调试器运行到这里，看看select实际返回的是什么\NNow let's run this through the deBugger here and see what select actually returns.
Dialogue: 0,0:15:41.49,0:15:44.61,Default,,0,0,0,,所以我设置了一个断点\NSo I set a break point,
Dialogue: 0,0:15:44.61,0:15:47.82,Default,,0,0,0,,现在我们有了这个事件列表\Nand now we've got this events list,
Dialogue: 0,0:15:47.82,0:15:49.98,Default,,0,0,0,,如果我查看这个事件列表\Nand if I inspect that,
Dialogue: 0,0:15:49.98,0:15:51.96,Default,,0,0,0,,你会看到它是一个列表\Nyou'll see that it's a list.
Dialogue: 0,0:15:51.96,0:15:53.58,Default,,0,0,0,,它有两个元素\NIt's got two elements,
Dialogue: 0,0:15:53.58,0:15:56.64,Default,,0,0,0,,我们来看看第一个元素是什么\Nand let's see what that first element is.
Dialogue: 0,0:15:56.64,0:15:58.26,Default,,0,0,0,,它有\NIt's got.
Dialogue: 0,0:15:58.26,0:16:00.45,Default,,0,0,0,,它是一个有两个值的元组\NIt's a tuple with two values.
Dialogue: 0,0:16:00.45,0:16:02.13,Default,,0,0,0,,第二个值不是很有趣\NA second value isn't very interesting.
Dialogue: 0,0:16:02.13,0:16:06.99,Default,,0,0,0,,这只是我们一开始传递的mask\NThis is just the *mask that we passed in at first,
Dialogue: 0,0:16:06.99,0:16:11.04,Default,,0,0,0,,它等于常量EVENT_WRITE的值\Nand it's equal to the EVENT_WRITE value.
Dialogue: 0,0:16:11.04,0:16:15.84,Default,,0,0,0,,但我们已经知道了 因为那是我们唯一感兴趣的事件\Nbut we already knew that because that was the only event that we were interested in.
Dialogue: 0,0:16:15.84,0:16:18.96,Default,,0,0,0,,它是元组的第一个元素\NIt's this first element of the tuple.
Dialogue: 0,0:16:18.96,0:16:22.53,Default,,0,0,0,,这个SelectorKey很有趣\NThis SelectorKey thing that's really interesting,
Dialogue: 0,0:16:22.53,0:16:28.92,Default,,0,0,0,,当我调用寄存器时 你会看到我传递的数据值\Nand you'll see that the data value that I passed in when I called register.
Dialogue: 0,0:16:28.92,0:16:37.08,Default,,0,0,0,,在这个事件列表中得到了这个对象，它的内容是我注册为回调的lambda表达式\NWe're getting that back out in this events list and its contents is that lambda that I registered as the callback
Dialogue: 0,0:16:37.10,0:16:41.55,Default,,0,0,0,,让我们执行它\NSo let's execute it.
Dialogue: 0,0:16:43.44,0:16:44.91,Default,,0,0,0,,写一个循环\NSo for event.
Dialogue: 0,0:16:46.14,0:16:48.00,Default,,0,0,0,,\NAnd mask events.
Dialogue: 0,0:16:49.38,0:16:50.94,Default,,0,0,0,,Mask是我们不关心的东西\NMask is the thing we don't care about.
Dialogue: 0,0:16:50.94,0:16:51.75,Default,,0,0,0,,它的值是2\Nits too.
Dialogue: 0,0:16:51.75,0:16:53.97,Default,,0,0,0,,它等于常量EVENT_WRITE的值\NIt's equal to EVENT_WRITE
Dialogue: 0,0:16:53.97,0:16:55.89,Default,,0,0,0,,但是这个事件\Nbut this event here.
Dialogue: 0,0:16:59.61,0:17:04.82,Default,,0,0,0,,它的数据字段是我们之前注册的回调\NIts data field is the callback that we originally registered
Dialogue: 0,0:17:04.84,0:17:06.39,Default,,0,0,0,,所以我要叫它cb\Nso I'm going to call that cb,
Dialogue: 0,0:17:06.39,0:17:08.04,Default,,0,0,0,,然后调用它\Nand then I'm just going to call it.
Dialogue: 0,0:17:09.60,0:17:14.76,Default,,0,0,0,,现在运行程序,看看会发生什么 这样就可以进入函数内部(F7)\NSo if I run this now instead of breakpoint here and see what happens so it can step in.
Dialogue: 0,0:17:15.69,0:17:18.36,Default,,0,0,0,,你会发现我们进入这个lambda表达式\NAnd you'll see that we step into this lambda here.
Dialogue: 0,0:17:18.36,0:17:26.91,Default,,0,0,0,,而lambda调用connected函数，这个函数的参数有socket和request\NAnd the lambda calls connected and connected is executed with the socket and the request,
Dialogue: 0,0:17:26.91,0:17:27.87,Default,,0,0,0,,request的值是GET /foo\Nwhich is get foo
Dialogue: 0,0:17:29.46,0:17:30.99,Default,,0,0,0,,我们运行这个\NSo we run this.
Dialogue: 0,0:17:33.30,0:17:38.70,Default,,0,0,0,,我们需要在这里做同样的转换\NWe'll see that we need to do the same transformation down here for s.recv.
Dialogue: 0,0:17:40.65,0:17:41.70,Default,,0,0,0,,我们来修改一下\NSo let's do that.
Dialogue: 0,0:17:44.04,0:17:45.27,Default,,0,0,0,,我们可以说\NAnd we can say.
Dialogue: 0,0:17:48.75,0:17:49.71,Default,,0,0,0,,回调\NThe callback.
Dialogue: 0,0:17:51.12,0:17:52.44,Default,,0,0,0,,因为当socket是可读时\NFor when the socket is readable,
Dialogue: 0,0:17:52.44,0:17:54.18,Default,,0,0,0,,将函数命名为readable\Nwe're going to call it readable
Dialogue: 0,0:17:54.34,0:18:07.02,Default,,0,0,0,,和connected函数需要接收参数的方式是一样的\Nand the same way that connected needed to take the variables that had been available in the previous callback as arguments so does readable
Dialogue: 0,0:18:07.36,0:18:09.33,Default,,0,0,0,,在这个函数中仍然需要socket参数\Nin this case still needs the socket.
Dialogue: 0,0:18:09.33,0:18:11.34,Default,,0,0,0,,它不需要请求 我们已经完成了\NIt doesn't need request we're done with that,
Dialogue: 0,0:18:11.34,0:18:13.35,Default,,0,0,0,,但它确实需要一个分块的列表\Nbut it does need the list of chunks.
Dialogue: 0,0:18:14.79,0:18:19.05,Default,,0,0,0,,所以它会把这两个作为参数\NSo it's going to take those two as arguments,
Dialogue: 0,0:18:19.05,0:18:21.93,Default,,0,0,0,,当它被执行时\Nand when it's executed,
Dialogue: 0,0:18:21.93,0:18:25.50,Default,,0,0,0,,它知道s在这个时候是可读的\Nit knows that s is readable by this time.
Dialogue: 0,0:18:26.58,0:18:31.71,Default,,0,0,0,,所以它可以注销它的文件描述符并接收一个分块\NSo we can unregister its file descriptor and receive a truck.
Dialogue: 0,0:18:31.71,0:18:33.15,Default,,0,0,0,,我们知道这个分块\NAnd we know that a chunk.
Dialogue: 0,0:18:34.11,0:18:34.74,Default,,0,0,0,,嗯\NWell,
Dialogue: 0,0:18:34.74,0:18:39.72,Default,,0,0,0,,我们知道这不会引发异常 因为select调用\Nwe know that this won't raise an exception because the select call.
Dialogue: 0,0:18:40.71,0:18:45.87,Default,,0,0,0,,在这里确保了我们在这个socket上等待的事件都准备好了\NDown here said that whatever we're waiting for on this socket is ready.
Dialogue: 0,0:18:46.80,0:18:53.25,Default,,0,0,0,,所以这里不会出现资源不可用或其他异常\NSo we won't throw a resource unavailable or whatever that exception was.
Dialogue: 0,0:18:54.33,0:18:58.71,Default,,0,0,0,,数据块要么包含一些内容 或者服务器已经关闭\NThe chunk will either contain something or if the server has closed,
Dialogue: 0,0:18:58.71,0:19:00.42,Default,,0,0,0,,那么这个分块就是空的\Nthe connection then chunk is empty.
Dialogue: 0,0:19:00.42,0:19:01.41,Default,,0,0,0,,我们知道我们已经传完数据了\NAnd we know that we're done.
Dialogue: 0,0:19:03.84,0:19:06.15,Default,,0,0,0,,在这里\NSo up here,
Dialogue: 0,0:19:06.15,0:19:08.22,Default,,0,0,0,,这意味着我们不调用select\Nthat means that we don't call select,
Dialogue: 0,0:19:08.22,0:19:12.30,Default,,0,0,0,,因为这是事件循环的工作\Nbecause that's the eventloop's job,
Dialogue: 0,0:19:12.30,0:19:15.15,Default,,0,0,0,,但我们确实需要创建回调\Nbut we do need to create the callback.
Dialogue: 0,0:19:16.02,0:19:20.53,Default,,0,0,0,,它和我们之前创建的回调非常相似\NSo it's going to be very similar to the callback that we created before
Dialogue: 0,0:19:20.53,0:19:24.24,Default,,0,0,0,,还是一个由lambda表达式创建的闭包\Nit's going to be a closure expressed by lambda,
Dialogue: 0,0:19:24.24,0:19:25.65,Default,,0,0,0,,当我们执行它的时候\Nand when we execute it.
Dialogue: 0,0:19:27.03,0:19:29.73,Default,,0,0,0,,我们要传入socket和chunks变量\NWe're going to pass it the socket and the chunks,
Dialogue: 0,0:19:29.73,0:19:31.89,Default,,0,0,0,,这不再是一个循环\Nand this is no longer a loop.
Dialogue: 0,0:19:31.89,0:19:32.94,Default,,0,0,0,,我们只是注册\NWe just register.
Dialogue: 0,0:19:35.97,0:19:37.89,Default,,0,0,0,,回调一次 然后我们就做完了\NThe callback once and then we're done.
Dialogue: 0,0:19:40.05,0:19:41.34,Default,,0,0,0,,这意味着\NAnd that means that,
Dialogue: 0,0:19:41.34,0:19:43.96,Default,,0,0,0,,既然我们没有死循环了\Nsince we no longer have a while true loop
Dialogue: 0,0:19:44.18,0:19:47.64,Default,,0,0,0,,如果在这里我们有分块\Nthat down here, if we have a chunk,
Dialogue: 0,0:19:47.64,0:19:51.60,Default,,0,0,0,,我们需要等待剩下的部分\Nwe need to wait for the remaining chunks,
Dialogue: 0,0:19:51.60,0:19:52.95,Default,,0,0,0,,所以我们不能就这样离开这里\Nso we can't just leave here.
Dialogue: 0,0:19:52.95,0:19:53.73,Default,,0,0,0,,我们还要做些工作\NWe need to go.
Dialogue: 0,0:19:55.80,0:19:59.19,Default,,0,0,0,,给Callback赋值另一个闭包\NCallback equals yet another closure,
Dialogue: 0,0:19:59.19,0:20:06.98,Default,,0,0,0,,这将引起对readable函数的二次或多次调用\Nand that's going to cause a second call or Nth call to this readable function again
Dialogue: 0,0:20:07.12,0:20:13.58,Default,,0,0,0,,我们要在这里重新注册刚才注销的socket\Nand we'll register that again with a selector to re-register the socket that we unregistered up here
Dialogue: 0,0:20:13.58,0:20:16.59,Default,,0,0,0,,这里的return就没有必要了\Nand then this return calls no longer necessary.
Dialogue: 0,0:20:18.12,0:20:19.44,Default,,0,0,0,,如果我们运行这个\NSo if we run this.
Dialogue: 0,0:20:21.15,0:20:22.02,Default,,0,0,0,,我们会看到的\NWe'll see that.
Dialogue: 0,0:20:23.70,0:20:26.22,Default,,0,0,0,,我们的两个请求现在都完成了\NBoth of our requests now complete.
Dialogue: 0,0:20:26.22,0:20:27.54,Default,,0,0,0,,这是坠吼的\NSo that's fantastic,
Dialogue: 0,0:20:27.54,0:20:29.07,Default,,0,0,0,,但不幸的是\Nbut unfortunately.
Dialogue: 0,0:20:30.12,0:20:36.87,Default,,0,0,0,,我们看不到她的最终输出 因为我们在这个死循环里\NWe don't see her final output because we're in this while true loop,
Dialogue: 0,0:20:36.87,0:20:42.06,Default,,0,0,0,,所以我们被阻塞在这个selector上，因为没有什么可以做的了\Nso were blocked here on this selector because there's nothing left to do,
Dialogue: 0,0:20:42.06,0:20:44.43,Default,,0,0,0,,但是我们还没有让循环完成\Nbut we haven't told the loop to complete,
Dialogue: 0,0:20:44.43,0:20:46.44,Default,,0,0,0,,如果我们点击这里的停止\Nand if we hit stop here,
Dialogue: 0,0:20:46.44,0:20:47.16,Default,,0,0,0,,我们会看到的\Nwe'll see that.
Dialogue: 0,0:20:49.02,0:20:50.91,Default,,0,0,0,,我们卡在这行语句上了\NThis line is, in fact,where we're stuck.
Dialogue: 0,0:20:53.04,0:21:02.28,Default,,0,0,0,,所以我认为结束这个循环的正确方法是 搞清楚任务何时完成，然后退出循环\NSo I think that the right way to complete this loop now is to somehow figure out when all work is complete and then exit the loop.
Dialogue: 0,0:21:02.28,0:21:06.54,Default,,0,0,0,,所以我设置了任务数这个变量\NSo I'm going to say that there is some number of tasks.
Dialogue: 0,0:21:07.47,0:21:10.50,Default,,0,0,0,,这个变量贯穿整个执行过程\N*That are always in flight.
Dialogue: 0,0:21:12.54,0:21:13.89,Default,,0,0,0,,刚开始时\NTo begin with,
Dialogue: 0,0:21:13.89,0:21:14.85,Default,,0,0,0,,没有任务在执行\Nthere are none.
Dialogue: 0,0:21:16.14,0:21:17.97,Default,,0,0,0,,一旦我们调用get函数\NAnd whenever we call get.
Dialogue: 0,0:21:24.45,0:21:29.97,Default,,0,0,0,,就会增加任务数\NIt'll Increment the number of tasks.
Dialogue: 0,0:21:30.99,0:21:37.77,Default,,0,0,0,,当我们读完服务器的响应时\NAnd when we have finished reading a response from a server.
Dialogue: 0,0:21:40.29,0:21:45.15,Default,,0,0,0,,就可以把任务数减1了\NThen it's time to decrement it.
Dialogue: 0,0:21:47.25,0:21:52.22,Default,,0,0,0,,所以当我们调用get foo的时候把任务数增加到1\NSo when we call get foo that increments the tasks to one
Dialogue: 0,0:21:52.24,0:21:56.01,Default,,0,0,0,,当调用get bar 时，任务数又加1\Nand when we call get bar, that increments it too,
Dialogue: 0,0:21:56.01,0:21:56.55,Default,,0,0,0,,然后\Nand then,
Dialogue: 0,0:21:56.55,0:22:00.42,Default,,0,0,0,,当回调链都结束时\Nas each of the chains of callbacks runs to completion,
Dialogue: 0,0:22:00.42,0:22:02.01,Default,,0,0,0,,就将任务数减1\Nit decrements n_tasks.
Dialogue: 0,0:22:02.01,0:22:08.91,Default,,0,0,0,,直到这个事件循环的n_tasks为零时退出\Nuntil this event loop sees that n tasks is zero and quits
Dialogue: 0,0:22:10.50,0:22:12.15,Default,,0,0,0,,如果我们运行这个\NIf we run this,
Dialogue: 0,0:22:12.15,0:22:22.08,Default,,0,0,0,,然后我们会看到这两个请求都完成了 奇迹般地只花了一秒而不是两秒\Nthen we'll see that both of the requests complete and miraculously it's only taken one second, not two.
Dialogue: 0,0:22:22.08,0:22:24.30,Default,,0,0,0,,我们可以做到\Nand we can do.
Dialogue: 0,0:22:26.04,0:22:26.40,Default,,0,0,0,,哦\NOops.
Dialogue: 0,0:22:29.58,0:22:35.94,Default,,0,0,0,,更多的并发请求 还是只需要一秒\NMany more of these concurrent requests and it will still only take one second.
Dialogue: 0,0:22:36.87,0:22:40.68,Default,,0,0,0,,这样做的原因是服务器太慢了\NAnd the reason for that is that the server is so slow
Dialogue: 0,0:22:40.74,0:22:48.36,Default,,0,0,0,,与从服务器上等待下一个分段的时间相比\Nthat this client is not spending significant CPU processing each of the responses
Dialogue: 0,0:22:48.56,0:22:53.07,Default,,0,0,0,,（本地）客户端不用消耗大量的CPU资源去处理每一个响应\Ncompared to how long its spending waiting for the next chunk from the server.
Dialogue: 0,0:22:53.07,0:22:57.92,Default,,0,0,0,,服务器需要整整1秒才能返回几百字节的数据\NThe server takes a full second to return just a few hundred bytes of data
Dialogue: 0,0:22:58.38,0:23:03.54,Default,,0,0,0,,而客户端所做的只是将这些数据块插入到一个列表中\Nand all the client is doing is appending those chunks to a list.
Dialogue: 0,0:23:03.54,0:23:07.36,Default,,0,0,0,,因此 客户端几乎没有CPU开销\NSo the client is spending almost no CPU
Dialogue: 0,0:23:07.44,0:23:13.44,Default,,0,0,0,,而在绝大多数时间内都是在等待I/O\Nwith spending overwhelmingly the majority of its time waiting for i/o.
Dialogue: 0,0:23:13.89,0:23:18.66,Default,,0,0,0,,这就是异步优化的应用场景\NSo,this is the sort of thing that async is optimized for.
Dialogue: 0,0:23:18.66,0:23:26.50,Default,,0,0,0,,我们可以用一个简单的框架来做几十个甚至上百个并发的请求\NWe can do probably dozens or even hundreds of simultaneous requests with a simple framework like this one.
Dialogue: 0,0:23:26.78,0:23:33.75,Default,,0,0,0,,而不用在运算上损失大量的时间\Nand not lose significant amounts of time on computation,
Dialogue: 0,0:23:33.75,0:23:39.66,Default,,0,0,0,,它非常高效 因为它不需要保持空闲线程就可以达到同样的效果\Nand it's very efficient because it doesn't have to hold open idle threads In order to do that.
Dialogue: 0,0:23:41.76,0:23:43.14,Default,,0,0,0,,这很好\NSo that's great.
Dialogue: 0,0:23:43.14,0:23:44.19,Default,,0,0,0,,它非常高效\NIt's very efficient,
Dialogue: 0,0:23:44.19,0:23:52.23,Default,,0,0,0,,但你也会发现 与简单的初始get函数相比，现在就是一团乱麻\Nbut you'll also see that it's kind of a mess compared to a very simple initial implementation of Get,
Dialogue: 0,0:23:52.23,0:23:55.53,Default,,0,0,0,,我们现在写了一堆乱七八糟的东西\Nwe've now created a whole bunch of mess.
Dialogue: 0,0:23:55.53,0:23:57.48,Default,,0,0,0,,我们现在需要三个函数\NWe now need three functions where
Dialogue: 0,0:23:57.48,0:23:58.83,Default,,0,0,0,,原来只需要一个\Nbefore we only had one.
Dialogue: 0,0:24:00.03,0:24:01.44,Default,,0,0,0,,这三个函数\NThese three functions.
Dialogue: 0,0:24:02.76,0:24:07.74,Default,,0,0,0,,关于它们的特别之处在于 每当一个函数退出时\NWhat's particularly about about them is that each time a function exits,
Dialogue: 0,0:24:07.74,0:24:17.10,Default,,0,0,0,,它失去了所有的局部变量，例如s、request和chunks\Nit loses all of its local variables *right so s and request and chunks
Dialogue: 0,0:24:17.50,0:24:26.28,Default,,0,0,0,,当一个回调函数完成时，需要将下一个回调注册到调用链中\Neach time one of these callbacks completes and registers the next callback in the chain to be executed.
Dialogue: 0,0:24:26.28,0:24:34.08,Default,,0,0,0,,它必须手动将它的状态复制到一个闭包中 这样就可以在调用链的下一个回调中使用这个状态\NIt has to manually copy its state into a closure so that that state is available to the next call back in the chain.
Dialogue: 0,0:24:35.28,0:24:44.46,Default,,0,0,0,,语言提供给我们的基础设施，比如堆栈和局部变量\NThe normal facilities that the language provides to us in a stack and in local variables,
Dialogue: 0,0:24:44.46,0:24:48.69,Default,,0,0,0,,在我们的异步框架中，必须手动重新创建它们\Nwe have to manually recreate that stuff in our async framework.
Dialogue: 0,0:24:48.69,0:24:56.85,Default,,0,0,0,,在维持I/O状态时，语言特性对我们来说基本上没有帮助\NThe language is basically no help to us here in terms of maintaining state across IO operations.
Dialogue: 0,0:24:58.41,0:25:01.68,Default,,0,0,0,,所以问题的解决方案来到了下一个阶段\NSo the solution to this is the next phase.
Dialogue: 0,0:25:01.68,0:25:03.27,Default,,0,0,0,,协程\NIt's coroutines.
Dialogue: 0,0:25:04.44,0:25:08.82,Default,,0,0,0,,协程建立在Future类上\NAnd coroutines are built on Future.
Dialogue: 0,0:25:10.41,0:25:15.03,Default,,0,0,0,,这是我们稍后在介绍python生成器时看到的类\NWhich is a class that we'll see in a second on python generators.
Dialogue: 0,0:25:16.71,0:25:20.07,Default,,0,0,0,,我们稍后将会看到另一个叫做Task的类\NAnd on another class that we'll see in a moment called Task.
Dialogue: 0,0:25:21.24,0:25:24.57,Default,,0,0,0,,现在很多协程的概念\NNow there are a bunch of kinds of things called coroutines.
Dialogue: 0,0:25:24.57,0:25:26.67,Default,,0,0,0,,协程这个概念其实很早就有了\Ncoroutines are very old idea.
Dialogue: 0,0:25:26.67,0:25:31.54,Default,,0,0,0,,协程在不同的语言中有不同的实现\NThere are many kinds of implementations of coroutines in many languages
Dialogue: 0,0:25:32.81,0:25:36.12,Default,,0,0,0,,在Python3的asyncio中\Nin Python3 asyncio
Dialogue: 0,0:25:36.12,0:25:38.10,Default,,0,0,0,,当我们说协程的时候\Nwhat we mean when we say coroutines is,
Dialogue: 0,0:25:39.90,0:25:43.68,Default,,0,0,0,,指的是基于生成器的协程\NGenerator based coroutines.
Dialogue: 0,0:25:45.84,0:25:49.35,Default,,0,0,0,,Greenlet在Python3.5中也被称作协程\NGreenlet are also called coroutines in Python3.5.
Dialogue: 0,0:25:49.35,0:25:56.85,Default,,0,0,0,,现在有了新的原生协程 可以利用新的async和await关键字\NThere are now new things called native coroutines that can take advantage of the new async and await keywords.
Dialogue: 0,0:25:56.85,0:26:00.48,Default,,0,0,0,,它们本质上是基于生成器的语法糖\NThey're essentially syntactic sugar on top of generators.
Dialogue: 0,0:26:00.48,0:26:04.20,Default,,0,0,0,,所以如果你理解了我们之后讨论的内容\NSo if you understand the discussion they were going to have right now,
Dialogue: 0,0:26:04.20,0:26:09.63,Default,,0,0,0,,就能同时了解Python3.5中原生协程的工作方式\Nyou'll understand how the Python3.5 native coroutines work as well,
Dialogue: 0,0:26:09.63,0:26:13.53,Default,,0,0,0,,尽管它们是内置在解释器里而不是直接用生成器写的\Nalthough they're built into the interpreter rather than built out of generators,
Dialogue: 0,0:26:13.53,0:26:14.55,Default,,0,0,0,,这是我们现在要做的（用生成器实现）\Nthe way we're going to do right now.
Dialogue: 0,0:26:16.83,0:26:17.25,Default,,0,0,0,,所以\NSo.
Dialogue: 0,0:26:18.72,0:26:21.93,Default,,0,0,0,,我们首先需要的是一个future类\NThe first thing that we need is a future class.
Dialogue: 0,0:26:22.83,0:26:25.59,Default,,0,0,0,,稍后，你们会明白为什么它很有用\NAnd you'll see why in a little bit this is useful
Dialogue: 0,0:26:25.59,0:26:29.76,Default,,0,0,0,,我先把它写出来\Nbut for the moment I'm just going to present it,
Dialogue: 0,0:26:29.76,0:26:34.35,Default,,0,0,0,,你现在只需要相信这将会是一个有用的东西\Nand you'll just have to trust me that this is going to be a useful thing,
Dialogue: 0,0:26:34.35,0:26:41.16,Default,,0,0,0,,future类代表着一些我们正在等待但尚未完成的事件\Nso a future represents some pending event that we're were waiting for.
Dialogue: 0,0:26:42.24,0:26:48.90,Default,,0,0,0,,它有一个事件发生时将要被执行的回调列表\NIt has a list of callbacks that will be executed when that event occurs,
Dialogue: 0,0:26:48.90,0:26:53.88,Default,,0,0,0,,当事件发生时，会调用resolve函数，\Nand when that event occurs, somebody's going to call resolve and the future will.
Dialogue: 0,0:26:57.96,0:27:02.16,Default,,0,0,0,,future类会执行所有等待该事件的回调\NExecute all of the callbacks that were waiting for that event.
Dialogue: 0,0:27:02.16,0:27:03.48,Default,,0,0,0,,这就是我们的future类\NSo that's our future class.
Dialogue: 0,0:27:04.65,0:27:12.36,Default,,0,0,0,,我们要简单地修改代码，而不是直接用selector来注册和回调\NAnd we're going to do this simple transformation where instead of register and callbacks directly with the selector,
Dialogue: 0,0:27:12.36,0:27:14.10,Default,,0,0,0,,我们要注册futures类\Nwe're going to register futures instead.
Dialogue: 0,0:27:24.63,0:27:29.19,Default,,0,0,0,,所以我们将回调添加到future的回调列表中\NSo we add the callback to the list of callbacks.
Dialogue: 0,0:27:29.19,0:27:33.33,Default,,0,0,0,,等待这个future来执行回调 而不是直接注册回调\Nwaiting for this future to be resolved and instead of registering the callback directly.
Dialogue: 0,0:27:34.29,0:27:35.79,Default,,0,0,0,,我们注册future\NWe register the future instead.
Dialogue: 0,0:27:37.56,0:27:42.21,Default,,0,0,0,,这里也做相同操作\NAnd I have to do the same thing here.
Dialogue: 0,0:27:45.48,0:27:46.50,Default,,0,0,0,,最后\NAnd finally,
Dialogue: 0,0:27:46.50,0:27:51.03,Default,,0,0,0,,我们必须再做一次麻烦的重构\Nwe have to do that same laborious transformation.
Dialogue: 0,0:27:54.69,0:27:57.06,Default,,0,0,0,,在我们注册回调的三个地方\Nin the three places where we had registered callbacks,
Dialogue: 0,0:27:57.06,0:28:00.72,Default,,0,0,0,,我们现在给futures加入回调，并对futures进行了注册\Nwe're now adding callbacks to futures and registering the future instead.
Dialogue: 0,0:28:02.01,0:28:05.28,Default,,0,0,0,,这意味着在我们的事件循环中\NAnd that means that down here in our event loop.
Dialogue: 0,0:28:06.54,0:28:11.52,Default,,0,0,0,,data不再是回调，而是future对象\NThe event that data is no longer a callback its future,
Dialogue: 0,0:28:11.52,0:28:12.99,Default,,0,0,0,,所以我们不直接调用它\Nand so we don't call it directly.
Dialogue: 0,0:28:12.99,0:28:15.33,Default,,0,0,0,,而是调用它的resolve方法\NInstead,we say future.resolve.
Dialogue: 0,0:28:16.62,0:28:19.14,Default,,0,0,0,,所以你可以预测一下\NSo, you can expect,
Dialogue: 0,0:28:19.14,0:28:22.62,Default,,0,0,0,,进行简单的修改之后，很可能得到正确的结果\Nwith such a simple transformation that had probably got it right,
Dialogue: 0,0:28:22.62,0:28:26.13,Default,,0,0,0,,看上去我做到了\Nand it looks like I did so.
Dialogue: 0,0:28:26.13,0:28:31.44,Default,,0,0,0,,到目前为止，我们所做的一切都把代码变的又杂乱又冗长\NAll we've done so far is made our code even worse,  even more messy and long,
Dialogue: 0,0:28:31.44,0:28:35.34,Default,,0,0,0,,程序的性能和之前的一样\Nand we have simply got the same performance that we had before.
Dialogue: 0,0:28:36.57,0:28:44.64,Default,,0,0,0,,所以下一步就是用future类和生成器来实现协程\NSo the next step is going to be to somehow use these futures with generators to start to implement coroutines.
Dialogue: 0,0:28:46.98,0:28:51.98,Default,,0,0,0,,所以我要快速复习一下生成器\NSo I'm going to do a quick little refresher about Generators.
Dialogue: 0,0:28:52.10,0:28:55.62,Default,,0,0,0,,生成器有一些难以理解的特性\Ncause there's a few confusing things about them.
Dialogue: 0,0:28:55.62,0:28:59.07,Default,,0,0,0,,即使对经验丰富的python程序员来说也是如此\NEven for veteran python programs.
Dialogue: 0,0:29:00.51,0:29:05.32,Default,,0,0,0,,生成器是用生成器函数创建的\NSo a generator is created with a generator function
Dialogue: 0,0:29:05.56,0:29:12.87,Default,,0,0,0,,生成器函数是任何包含的yield表达式的函数\Nand a generator function is any function that contains the yield statement.
Dialogue: 0,0:29:13.98,0:29:16.89,Default,,0,0,0,,所以这个生成器函数将会打印start和1\NSo this generator function is going to print start yield one.
Dialogue: 0,0:29:18.66,0:29:19.20,Default,,0,0,0,,Middle\NMiddle.
Dialogue: 0,0:29:20.58,0:29:21.06,Default,,0,0,0,,还有2\NTwo.
Dialogue: 0,0:29:23.37,0:29:24.06,Default,,0,0,0,,最后打印done\NAnd then it's done.
Dialogue: 0,0:29:25.92,0:29:31.53,Default,,0,0,0,,生成器函数的有趣之处在于 当你执行它时\NAnd the funny thing about a generator function is that when you execute it,
Dialogue: 0,0:29:31.53,0:29:32.94,Default,,0,0,0,,它实际上并没有运行它的代码\Nit doesn't actually run its code.
Dialogue: 0,0:29:33.99,0:29:36.12,Default,,0,0,0,,它没有打印start middle或done\NIt didn't print start middle or done
Dialogue: 0,0:29:36.32,0:29:40.72,Default,,0,0,0,,而是创建了一个生成器对象\NInstead,it created a generator object
Dialogue: 0,0:29:41.20,0:29:50.52,Default,,0,0,0,,这个生成器对象包含一个代码对象,即用来表示这些内容的字节码（co_code）\Nand this generator object contains a code object *that's the byte code that represents this stuff.
Dialogue: 0,0:29:51.45,0:29:52.08,Default,,0,0,0,,然后\NAnd?
Dialogue: 0,0:29:53.13,0:29:59.48,Default,,0,0,0,,它有44个字节\NIt's got forty four bytes
Dialogue: 0,0:29:59.48,0:30:02.82,Default,,0,0,0,,生成器自身也有一个栈帧\Nand the generator also has a stack frame.
Dialogue: 0,0:30:03.93,0:30:05.61,Default,,0,0,0,,它有一个指令指针\NAnd that's got an instruction pointer,
Dialogue: 0,0:30:05.61,0:30:07.89,Default,,0,0,0,,初始值为-1\Nand it begins his negative one,
Dialogue: 0,0:30:07.89,0:30:11.70,Default,,0,0,0,,也就是说它还没有执行任何指令\Nmeaning that it hasn't executed any instructions yet.
Dialogue: 0,0:30:12.69,0:30:16.53,Default,,0,0,0,,这就是为什么我们没有看到这些print语句的输出\NAnd that's why we didn't actually see any of these prints statements is being executed.
Dialogue: 0,0:30:17.85,0:30:22.47,Default,,0,0,0,,运行一个生成器的方法是对它调用next函数\NSo the way to run a generator is to call him next on it.
Dialogue: 0,0:30:23.73,0:30:25.32,Default,,0,0,0,,如果你这样做\NAnd if you do that,
Dialogue: 0,0:30:25.32,0:30:30.72,Default,,0,0,0,,然后你会看到它执行了最初的一些字节码\Nthen you'll see that it executes its first few bites of byte code,
Dialogue: 0,0:30:30.72,0:30:32.52,Default,,0,0,0,,所以它打印start\Nso it prints start
Dialogue: 0,0:30:32.68,0:30:36.78,Default,,0,0,0,,1 实际上是next语句的返回值\Nand one is actually the return value of the next statement
Dialogue: 0,0:30:36.92,0:30:42.36,Default,,0,0,0,,因为next()的返回值由next执行的yield语句决定\Nbecause the return value of next is whichever yield is next executed.
Dialogue: 0,0:30:43.35,0:30:50.34,Default,,0,0,0,,现在 指令指针暂停在第13个字节处\NAnd the instruction pointer is now paused at thirteen bites into the forty four bytes of bytecode.
Dialogue: 0,0:30:51.51,0:30:54.22,Default,,0,0,0,,所以如果我们再次调用next\NSo if we call next again
Dialogue: 0,0:30:54.22,0:31:00.96,Default,,0,0,0,,我要保存它的返回值 这样你就能看到它打印出middle\Nthis time,I'm going to assign its return value so that you can see that a prints middle.
Dialogue: 0,0:31:02.64,0:31:05.64,Default,,0,0,0,,但它返回2\NBut it returns two.
Dialogue: 0,0:31:06.60,0:31:11.55,Default,,0,0,0,,这是下一个yield语句传递出的值\NWhich was the value passed into the next yield statement.
Dialogue: 0,0:31:12.90,0:31:17.04,Default,,0,0,0,,现在我们的堆栈指针(口误)\NAnd now our stack pointer....
Dialogue: 0,0:31:17.04,0:31:17.40,Default,,0,0,0,,对不起\NSorry,
Dialogue: 0,0:31:17.40,0:31:20.34,Default,,0,0,0,,我们的指示指针来到第28字节\Nour instruction pointer is at twenty eight of forty four.
Dialogue: 0,0:31:21.57,0:31:24.84,Default,,0,0,0,,如果我们再次调用next\NAnd if we call next one more time.
Dialogue: 0,0:31:25.83,0:31:28.95,Default,,0,0,0,,然后我们将看到停止迭代异常\NThen we'll raise stop iteration exception,
Dialogue: 0,0:31:28.95,0:31:30.15,Default,,0,0,0,,这说明\Nwhich indicates that
Dialogue: 0,0:31:31.05,0:31:38.64,Default,,0,0,0,,它已经完成了 lasti指针已经被删除了\NIt's done executing and the lasti pointer has actually been deleted.
Dialogue: 0,0:31:40.38,0:31:46.74,Default,,0,0,0,,这就是生成器如何在Python2.5及之前版本的中工作的\NSo that's how a generator works in all versions of Python going back two point five.
Dialogue: 0,0:31:49.02,0:31:52.53,Default,,0,0,0,,那么我们如何用它来实现协程呢\NSo how do we use that to create a coroutine?
Dialogue: 0,0:31:54.60,0:31:55.02,Default,,0,0,0,,嗯\NWell,
Dialogue: 0,0:31:55.02,0:31:56.25,Default,,0,0,0,,先做一个设想\Nhere's the promise.
Dialogue: 0,0:31:57.81,0:31:59.67,Default,,0,0,0,,我们的想法是这样的\NThe promise is going to be that.
Dialogue: 0,0:32:00.87,0:32:02.79,Default,,0,0,0,,这个get函数\NThis get function.
Dialogue: 0,0:32:04.95,0:32:10.26,Default,,0,0,0,,需要创建一个闭包 以捕获他的局部变量\NWhich currently has to create a closure that captures his local variables.
Dialogue: 0,0:32:12.03,0:32:13.92,Default,,0,0,0,,将其命名为callback\NNames that closure callback.
Dialogue: 0,0:32:14.94,0:32:20.58,Default,,0,0,0,,向future增加回调 然后注册future到selector\Nadds that callback to the future and then registers that future with the selector.
Dialogue: 0,0:32:21.93,0:32:25.38,Default,,0,0,0,,这个回调完全可以简化\NThis can be simplified to not require a call back at all.
Dialogue: 0,0:32:26.94,0:32:29.64,Default,,0,0,0,,所以我要删除回调\NSo I'm going to delete the callback.
Dialogue: 0,0:32:29.64,0:32:31.71,Default,,0,0,0,,删除回调主体\NI'm going to delete the callbacks body.
Dialogue: 0,0:32:34.02,0:32:39.08,Default,,0,0,0,,但我们需要暂停直至socket可写\NBut we need to pause until s is writable
Dialogue: 0,0:32:39.20,0:32:47.40,Default,,0,0,0,,在我们注销它之前，这里是可写的。当socket可写时，就可以调用send\Nsomehow here before we unregistered it and then rely on the socket to be writable so that we can call send on it
Dialogue: 0,0:32:47.76,0:32:51.87,Default,,0,0,0,,我们的想法是\Nand the promise is that somehow,
Dialogue: 0,0:32:51.87,0:32:53.49,Default,,0,0,0,,通过yield f\Nby yielding F,
Dialogue: 0,0:32:53.49,0:32:54.96,Default,,0,0,0,,这个我们刚刚创建的future对象\Nthe future that we just created.
Dialogue: 0,0:32:56.49,0:33:05.01,Default,,0,0,0,,我们可以用某种方式暂停这个生成器 直到我们感兴趣的事件发生\NSomehow we can pause this generator until the event that we said we were interested in has occurred.
Dialogue: 0,0:33:07.95,0:33:11.61,Default,,0,0,0,,如果我们认为这个设想可行\NAnd if we believe that this promise is true.
Dialogue: 0,0:33:12.63,0:33:20.85,Default,,0,0,0,,然后 我们可以将两个函数合并成包含yield语句的单一生成器函数\NThen we can combine what had been two functions into a single generator function that contains a yield statement.
Dialogue: 0,0:33:22.74,0:33:28.74,Default,,0,0,0,,但这个设想还没有实现,因为如果我运行这个\NBut the promise is not going to be fulfilled just yet because if I run this,
Dialogue: 0,0:33:28.74,0:33:30.21,Default,,0,0,0,,它将花费0秒\Nit's going to take zero seconds.
Dialogue: 0,0:33:30.21,0:33:31.71,Default,,0,0,0,,它没有输出\NIt has no output,
Dialogue: 0,0:33:31.71,0:33:33.03,Default,,0,0,0,,没有实现想要的效果\Nand it doesn't do any work.
Dialogue: 0,0:33:34.80,0:33:35.82,Default,,0,0,0,,为什么呢\NSo why is that?
Dialogue: 0,0:33:35.82,0:33:36.66,Default,,0,0,0,,这里发生了什么\NWhat happened here?
Dialogue: 0,0:33:38.64,0:33:39.21,Default,,0,0,0,,嗯\NWell,
Dialogue: 0,0:33:39.21,0:33:42.03,Default,,0,0,0,,回想一下 当你执行一个生成器函数时\Nrecall that when you execute a generator function,
Dialogue: 0,0:33:42.03,0:33:46.50,Default,,0,0,0,,它会返回生成器，实际上并不运行它的任何代码\Nit returns a generator doesn't actually run any of its code.
Dialogue: 0,0:33:46.50,0:33:49.92,Default,,0,0,0,,现在我在这里添加了一个yield语句\NSo now that I've added a yield statement here to get,
Dialogue: 0,0:33:49.92,0:33:51.81,Default,,0,0,0,,这意味着这里的get语句\Nthat means that get here.
Dialogue: 0,0:33:54.36,0:33:55.83,Default,,0,0,0,,只返回了一个生成器\NJust returns a generator.
Dialogue: 0,0:33:57.66,0:33:59.67,Default,,0,0,0,,实际上什么都没做\Ndoesn't actually do anything,
Dialogue: 0,0:33:59.67,0:34:00.57,Default,,0,0,0,,这里也是一样\Nand the same here.
Dialogue: 0,0:34:01.80,0:34:09.09,Default,,0,0,0,,那么我们要怎么执行它呢\NSo how are we going to execute it?
Dialogue: 0,0:34:09.09,0:34:10.65,Default,,0,0,0,,如何对它执行next方法呢\NHow do we call next on it?
Dialogue: 0,0:34:12.66,0:34:22.14,Default,,0,0,0,,这就是这个基于协程的异步框架的第三个部分：Task类\NSo that is the third piece of this puzzle of this coroutine based async framework is the task class.
Dialogue: 0,0:34:23.37,0:34:24.48,Default,,0,0,0,,Task类\NTask class.
Dialogue: 0,0:34:26.25,0:34:31.20,Default,,0,0,0,,它负责在生成器上调用next\NIt's responsible for calling next on generators.
Dialogue: 0,0:34:32.34,0:34:34.98,Default,,0,0,0,,我们来看看它是什么样的\NSo let's see what that looks like.
Dialogue: 0,0:34:34.98,0:34:37.23,Default,,0,0,0,,同时使用future和task类时\NAnd in the case of both future and task,
Dialogue: 0,0:34:37.23,0:34:45.15,Default,,0,0,0,,现在写的这些内容非常简单，或者说过于简单了，而且实现并不完善\Nthese are incredibly simple and oversimplified and buggy incomplete implementations of these ideas.
Dialogue: 0,0:34:45.15,0:34:48.99,Default,,0,0,0,,不过这些想法在许多框架中得到了充分体现\NThese ideas are fully expressed in a number of frameworks,
Dialogue: 0,0:34:48.99,0:35:00.21,Default,,0,0,0,,尤其是tornado和python3.4标准库中的asyncio\Nnotably tornado and now in asyncio in the python3.4 standard library.
Dialogue: 0,0:35:01.59,0:35:08.10,Default,,0,0,0,,所以我的丐版Task类的实现如下：\NSo my dumb version of the task class is going to look like.
Dialogue: 0,0:35:09.54,0:35:12.90,Default,,0,0,0,,我们将用生成器初始化它\NWe're going to initialize it with a generator.
Dialogue: 0,0:35:14.61,0:35:15.60,Default,,0,0,0,,我将保存它\NI will save that.
Dialogue: 0,0:35:17.28,0:35:20.79,Default,,0,0,0,,然后我们会有一个叫做Step的函数\NAnd then we'll have a function called Step,
Dialogue: 0,0:35:20.79,0:35:24.36,Default,,0,0,0,,这个术语是从asyncio那里借来的\Nand this terminology is borrowed from a asyncio.
Dialogue: 0,0:35:24.36,0:35:28.32,Default,,0,0,0,,step函数的任务就是在生成器上调用next\NWhat step does his calls next on the generator.
Dialogue: 0,0:35:30.18,0:35:35.10,Default,,0,0,0,,生成器将会yield一个future对象\NAnd since the generator,\Nit's going to yield a future.
Dialogue: 0,0:35:36.87,0:35:40.77,Default,,0,0,0,,这就变成了next()的返回值\NSo that's going to become the return value of next.
Dialogue: 0,0:35:40.77,0:35:43.71,Default,,0,0,0,,我们来捕获它\NSo let's capture that.
Dialogue: 0,0:35:46.02,0:35:46.68,Default,,0,0,0,,然后\NAnd then.
Dialogue: 0,0:35:48.33,0:35:51.00,Default,,0,0,0,,当这个future执行完回调时 我们想要达成什么目的？\NWhat do we want to happen when this future is resolved?
Dialogue: 0,0:35:51.93,0:35:56.79,Default,,0,0,0,,我们需要给future增加一些回调\NWe need to add some kind of callback to the future,
Dialogue: 0,0:35:56.79,0:35:59.82,Default,,0,0,0,,这是我们想要在future就绪时执行的动作\Nsomething that we want to happen once the future is ready
Dialogue: 0,0:35:59.96,0:36:07.47,Default,,0,0,0,,让我们把self.step作为回调\Nand let's just pass self dot step in as the callback.
Dialogue: 0,0:36:07.47,0:36:09.90,Default,,0,0,0,,所以一旦这个future完成之后\NSo once this future is resolved,
Dialogue: 0,0:36:09.90,0:36:13.47,Default,,0,0,0,,就会回到这里 然后再次对self.gen执行next\Nwe'll just come right back into here and we'll call next and self.gen again.
Dialogue: 0,0:36:15.00,0:36:18.33,Default,,0,0,0,,当再次对self.gen执行next时\Nwhen we call next on self.gen again,
Dialogue: 0,0:36:18.33,0:36:20.76,Default,,0,0,0,,程序这将在这里恢复执行\Nthat's going to resume here.
Dialogue: 0,0:36:24.42,0:36:28.65,Default,,0,0,0,,因此我们知道我们可以注销socket文件号\NAnd therefore we know that we can unregister the sockets file number,
Dialogue: 0,0:36:28.65,0:36:30.00,Default,,0,0,0,,现在socket是可写的\Nand that s is now writable.
Dialogue: 0,0:36:31.35,0:36:35.52,Default,,0,0,0,,所以如果我们运行它 它仍然不会起作用\NSo if we run this still not going to work.
Dialogue: 0,0:36:37.11,0:36:38.73,Default,,0,0,0,,原因是\NThe reason for that is.
Dialogue: 0,0:36:41.16,0:36:45.06,Default,,0,0,0,,我们需要对self.step做一个初始的调用\NThat we need to make an initial call the self.step,
Dialogue: 0,0:36:45.06,0:36:54.09,Default,,0,0,0,,我们给self.gen做了一个初始的调用(预激)这样我们就启动了get函数\Nso that we make an initial call to self.gen so that we get the get function started,
Dialogue: 0,0:36:54.09,0:36:55.95,Default,,0,0,0,,它会连接socket 等等\Nand it will connect the socket and so on.
Dialogue: 0,0:36:55.95,0:36:58.83,Default,,0,0,0,,我们在这里改一下\NSo let's just do that right here.
Dialogue: 0,0:36:58.83,0:36:59.64,Default,,0,0,0,,在构造函数中\NIn the constructor.
Dialogue: 0,0:37:02.49,0:37:09.87,Default,,0,0,0,,然后是这个修改的最后一步，下面这里\NAnd then the final step of this conversion is going to be down here,
Dialogue: 0,0:37:09.87,0:37:14.90,Default,,0,0,0,,我们需要用task把这些get调用包起来\Nwhere we need to wrap each of these calls in a task
Dialogue: 0,0:37:15.00,0:37:18.15,Default,,0,0,0,,当get返回一个生成器时，task对象会把它包起来\Nso when get returns a generator, the task wraps it
Dialogue: 0,0:37:19.74,0:37:23.84,Default,,0,0,0,,保存到self.gen中，然后调用self.step\NSigns it to self.gen and calls self.step
Dialogue: 0,0:37:23.92,0:37:34.50,Default,,0,0,0,,之后就会调用next，真正地执行代码直至第一个yield语句\Nand that will call next and that will actually begin this thing executing up until the first yield statement
Dialogue: 0,0:37:34.50,0:37:35.70,Default,,0,0,0,,如果我运行这个\NSo if I run this.
Dialogue: 0,0:37:38.34,0:37:39.12,Default,,0,0,0,,在某种程度上\NIn a way,
Dialogue: 0,0:37:39.12,0:37:41.19,Default,,0,0,0,,你会看到我们已经有些进步了\Nyou will see the way we make progress.
Dialogue: 0,0:37:42.15,0:37:45.57,Default,,0,0,0,,因为我们在这里抛出了一个停止迭代异常\NBecause we raise a stop iteration exception here.
Dialogue: 0,0:37:47.19,0:37:49.38,Default,,0,0,0,,所以这确实是个好消息\NSo that that actually that's good news,
Dialogue: 0,0:37:49.38,0:37:55.80,Default,,0,0,0,,因为这意味着这个get生成器实际上已经运行到结束了\Nbecause it means that this get generator has actually been run to completion.
Dialogue: 0,0:37:55.80,0:37:59.70,Default,,0,0,0,,它完成了它所要做的工作\NIt's done the work that it set out to do.
Dialogue: 0,0:37:59.70,0:38:01.41,Default,,0,0,0,,所以\Nso.
Dialogue: 0,0:38:01.41,0:38:02.37,Default,,0,0,0,,如果我们\Nif we.
Dialogue: 0,0:38:04.08,0:38:04.98,Default,,0,0,0,,catch一下异常\NCatch that.
Dialogue: 0,0:38:05.94,0:38:07.14,Default,,0,0,0,,我们想在这里做什么\NWhat do we want to do here?
Dialogue: 0,0:38:07.14,0:38:07.47,Default,,0,0,0,,嗯\NWell,
Dialogue: 0,0:38:07.47,0:38:08.43,Default,,0,0,0,,task完成了\Nthe task is done.
Dialogue: 0,0:38:08.43,0:38:10.11,Default,,0,0,0,,直接返回\NSo let's just return.
Dialogue: 0,0:38:11.34,0:38:12.93,Default,,0,0,0,,如果我们执行这个版本\NAnd if we execute this version.
Dialogue: 0,0:38:14.37,0:38:15.54,Default,,0,0,0,,实际上已经成功了\NIt actually completes.
Dialogue: 0,0:38:16.53,0:38:22.80,Default,,0,0,0,,吼啊 我们还有一些零散的回调\NSo this is fantastic now we've still got a few stray callbacks.
Dialogue: 0,0:38:23.67,0:38:24.63,Default,,0,0,0,,所以\NSo.
Dialogue: 0,0:38:25.62,0:38:28.98,Default,,0,0,0,,我们可以删去这些，在这里做同样的修改\NWe can get rid of those the same transformation that we did here.
Dialogue: 0,0:38:30.33,0:38:32.43,Default,,0,0,0,,所以在这里做同样的操作\NSo we're just going to do it down here again as well,
Dialogue: 0,0:38:32.43,0:38:33.33,Default,,0,0,0,,所以我们要\Nso we're going to.
Dialogue: 0,0:38:33.33,0:38:34.95,Default,,0,0,0,,我们再也不需要这个调用了\NWe don't need this call back any more.
Dialogue: 0,0:38:35.94,0:38:37.50,Default,,0,0,0,,你不需要把它加到future中\NYou don't need to add it to the future.
Dialogue: 0,0:38:38.46,0:38:46.68,Default,,0,0,0,,我们仍然需要说明我们关注的事件，并注册future对象\NWe do still need to say what event we're interested in and register the future to be resolved when that event occurs,
Dialogue: 0,0:38:46.68,0:38:50.01,Default,,0,0,0,,但是我们可以删除回调定义\Nbut we can delete the callback definition.
Dialogue: 0,0:38:51.06,0:38:55.71,Default,,0,0,0,,因为我们在之前的同一个函数中\NSince we're still in the same function as we were in before,
Dialogue: 0,0:38:55.71,0:38:59.01,Default,,0,0,0,,我们不需要一个冗余的全局声明\Nwe don't need a redundant global statement.
Dialogue: 0,0:39:00.27,0:39:06.48,Default,,0,0,0,,如果我们简单地yield我们新定义的future\NAnd if we simply yield this new future that we created,
Dialogue: 0,0:39:06.48,0:39:07.44,Default,,0,0,0,,这意味着\Nthat means that.
Dialogue: 0,0:39:08.76,0:39:09.42,Default,,0,0,0,,到目前为止\NBy now,
Dialogue: 0,0:39:09.42,0:39:13.71,Default,,0,0,0,,当task恢复的时候\Nby the time the task resolve.. resumes us,
Dialogue: 0,0:39:13.71,0:39:14.88,Default,,0,0,0,,这个socket现在是可读的\Nthe socket is now readable.
Dialogue: 0,0:39:17.97,0:39:21.57,Default,,0,0,0,,这是最后一个回调\NAnd here we've got our last of the callback.
Dialogue: 0,0:39:21.57,0:39:22.80,Default,,0,0,0,,我们可以把它删掉\Nso we can delete that.
Dialogue: 0,0:39:24.00,0:39:29.46,Default,,0,0,0,,我们可以yield我们的future 而不是注册一个回调\NAnd we can yield our future instead of registering a callback.
Dialogue: 0,0:39:36.72,0:39:42.18,Default,,0,0,0,,当我们收到下一个分块时 我们要做什么\NWhat do we want to do once we have received the next chunk?
Dialogue: 0,0:39:42.18,0:39:42.78,Default,,0,0,0,,换句话说\NIn other words,
Dialogue: 0,0:39:42.78,0:39:45.39,Default,,0,0,0,,当socket再次处于可读状态\Nonce the socket is readable again?
Dialogue: 0,0:39:46.68,0:39:50.46,Default,,0,0,0,,我们想要得到下一个分块，对吧？\Nwe want to receive the next chunk right？
Dialogue: 0,0:39:50.46,0:39:54.12,Default,,0,0,0,,所以我们最后要做的是\Nso what we're going to end up doing is
Dialogue: 0,0:39:54.24,0:40:05.13,Default,,0,0,0,,借鉴在教程刚开始的时候写的死循环\Nwe're going to end up reproducing the same while true loop that we originally had in the olden days at the beginning of this talk,
Dialogue: 0,0:40:05.13,0:40:08.10,Default,,0,0,0,,那时我们只写了一个简单的阻塞get函数\Nwhen we were writing a simple blocking get.
Dialogue: 0,0:40:09.06,0:40:10.83,Default,,0,0,0,,所以它看起来是这样的\NSo that's going to look something like.
Dialogue: 0,0:40:14.07,0:40:18.18,Default,,0,0,0,,我们要把这个放在循环中\NWe're going to put this within the loop.
Dialogue: 0,0:40:19.65,0:40:22.68,Default,,0,0,0,,每次执行循环时\NAnd each time through the loop we say,
Dialogue: 0,0:40:22.68,0:40:25.89,Default,,0,0,0,,我想从socket上读取数据\NI want to read from the socket,
Dialogue: 0,0:40:25.89,0:40:28.14,Default,,0,0,0,,所以等待这个future执行完毕\Nso wait for this future to be resolved.
Dialogue: 0,0:40:29.13,0:40:32.37,Default,,0,0,0,,然后从selector中注销socket\NAnd then unregistered the socket from the selector.
Dialogue: 0,0:40:32.37,0:40:33.12,Default,,0,0,0,,得到当前的分块\Nget the chunk.
Dialogue: 0,0:40:34.05,0:40:40.86,Default,,0,0,0,,如果有分块，那就加入到列表中 这个部分是多余的\NAnd if there is any then added to the list and this stuff is now extra.
Dialogue: 0,0:40:42.69,0:40:46.11,Default,,0,0,0,,这个循环会重复 在这里重复做这些\NThe loop will just repeat and do that stuff again up here,
Dialogue: 0,0:40:46.11,0:40:47.52,Default,,0,0,0,,如果没有分块\Nand if there's no chunk.
Dialogue: 0,0:40:47.52,0:40:48.42,Default,,0,0,0,,这意味着\NThat means that.
Dialogue: 0,0:40:50.07,0:40:51.96,Default,,0,0,0,,我们已经接收完服务器响应\NWe're done reading the server response,
Dialogue: 0,0:40:51.96,0:40:53.64,Default,,0,0,0,,所以我们可以\Nand so we can.
Dialogue: 0,0:40:55.26,0:40:56.46,Default,,0,0,0,,连接各个分块\NJoin the body up,
Dialogue: 0,0:40:56.46,0:40:59.85,Default,,0,0,0,,打印第一行 减去任务数\Nprint the first line decrement the tasks count,
Dialogue: 0,0:40:59.85,0:41:02.94,Default,,0,0,0,,从现在开始 我们又回到了一个无限循环\Nand since now we're in an infinite loop again.
Dialogue: 0,0:41:02.94,0:41:05.37,Default,,0,0,0,,在这里 我们需要立即返回\Nhere we need to return as soon as we're done.
Dialogue: 0,0:41:07.74,0:41:08.16,Default,,0,0,0,,现在\NNow,
Dialogue: 0,0:41:08.16,0:41:10.29,Default,,0,0,0,,如果一切顺利 我运行这个\Nif all goes well and I run this,
Dialogue: 0,0:41:10.29,0:41:14.34,Default,,0,0,0,,它仍然只花了一秒\Nthen it still takes one second.
Dialogue: 0,0:41:14.34,0:41:19.44,Default,,0,0,0,,它还是做了所有的工作\Nit still does all the work that it was asked to do
Dialogue: 0,0:41:19.80,0:41:26.25,Default,,0,0,0,,我们可以把它扩展到能够执行大量的任务而不损失任何性能\Nand we can still scale this out to a large number of tasks without any loss of performance,
Dialogue: 0,0:41:26.25,0:41:32.16,Default,,0,0,0,,因为发起10个或15个协程的资源消耗实在是太低廉了\Nbecause launching ten fifteen coroutines is incredibly cheap,
Dialogue: 0,0:41:32.16,0:41:36.36,Default,,0,0,0,,大概只和一堆回调差不多\Nit's roughly as cheap as a bunch of callbacks.
Dialogue: 0,0:41:37.44,0:41:40.52,Default,,0,0,0,,所以协程同时拥有回调和线程的长处\NSo coroutines are kind of the best of both worlds.
Dialogue: 0,0:41:40.66,0:41:44.98,Default,,0,0,0,,资源消耗和回调一样少，比线程更是不知道少到哪里去了\Nthey're about as cheap as callbacks they're much cheaper than threads
Dialogue: 0,0:41:45.24,0:41:50.58,Default,,0,0,0,,我在我的系统上测量了一个协程..\Non my system, I measured that a coroutine takes...
Dialogue: 0,0:41:51.54,0:41:57.15,Default,,0,0,0,,大约需要6K的内存，而线程需要30K\NAbout six K of memory versus about thirty K of memory for a thread,
Dialogue: 0,0:41:57.15,0:42:04.74,Default,,0,0,0,,此外 我做了一个小实验：我有可以启动超过十万个协程\Nand furthermore I did a little experiment and found that I was capable of launching over a hundred thousand coroutines.
Dialogue: 0,0:42:04.74,0:42:12.03,Default,,0,0,0,,它们的限制仅仅是Python进程允许分配的内存总量\NTheir limited only by the amount of ram that the Python process is allowed to allocate.
Dialogue: 0,0:42:12.93,0:42:14.10,Default,,0,0,0,,对比线程\Nversus Threads,
Dialogue: 0,0:42:14.10,0:42:18.03,Default,,0,0,0,,除了简单的内存限制之外 线程还受到其他限制\Nwhich are subject to other limits beside simply memory limits.
Dialogue: 0,0:42:18.03,0:42:24.63,Default,,0,0,0,,各种用户和操作系统限制了一个进程被允许启动线程数量\NThere are various user and operating system limits on the number of threads that a *process is allowed to start with.
Dialogue: 0,0:42:24.63,0:42:29.67,Default,,0,0,0,,这个问题在很多情况下都很难解决\Nwhich are difficult in various ways to work around,
Dialogue: 0,0:42:29.67,0:42:34.90,Default,,0,0,0,,线程占用空间和操作系统的数据结构，以及操作系统调度器\Nand they take up space and operating system data structures and the operating system scheduler
Dialogue: 0,0:42:35.02,0:42:39.18,Default,,0,0,0,,最终导致它们的开销变得非常大\Nthat eventually causes their overhead to become quite significant.
Dialogue: 0,0:42:40.35,0:42:49.24,Default,,0,0,0,,他们所做的一切只是在等待一些缓慢的I/O操作。这实际上不需要非常多的CPU资源\NAll they're doing is waiting around for some sort of slow IO operations that aren't actually going to require very much CPU。
Dialogue: 0,0:42:49.30,0:42:55.02,Default,,0,0,0,,相较于协程在这个程序中的应用\Nso compared to coroutines for a application like this,
Dialogue: 0,0:42:55.02,0:42:59.38,Default,,0,0,0,,这将花费很少的时间用于CPU计算\Nthat's going to spend very little time doing computation
Dialogue: 0,0:42:59.54,0:43:08.01,Default,,0,0,0,,并且绝大多数时间都花在等待一个缓慢的服务器或者 客户端的缓慢socket上\Nand overwhelmingly spending its time waiting for a slow server or a slow client at the other end of the socket.
Dialogue: 0,0:43:08.01,0:43:11.58,Default,,0,0,0,,在这种情况下协程有效率的多\NCoroutines are much more efficient for this kind of thing,
Dialogue: 0,0:43:11.58,0:43:16.29,Default,,0,0,0,,但是和回调相比 它们的简单得多 因为\Nbut compared to call backs their lot simpler because.
Dialogue: 0,0:43:17.46,0:43:23.25,Default,,0,0,0,,你可以把协程的所有的代码放在一个函数里\NYou can put all of the code for a coroutine in one function,
Dialogue: 0,0:43:23.25,0:43:29.25,Default,,0,0,0,,所以你不需要声明并注册整个调用链\Nso you don't have to declare and register a whole chain of callbacks.
Dialogue: 0,0:43:29.25,0:43:34.17,Default,,0,0,0,,你可以重复使用你的局部变量 就像你原来的习惯\NAnd you can just reuse your local variables the same way that  you have always done.
Dialogue: 0,0:43:36.27,0:43:47.13,Default,,0,0,0,,这就是Tornado或asyncio风格，这些基于协程的异步框架的开端。\NSo that's the beginning of Tornado style or async i/o style coroutine based async framework.
Dialogue: 0,0:43:50.13,0:43:52.71,Default,,0,0,0,,如果你想了解更多\NSo if you want to know more about this,
Dialogue: 0,0:43:52.71,0:43:57.84,Default,,0,0,0,,访问bit.ly/coroutines 我创建了一个页面\Ngo to bit.ly/coroutines so I've have created a landing page for you there
Dialogue: 0,0:43:57.98,0:44:03.09,Default,,0,0,0,,你可以在那里看到我刚才写的代码\Nthat'll link you out to a version of the code that I wrote just now,
Dialogue: 0,0:44:03.09,0:44:07.74,Default,,0,0,0,,那里也可以看到我和Guido(Python之父)合写的一章\Nas well as link you to a chapter that I wrote with Guido van Rossum
Dialogue: 0,0:44:07.78,0:44:12.84,Default,,0,0,0,,这章将会出现在开源应用程序架构系列的下一本书中\Nthat will appear in the next book in the architecture of Open source Application series.
Dialogue: 0,0:44:12.84,0:44:25.50,Default,,0,0,0,,这一章深入地介绍了在Python3.4的标准库中，基于生成器的协程的实现细节\Nand that chapter goes into far more detail about how generator based coroutines are implemented in asyncio on Python3.4 standard library,
Dialogue: 0,0:44:25.50,0:44:36.82,Default,,0,0,0,,特别是它详细描述协程如何利用基于python3的生成器特性\Nand especially it goes into how coroutines take advantage of generator features that are specific to python3
Dialogue: 0,0:44:37.38,0:44:43.56,Default,,0,0,0,,以及asyncio库中如何运用异步队列类\Nand how a asynchronous queue class that's included in asyncio,
Dialogue: 0,0:44:43.56,0:44:52.35,Default,,0,0,0,,以一种惯用线程的工作者非常熟悉的方式来使用协程\Ncan be used to coordinate coroutines in a way that's very familiar to people who are used to using threads.
Dialogue: 0,0:44:53.58,0:44:55.53,Default,,0,0,0,,提醒一下\NAnd as a reminder,
Dialogue: 0,0:44:55.53,0:45:00.21,Default,,0,0,0,,如果你想和我这样的人在一家开源公司工作\Nif you want to work with people like me at a opensource company,
Dialogue: 0,0:45:00.21,0:45:05.40,Default,,0,0,0,,非常热情、多元、充实以及有技术挑战的工作\Nthat's very warm and diversity has really fulfilling and technically challenging jobs.
Dialogue: 0,0:45:05.40,0:45:07.08,Default,,0,0,0,,Mongodb正在招聘\NMongo db is hiring.
Dialogue: 0,0:45:07.08,0:45:11.07,Default,,0,0,0,,我们在纽约的帕罗奥多和世界各地都设有办事处\NWe have offices in New York in Palo Alto and worldwide.
Dialogue: 0,0:45:11.07,0:45:14.16,Default,,0,0,0,,访问bit.ly/mongo-jobs\NGo to bit.ly/mongo-jobs.
Dialogue: 0,0:45:14.16,0:45:15.09,Default,,0,0,0,,我将很荣幸与你共事\NI would love to work with you.
