1
00:00:04,380 --> 00:00:08,130
大家好，我是A. Jesse Jiryu Davis
Hi, I'm A. Jesse Jiryu Davis

2
00:00:08,131 --> 00:00:12,660
我将解释Python协程是如何工作的
and I'm going to tell you how Python coroutines work.

3
00:00:14,520 --> 00:00:15,540
介绍一下我自己
Little about me,

4
00:00:15,541 --> 00:00:25,980
我是MongoDB的一名高级工程师，职责是为MongoDB写Python和C的驱动。
I work for a MongoDB,I'm a staff engineer, there work on the Python and the C drivers for MongoDB.

5
00:00:25,981 --> 00:00:32,100
是的,我们正在招聘。我强烈推荐来MongoDB工作
Yes, we are hiring and I highly recommend working for MongoDB.

6
00:00:32,101 --> 00:00:40,440
访问bit.ly/mongo-jobs了解所有的工作机会
You can go to Mongo-jobs to see all of the jobs that we've got open.

7
00:00:41,400 --> 00:00:44,580
如果你想了解更多关于这个话题的信息
And if you want more information about this talk,

8
00:00:44,581 --> 00:00:49,710
我在bit.ly/coroutines中新增了一个页面
I've set up a landing pages at bit.ly/coroutines

9
00:00:49,711 --> 00:00:56,370
你可以在链接里找到本视频的代码
You can find links there to the code that I'm going to write right now,

10
00:00:56,370 --> 00:01:05,640
同时，在即将发布的《开源应用程序架构》书中
and also to a chapter in the upcoming architecture of open source applications book

11
00:01:05,940 --> 00:01:16,050
我和Guido(Python创始人)合著了一章，其中深入地阐述了python协程工作的细节
that I co-wrote with Guido Van Rossum that goes into far more depth and is a very detailed exposition of python coroutines work.

12
00:01:17,160 --> 00:01:22,830
这个示例的主题是
So the agenda for this demo is going to be a

13
00:01:26,550 --> 00:01:29,880
基于回调的异步框架
callback-based async framework,

14
00:01:29,881 --> 00:01:35,400
写完之后，我们会看到它非常有效，但也有些混乱
and once we've written that we're going to see that it's very efficient but also kind of a mess,

15
00:01:35,401 --> 00:01:42,540
所以我们最后要把它改写成一个基于协程的框架
and so we're going to adapt that to a coroutine based framework instead.

16
00:01:44,220 --> 00:01:48,720
因此 从一个基于回调的异步框架入手
So to begin with a callback based async framework,

17
00:01:48,721 --> 00:01:51,990
它使用非阻塞socket
It uses non-blocking sockets.

18
00:01:52,980 --> 00:01:54,810
使用回调函数
uses the callbacks,

19
00:01:54,811 --> 00:01:55,560
当然
of course,

20
00:01:55,561 --> 00:01:58,980
它还使用一个事件循环
and it also uses an event loop.

21
00:02:00,420 --> 00:02:02,850
至于协程
And as for coroutines,

22
00:02:02,851 --> 00:02:05,460
到时候再说吧
well, we'll cross that bridge when we come to it.

23
00:02:06,510 --> 00:02:09,000
编码之前有一些准备工作
So a little bit of setup,

24
00:02:09,001 --> 00:02:14,490
我写了一个简单的web服务器(Github代码中的server.py)
I've written a simple web server and.

25
00:02:18,750 --> 00:02:21,060
它可以响应http请求
It can respond to an HTTP request.

26
00:02:22,440 --> 00:02:27,510
我为本地的python会议"PyGotham 2015"写了这篇文章
I wrote this for a local python conference PyGotham 2015,

27
00:02:27,511 --> 00:02:32,730
所以你可以看到它向所有那些了不起的人们致意
so you can see that it says hello to all of the incredible people there.

28
00:02:32,731 --> 00:02:37,020
这个框架的另一个有趣之处是它有点慢
And the other interesting thing about this framework is its kind of slow.

29
00:02:38,520 --> 00:02:42,300
这个web服务器返回非常简单的响应
This web server returns very simple response,

30
00:02:42,301 --> 00:02:47,610
但我故意增加了一些sleep代码 所以要花差不多一秒的时间响应
but I've coded it so that it takes almost a second to reply.

31
00:02:47,611 --> 00:02:50,550
这么做的重要性将会在后面体现
And so that's going to end up being very important,

32
00:02:50,551 --> 00:02:54,390
因为这是最适合用异步优化的场景：
because that's the sort of thing that async is optimized for.

33
00:02:54,391 --> 00:03:00,450
与速度较慢的服务器或者客户端进行有效率的通信
Is for talking too slow servers or slow clients efficiently.

34
00:03:02,490 --> 00:03:04,380
让我们看看
So let's see,

35
00:03:04,381 --> 00:03:11,280
我们怎样才能以典型的python方式获取URL
how would we fetch a URL in the kind of typical python way.

36
00:03:14,610 --> 00:03:19,620
所以我们先导入socket
so we would need to import socket right?

37
00:03:21,240 --> 00:03:22,350
然后
And?

38
00:03:30,660 --> 00:03:34,110
绑定到合适的域名和端口
Connected to the proper domain and port.

39
00:03:35,640 --> 00:03:36,900
格式化一个请求
we format a request

40
00:03:48,870 --> 00:03:50,580
把它发送到服务器
then we would send it to the server.

41
00:03:51,750 --> 00:03:54,270
我用的python3环境
And I'm going to do this in Python 3

42
00:03:54,271 --> 00:03:59,820
所以对那些通过网络传输的所有内容进行编码是很重要的
and so it's important to encode everything that we're going to send over the wire.

43
00:03:59,821 --> 00:04:00,000
哦
Oh,

44
00:04:00,001 --> 00:04:02,130
另一个需要记住的重要的事情是
and the other important thing to remember is that.

45
00:04:04,590 --> 00:04:12,750
每个HTTP请求头部以两个回车换行符分隔
Each HTTP requests end in a double carriage return to a new line

46
00:04:12,751 --> 00:04:19,350
所以一旦我们发送了请求就会收到响应 它会以分块的形式返回给我们
so once we've sent the request were going to receive the response and that'll come back to us in chunks.

47
00:04:19,351 --> 00:04:23,310
所以我们要把它们收集到一个列表中
so we're just going to collect those in a list.

48
00:04:28,650 --> 00:04:30,810
收集最多1000个分块(口胡)
Receive them up to a thousand chunks

49
00:04:30,811 --> 00:04:33,210
一次接收1000字节
a thousand bytes at a time,

50
00:04:33,211 --> 00:04:35,400
只要我们接收完一个分块
and as long as we've got a chunk.

51
00:04:39,450 --> 00:04:44,070
就将它加到列表中，如果我们得到一个空的块
will append it to the list and if we get an empty chunk,

52
00:04:44,071 --> 00:04:46,320
我们就知道服务器断开了
then we know that the server is hung up on us.

53
00:04:46,321 --> 00:04:49,860
所以数据就接收完毕了
so our reception is complete,

54
00:04:49,861 --> 00:04:52,920
所以响应内容将会是
and so the body is going to be....

55
00:04:56,160 --> 00:04:59,640
我们将用空字节类型来连接所有的块
We'll use the empty bye to join all the chunks.

56
00:05:00,750 --> 00:05:03,900
然后我们会解码
And then we'll decode that.

57
00:05:05,820 --> 00:05:07,290
默认是utf-8
The utf-8 by default.

58
00:05:08,490 --> 00:05:17,280
然后我们把响应内容的第一行打印出来
And then let's just prints the first line of the body.

59
00:05:19,980 --> 00:05:21,480
所以
So,

60
00:05:21,481 --> 00:05:23,130
因为我们在死循环中
and since we're in an infinite loop,

61
00:05:23,131 --> 00:05:24,270
我们需要返回
we need to return,

62
00:05:24,270 --> 00:05:29,260
这就是我们的get函数。如果我们get参数/foo
so that's our get function and if we get that path Foo

63
00:05:29,540 --> 00:05:39,450
运行程序,可以看到响应的第一行是http 200 OK
and if I run this, you'll see that the first line of the response is an http 200 OK.

64
00:05:40,980 --> 00:05:41,580
然后
And?

65
00:05:42,480 --> 00:05:43,560
让我们看看
Let's also see.

66
00:05:45,180 --> 00:05:46,320
整个过程的运行时间
How long that took

67
00:06:00,600 --> 00:06:04,380
这需要大约一秒钟的时间 因为还有Python解释器的一点开销
So it takes about a second because there's a little bit of overhead in the Python interpreter.

68
00:06:05,490 --> 00:06:11,070
这种方法的问题是 如果我们想要访问两个url
the problem with this approach is that if we want to get 2 Urls,

69
00:06:11,071 --> 00:06:15,420
就需要两秒钟 因为我们是串行地获取URL
it's going to take two seconds because we get them serially.

70
00:06:17,070 --> 00:06:24,630
典型方法是在两个线程上启动这两个get操作
And the typical approach to this might be to launch these two operations on two threads,

71
00:06:24,631 --> 00:06:31,230
但如果我们等待数百个缓慢的请求，效率可能会变得非常低
but that might become inefficient if we're waiting for hundreds of slow requests,

72
00:06:31,231 --> 00:06:34,770
因为我们不得不为这些请求创建数百个线程
and we have to spawn hundreds of threads for them.

73
00:06:34,771 --> 00:06:36,960
有很多的开销是不必要的
There's a lot of overhead though it's not necessary,

74
00:06:36,961 --> 00:06:41,400
所以我们将尝试写一个异步的框架来代替它
so we're going to try out making an async framework to do it instead,

75
00:06:41,401 --> 00:06:49,050
这样我们就不需要为了执行数百次缓慢的I/O请求而创建数百个线程了
so that we don't have to spawn hundreds of threads in order to do hundreds of slow i/o operations,

76
00:06:49,051 --> 00:06:51,360
我们想要比这更有效率的办法
we want to be more efficient than that.

77
00:06:51,361 --> 00:06:51,930
所以
So.

78
00:06:53,070 --> 00:07:00,750
异步框架可以使用非阻塞socket，python中实现非阻塞的基本框架非常简单
A async framework could uses non-blocking sockets and in python making socket non blocking is very simple.

79
00:07:01,770 --> 00:07:04,800
如果我们运行程序，将会发生什么
Now what's going to happen if we run this?

80
00:07:05,880 --> 00:07:07,950
我们会得到一个异常，因为
We're going to get an exception because.

81
00:07:09,540 --> 00:07:15,390
一个非阻塞socket的意思是任何会阻塞的操作
A non blocking socket what that means is any operation that would block,

82
00:07:15,391 --> 00:07:22,080
就像连接操作，要么立即成功 要么抛出异常
like connecting,either succeeds immediately or raises an exception.

83
00:07:22,081 --> 00:07:22,350
对
Right.

84
00:07:22,351 --> 00:07:23,790
它是不允许阻塞的
It's not allowed to block.

85
00:07:23,791 --> 00:07:27,030
不允许一直等待直到程序成功完成操作
it's not allowed to wait for success.

86
00:07:28,050 --> 00:07:34,140
所以我们需要一些方法来等待它完成
So we need some way to wait for that to complete.

87
00:07:35,490 --> 00:07:37,410
我们用Python来做这个
And the way we do that in Python.

88
00:07:38,550 --> 00:07:39,090
嗯
Well,

89
00:07:39,091 --> 00:07:39,630
首先
first of all,

90
00:07:39,631 --> 00:07:47,370
我们可以先忽略这个错误
we can just ignore that error.

91
00:07:48,510 --> 00:07:50,360
但这没有太大帮助
But that's not going to get us very far

92
00:07:50,420 --> 00:07:56,220
一旦我们试着给socket发送数据，就会报错：socket未连接
because as soon as we tried to send something of the socket is going to say that it's not connected yet right

93
00:07:56,320 --> 00:08:00,000
当我们调用connect时
because when we called connect,

94
00:08:00,001 --> 00:08:02,790
非阻塞socket开始执行操作
the non-blocking socket began the operation.

95
00:08:02,791 --> 00:08:05,130
但它并没有等待操作完成
But it didn't wait for the operation to complete.

96
00:08:05,131 --> 00:08:06,900
因此我们还没有准备好发送数据
And so we're not ready to send it yet.

97
00:08:07,860 --> 00:08:12,870
那么，我们怎么知道何时才能准备好发送一个操作呢
So how do we know when we're ready to send an operation?

98
00:08:14,220 --> 00:08:15,450
嗯
Well,

99
00:08:15,451 --> 00:08:16,620
python3
python 3.

100
00:08:19,050 --> 00:08:21,570
有一个易于使用的包叫做selectors
There's this handy module called selectors.

101
00:08:24,360 --> 00:08:28,350
在每一个远古版本的操作系统中
In every operating system since time immemorial,

102
00:08:28,351 --> 00:08:34,440
就有一些方法可以在非阻塞socket上等待某些事件
there has been some way to wait for some event on a non blocking socket.

103
00:08:34,441 --> 00:08:35,100
最初
Originally,

104
00:08:35,101 --> 00:08:37,860
有系统调用select
there was the system call select,

105
00:08:37,861 --> 00:08:39,060
随着时间的推移
and then over time,

106
00:08:39,061 --> 00:08:43,260
越来越多的可扩展的新版select已经被发明出来了
more and more scalable versions of select have been invented.

107
00:08:43,261 --> 00:08:46,080
比如Linux上的poll
Like poll on Linux,

108
00:08:46,081 --> 00:08:50,460
BSD和Mac上的epoll以及windows上的kqueue
epoll on Bsd and Mac kqueue on windows.

109
00:08:50,461 --> 00:08:52,860
这些都是I/O完成端口
there's these I/O completion ports.

110
00:08:54,210 --> 00:08:56,400
Python3.4的优点是
The nice thing about Python 3.4

111
00:08:57,990 --> 00:09:03,390
你可以获取一个默认选择器
Is that you can just ask it for a default selector,

112
00:09:03,391 --> 00:09:14,160
它会识别你当前使用的系统，给你最匹配的selector
and it will figure out what your running and give you the most efficient selector for your platform,

113
00:09:14,161 --> 00:09:16,620
所以我们要做一个这样的程序：
so we'll make one of those and.

114
00:09:18,120 --> 00:09:21,000
在我们试着给socket发送任何东西之前
Before we try to send anything on the socket.

115
00:09:22,170 --> 00:09:24,840
我们将等待它到可读状态
We're going to wait for it to be readable.

116
00:09:24,841 --> 00:09:28,380
我们会等着它准备好要发送的内容
We're going to wait for it to be ready for something to be sent,

117
00:09:28,381 --> 00:09:30,300
为了做到这一点
so to do that,

118
00:09:30,301 --> 00:09:34,230
我们注册了socket文件号
we register the sockets file number,

119
00:09:34,231 --> 00:09:36,810
就是一个整型
which is just an integer.

120
00:09:36,811 --> 00:09:38,820
它只是一个文件描述符
it's just a file descriptor.

121
00:09:38,820 --> 00:09:44,700
这将告诉selector，这是一个我们在事件发生时关注的文件号
And we're going to tell the selector that this is a file number that we're interested in events on

122
00:09:44,800 --> 00:09:52,723
我们关注的事件则是socket何时处于可写状态
and the specific event that we're interested in is we want to know when the socket is writable

123
00:09:52,720 --> 00:09:57,040
pycharm可以自动为我们导入那个常量(win: Alt+Enter)
and pycharm can auto import that constant for us.

124
00:09:59,340 --> 00:10:00,800
我们要做的下一件事是
The next thing we do

125
00:10:00,880 --> 00:10:06,480
到目前为止，所做的一切都表明我们关注这个事件中的文件描述符
so all we have done so far said I'm interested in this event on this file descriptor.

126
00:10:06,481 --> 00:10:13,080
如果我们调用select 它会等待我们要求的事件发生
And then if we call select that will wait for some event that we've asked about to happen.

127
00:10:14,130 --> 00:10:15,120
所以
So,

128
00:10:15,121 --> 00:10:16,620
一旦这种情况发生
once that happens,

129
00:10:16,621 --> 00:10:20,160
我们可以注销文件号
we can unregistered the file number.

130
00:10:21,510 --> 00:10:22,830
此时
And by this point.

131
00:10:24,990 --> 00:10:25,860
s(socket)是可写的
s is writable.

132
00:10:27,930 --> 00:10:31,560
这意味着我们可以合法地调用send
So that means that we can legally now call send on it.

133
00:10:31,561 --> 00:10:33,000
如果我现在调用这个
So if I call this now.

134
00:10:35,070 --> 00:10:38,040
你会看到程序已经越过这行
You'll see that I get past this line,

135
00:10:38,041 --> 00:10:45,090
但是现在这里抛出一个异常，因为这个socket是可写的
but now we're throwing an exception down here because the socket is writable,

136
00:10:45,091 --> 00:10:52,170
但是它还没有变得可读 我们还没有等待服务器开始发送它的响应
but it hasn't become readable yet We haven't waited for the server to start sending its response.

137
00:10:53,490 --> 00:10:55,140
所以为了等待服务器
So in order to wait for that,

138
00:10:55,141 --> 00:10:59,550
我们必须再做一次同样的操作
we have to do the same dance again,

139
00:10:59,551 --> 00:11:04,320
这一次我们对可读情况感兴趣而不是可写情况
and this time we're not interested in write ability we're interested in readability.

140
00:11:04,321 --> 00:11:08,580
这里可以用pycharm的自动导入（win: Alt + Enter）
So we have the pycharm auto inputs that

141
00:11:10,170 --> 00:11:12,030
再次等待socket
We wait for it again,

142
00:11:12,031 --> 00:11:15,960
一旦这个调用完成
and once this call completes,

143
00:11:15,961 --> 00:11:20,370
那我们就注销文件号
then we'll unregistered the file number,

144
00:11:20,370 --> 00:11:22,420
现在我们可以接收数据了
and now we're allowed to receive

145
00:11:22,500 --> 00:11:25,170
如果我现在运行，它可以正常工作
so if I run this code now it completes,

146
00:11:25,171 --> 00:11:29,640
但我们还没有得到真正想要的效果，还是需要两秒
but we haven't really won anything right still took two seconds.

147
00:11:29,641 --> 00:11:33,060
我们只是把代码弄得一团糟
We just kind of made a small mess in our code.

148
00:11:33,061 --> 00:11:37,590
但我们还没有获得任何效率的提升
But we haven't gained any efficiency improvements yet.

149
00:11:43,200 --> 00:11:44,640
那么下一步做什么呢
So what's the next step?

150
00:11:46,410 --> 00:11:51,990
在使用了非阻塞socket之后的步骤
The next step after we've started to use non blocking sockets,

151
00:11:51,991 --> 00:11:53,490
是回调
is callbacks.

152
00:11:55,080 --> 00:11:56,520
我将解释它是如何工作的
So I'll explain how that works.

153
00:11:57,600 --> 00:12:07,410
回调是一种允许多个操作并发等待I/O操作的方法
Callbacks are a way of allowing multiple operations to be waiting concurrently for i/o operations.

154
00:12:11,760 --> 00:12:13,350
首先以这个get函数为例
To begin with, this get.

155
00:12:14,370 --> 00:12:16,530
当开始连接时
When it starts connecting,

156
00:12:16,531 --> 00:12:23,610
一旦socket可写时，注册的回调将被执行
it needs to register callback to be executed once the socket is writable,

157
00:12:23,610 --> 00:12:24,920
之后它需要返回
and then it needs to return

158
00:12:24,980 --> 00:12:33,930
这样当我们在等待连接这个socket的时候，就可以开始获取另一个URL
so that work can begin on getting the other URL while we're waiting to connect this socket right,

159
00:12:33,931 --> 00:12:38,460
我们需要某种并发手段来优化这两秒的时间
we need some sort of concurrency in order to get past this two seconds.

160
00:12:39,870 --> 00:12:41,190
我们来看看它是如何工作的
So let's see how that would work.

161
00:12:42,510 --> 00:12:46,260
我们可以先写回调的主体
We can begin by writing the body of that call back,

162
00:12:46,261 --> 00:12:47,820
所以我将它命名为connected函数
so I'm gonna call it connected.

163
00:12:47,821 --> 00:12:49,080
这将会执行
This is going to execute.

164
00:12:50,190 --> 00:12:54,810
一旦socket已连接，它就会执行下一步
Once the socket is connected and it's going to do the next step.

165
00:12:55,980 --> 00:12:58,410
但问题是
But the problem is,

166
00:12:58,411 --> 00:13:01,410
你可以看到PyCharm有错误提示了
you can see that right now PyCharm is sort of losing its mind

167
00:13:01,411 --> 00:13:10,950
因为在这个新函数中有两个变量没有声明，因为我们在get函数中创建了它们
because there's two variables that are not bound in this new function because we created them up here in get.

168
00:13:12,330 --> 00:13:17,400
这两个变量是s和request
And the two variables are s and request.

169
00:13:17,401 --> 00:13:21,360
假设这些变量通过某种方式传递给connected函数
So let's say that those are passed into connected somehow.

170
00:13:23,340 --> 00:13:27,240
解决办法是
And that somehow is going to be.

171
00:13:27,241 --> 00:13:33,330
我们将使用lambda来创建一个闭包来捕获这两个值
We're going to use a lambda to create a closure to capture those two values.

172
00:13:33,331 --> 00:13:35,160
所以我们要创建一个Lambda表达式
so we'll create a Lambda.

173
00:13:36,300 --> 00:13:43,440
这样调用Lambda执行connected函数就可以使用这两个变量了
And we'll say that calling the Lambda executes connected with the socket and the request,

174
00:13:43,441 --> 00:13:46,440
我们把这个叫做lambda回调
and we'll call this lambda callback.

175
00:13:48,210 --> 00:13:50,520
现在我们如何使用这个回调？
Now what do we do with this callback?

176
00:13:50,521 --> 00:13:54,060
selector.register
Well selector.register,

177
00:13:54,061 --> 00:14:00,870
它有特别的隐藏参数，有点像*b-side(唱片的B面，指没被选入专辑的歌)
it has this special hidden argument sort of a b-side,

178
00:14:00,871 --> 00:14:03,210
它被称为data
and it's called data,

179
00:14:03,210 --> 00:14:06,360
所以我们要把回调作为data的参数传递给调用者
so we're going to pass the callback again as data.

180
00:14:06,400 --> 00:14:08,160
因为这是Python(动态语言)
because this is Python,

181
00:14:09,750 --> 00:14:15,120
data可以是任何东西，所以我们要把lambda作为data参数传入
The data can be anything so we're going to pass in our lambda as the data.

182
00:14:17,370 --> 00:14:17,940
然后
And?

183
00:14:19,950 --> 00:14:24,510
我们要等到connected被调用时才注销那个文件号
We're going to wait until connected is called to actually unregistered that file number.

184
00:14:24,511 --> 00:14:25,470
现在
Now,

185
00:14:25,471 --> 00:14:26,970
如果我们这样做
if we do this.

186
00:14:30,450 --> 00:14:32,130
不幸的是
Unfortunately,

187
00:14:32,131 --> 00:14:33,720
我们实际上并没有完成任何工作
we don't actually get any work done.

188
00:14:34,860 --> 00:14:36,840
因为我们的回调从来没有真正执行过
Because our callback is never actually executed.

189
00:14:37,830 --> 00:14:48,930
那么我们如何确保在等待的事件发生的时候，立即执行这个回调呢
So how do we make sure that this callback is actually run, once the event that it's waiting for has been executed?

190
00:14:48,931 --> 00:14:53,250
为了解决这个问题，我们需要异步框架的第三部分
Well for that we need the third part of our async framework.

191
00:14:53,251 --> 00:14:54,570
我们需要一个事件循环
We need an event loop.

192
00:14:56,550 --> 00:14:58,170
我在这里把它写出来
so I'm going to code that down here.

193
00:15:00,450 --> 00:15:05,130
get函数将首先运行，它会启动一个socket连接
get is going to run first and it's going to start a socket connecting,

194
00:15:05,131 --> 00:15:10,230
然后它会注册一个回调 当socket是可写的时候就会执行
and then it's going to register a callback to be executed when the socket is writable.

195
00:15:10,231 --> 00:15:14,160
一旦foo执行完成了，bar也做同样的操作
and once foo has done that it returns and bar does the same thing.

196
00:15:14,161 --> 00:15:19,740
现在我们有两个非阻塞的socket在连接的过程中
So now we've got to two non blocking sockets that are open and in the midst of connected,

197
00:15:19,741 --> 00:15:24,450
它们都已经在selector中注册了
and they've both been registered with the selector.

198
00:15:24,451 --> 00:15:29,550
所以我先运行一个简略的事件循环
So I'm going to run a *dirt simple little event loop here,

199
00:15:29,551 --> 00:15:33,780
写下selector.select
and it's going to say selector dot select.

200
00:15:35,130 --> 00:15:41,490
现在让我们用调试器运行到这里，看看select实际返回的是什么
Now let's run this through the deBugger here and see what select actually returns.

201
00:15:41,491 --> 00:15:44,610
所以我设置了一个断点
So I set a break point,

202
00:15:44,611 --> 00:15:47,820
现在我们有了这个事件列表
and now we've got this events list,

203
00:15:47,821 --> 00:15:49,980
如果我查看这个事件列表
and if I inspect that,

204
00:15:49,981 --> 00:15:51,960
你会看到它是一个列表
you'll see that it's a list.

205
00:15:51,961 --> 00:15:53,580
它有两个元素
It's got two elements,

206
00:15:53,581 --> 00:15:56,640
我们来看看第一个元素是什么
and let's see what that first element is.

207
00:15:56,641 --> 00:15:58,260
它有
It's got.

208
00:15:58,261 --> 00:16:00,450
它是一个有两个值的元组
It's a tuple with two values.

209
00:16:00,451 --> 00:16:02,130
第二个值不是很有趣
A second value isn't very interesting.

210
00:16:02,131 --> 00:16:06,990
这只是我们一开始传递的mask
This is just the *mask that we passed in at first,

211
00:16:06,991 --> 00:16:11,040
它等于常量EVENT_WRITE的值
and it's equal to the EVENT_WRITE value.

212
00:16:11,041 --> 00:16:15,840
但我们已经知道了 因为那是我们唯一感兴趣的事件
but we already knew that because that was the only event that we were interested in.

213
00:16:15,841 --> 00:16:18,960
它是元组的第一个元素
It's this first element of the tuple.

214
00:16:18,961 --> 00:16:22,530
这个SelectorKey很有趣
This SelectorKey thing that's really interesting,

215
00:16:22,531 --> 00:16:28,920
当我调用寄存器时 你会看到我传递的数据值
and you'll see that the data value that I passed in when I called register.

216
00:16:28,920 --> 00:16:37,080
在这个事件列表中得到了这个对象，它的内容是我注册为回调的lambda表达式
We're getting that back out in this events list and its contents is that lambda that I registered as the callback

217
00:16:37,100 --> 00:16:41,550
让我们执行它
So let's execute it.

218
00:16:43,440 --> 00:16:44,910
写一个循环
So for event.

219
00:16:46,140 --> 00:16:48,000

And mask events.

220
00:16:49,380 --> 00:16:50,940
Mask是我们不关心的东西
Mask is the thing we don't care about.

221
00:16:50,941 --> 00:16:51,750
它的值是2
its too.

222
00:16:51,751 --> 00:16:53,970
它等于常量EVENT_WRITE的值
It's equal to EVENT_WRITE

223
00:16:53,971 --> 00:16:55,890
但是这个事件
but this event here.

224
00:16:59,610 --> 00:17:04,820
它的数据字段是我们之前注册的回调
Its data field is the callback that we originally registered

225
00:17:04,840 --> 00:17:06,390
所以我要叫它cb
so I'm going to call that cb,

226
00:17:06,391 --> 00:17:08,040
然后调用它
and then I'm just going to call it.

227
00:17:09,600 --> 00:17:14,760
现在运行程序,看看会发生什么 这样就可以进入函数内部(F7)
So if I run this now instead of breakpoint here and see what happens so it can step in.

228
00:17:15,690 --> 00:17:18,360
你会发现我们进入这个lambda表达式
And you'll see that we step into this lambda here.

229
00:17:18,361 --> 00:17:26,910
而lambda调用connected函数，这个函数的参数有socket和request
And the lambda calls connected and connected is executed with the socket and the request,

230
00:17:26,911 --> 00:17:27,870
request的值是GET /foo
which is get foo

231
00:17:29,460 --> 00:17:30,990
我们运行这个
So we run this.

232
00:17:33,300 --> 00:17:38,700
我们需要在这里做同样的转换
We'll see that we need to do the same transformation down here for s.recv.

233
00:17:40,650 --> 00:17:41,700
我们来修改一下
So let's do that.

234
00:17:44,040 --> 00:17:45,270
我们可以说
And we can say.

235
00:17:48,750 --> 00:17:49,710
回调
The callback.

236
00:17:51,120 --> 00:17:52,440
因为当socket是可读时
For when the socket is readable,

237
00:17:52,440 --> 00:17:54,180
将函数命名为readable
we're going to call it readable

238
00:17:54,340 --> 00:18:07,020
和connected函数需要接收参数的方式是一样的
and the same way that connected needed to take the variables that had been available in the previous callback as arguments so does readable

239
00:18:07,360 --> 00:18:09,330
在这个函数中仍然需要socket参数
in this case still needs the socket.

240
00:18:09,331 --> 00:18:11,340
它不需要请求 我们已经完成了
It doesn't need request we're done with that,

241
00:18:11,341 --> 00:18:13,350
但它确实需要一个分块的列表
but it does need the list of chunks.

242
00:18:14,790 --> 00:18:19,050
所以它会把这两个作为参数
So it's going to take those two as arguments,

243
00:18:19,051 --> 00:18:21,930
当它被执行时
and when it's executed,

244
00:18:21,931 --> 00:18:25,500
它知道s在这个时候是可读的
it knows that s is readable by this time.

245
00:18:26,580 --> 00:18:31,710
所以它可以注销它的文件描述符并接收一个分块
So we can unregister its file descriptor and receive a truck.

246
00:18:31,711 --> 00:18:33,150
我们知道这个分块
And we know that a chunk.

247
00:18:34,110 --> 00:18:34,740
嗯
Well,

248
00:18:34,741 --> 00:18:39,720
我们知道这不会引发异常 因为select调用
we know that this won't raise an exception because the select call.

249
00:18:40,710 --> 00:18:45,870
在这里确保了我们在这个socket上等待的事件都准备好了
Down here said that whatever we're waiting for on this socket is ready.

250
00:18:46,800 --> 00:18:53,250
所以这里不会出现资源不可用或其他异常
So we won't throw a resource unavailable or whatever that exception was.

251
00:18:54,330 --> 00:18:58,710
数据块要么包含一些内容 或者服务器已经关闭
The chunk will either contain something or if the server has closed,

252
00:18:58,711 --> 00:19:00,420
那么这个分块就是空的
the connection then chunk is empty.

253
00:19:00,421 --> 00:19:01,410
我们知道我们已经传完数据了
And we know that we're done.

254
00:19:03,840 --> 00:19:06,150
在这里
So up here,

255
00:19:06,151 --> 00:19:08,220
这意味着我们不调用select
that means that we don't call select,

256
00:19:08,221 --> 00:19:12,300
因为这是事件循环的工作
because that's the eventloop's job,

257
00:19:12,301 --> 00:19:15,150
但我们确实需要创建回调
but we do need to create the callback.

258
00:19:16,020 --> 00:19:20,539
它和我们之前创建的回调非常相似
So it's going to be very similar to the callback that we created before

259
00:19:20,539 --> 00:19:24,240
还是一个由lambda表达式创建的闭包
it's going to be a closure expressed by lambda,

260
00:19:24,241 --> 00:19:25,650
当我们执行它的时候
and when we execute it.

261
00:19:27,030 --> 00:19:29,730
我们要传入socket和chunks变量
We're going to pass it the socket and the chunks,

262
00:19:29,731 --> 00:19:31,890
这不再是一个循环
and this is no longer a loop.

263
00:19:31,891 --> 00:19:32,940
我们只是注册
We just register.

264
00:19:35,970 --> 00:19:37,890
回调一次 然后我们就做完了
The callback once and then we're done.

265
00:19:40,050 --> 00:19:41,340
这意味着
And that means that,

266
00:19:41,340 --> 00:19:43,960
既然我们没有死循环了
since we no longer have a while true loop

267
00:19:44,180 --> 00:19:47,640
如果在这里我们有分块
that down here, if we have a chunk,

268
00:19:47,641 --> 00:19:51,600
我们需要等待剩下的部分
we need to wait for the remaining chunks,

269
00:19:51,601 --> 00:19:52,950
所以我们不能就这样离开这里
so we can't just leave here.

270
00:19:52,951 --> 00:19:53,730
我们还要做些工作
We need to go.

271
00:19:55,800 --> 00:19:59,190
给Callback赋值另一个闭包
Callback equals yet another closure,

272
00:19:59,190 --> 00:20:06,980
这将引起对readable函数的二次调用
and that's going to cause a second call or an *another call to this readable function again

273
00:20:07,120 --> 00:20:13,582
我们要在这里重新注册刚才注销的socket
and we'll register that again with a selector to re-register the socket that we unregistered up here

274
00:20:13,582 --> 00:20:16,590
这里的return就没有必要了
and then this return calls no longer necessary.

275
00:20:18,120 --> 00:20:19,440
如果我们运行这个
So if we run this.

276
00:20:21,150 --> 00:20:22,020
我们会看到的
We'll see that.

277
00:20:23,700 --> 00:20:26,220
我们的两个请求现在都完成了
Both of our requests now complete.

278
00:20:26,221 --> 00:20:27,540
这是坠吼的
So that's fantastic,

279
00:20:27,541 --> 00:20:29,070
但不幸的是
but unfortunately.

280
00:20:30,120 --> 00:20:36,870
我们看不到她的最终输出 因为我们在这个死循环里
We don't see her final output because we're in this while true loop,

281
00:20:36,871 --> 00:20:42,060
所以我们被阻塞在这个selector上，因为没有什么可以做的了
so were blocked here on this selector because there's nothing left to do,

282
00:20:42,061 --> 00:20:44,430
但是我们还没有让循环完成
but we haven't told the loop to complete,

283
00:20:44,431 --> 00:20:46,440
如果我们点击这里的停止
and if we hit stop here,

284
00:20:46,441 --> 00:20:47,160
我们会看到的
we'll see that.

285
00:20:49,020 --> 00:20:50,910
我们卡在这行语句上了
This line is, in fact,where we're stuck.

286
00:20:53,040 --> 00:21:02,280
所以我认为结束这个循环的正确方法是 搞清楚任务何时完成，然后退出循环
So I think that the right way to complete this loop now is to somehow figure out when all work is complete and then exit the loop.

287
00:21:02,281 --> 00:21:06,540
所以我设置了任务数这个变量
So I'm going to say that there is some number of tasks.

288
00:21:07,470 --> 00:21:10,500
这个变量贯穿整个执行过程
*That are always in flight.

289
00:21:12,540 --> 00:21:13,890
刚开始时
To begin with,

290
00:21:13,891 --> 00:21:14,850
没有任务在执行
there are none.

291
00:21:16,140 --> 00:21:17,970
一旦我们调用get函数
And whenever we call get.

292
00:21:24,450 --> 00:21:29,970
就会增加任务数
It'll Increment the number of tasks.

293
00:21:30,990 --> 00:21:37,770
当我们读完服务器的响应时
And when we have finished reading a response from a server.

294
00:21:40,290 --> 00:21:45,150
就可以把任务数减1了
Then it's time to decrement it.

295
00:21:47,250 --> 00:21:52,220
所以当我们调用get foo的时候把任务数增加到1
So when we call get foo that increments the tasks to one

296
00:21:52,240 --> 00:21:56,010
当调用get bar 时，任务数又加1
and when we call get bar, that increments it too,

297
00:21:56,011 --> 00:21:56,550
然后
and then,

298
00:21:56,551 --> 00:22:00,420
当回调链都结束时
as each of the chains of callbacks runs to completion,

299
00:22:00,421 --> 00:22:02,010
就将任务数减1
it decrements n_tasks.

300
00:22:02,011 --> 00:22:08,910
直到这个事件循环的n_tasks为零时退出
until this event loop sees that n tasks is zero and quits

301
00:22:10,500 --> 00:22:12,150
如果我们运行这个
If we run this,

302
00:22:12,151 --> 00:22:22,080
然后我们会看到这两个请求都完成了 奇迹般地只花了一秒而不是两秒
then we'll see that both of the requests complete and miraculously it's only taken one second, not two.

303
00:22:22,081 --> 00:22:24,300
我们可以做到
and we can do.

304
00:22:26,040 --> 00:22:26,400
哦
Oops.

305
00:22:29,580 --> 00:22:35,940
更多的并发请求 还是只需要一秒
Many more of these concurrent requests and it will still only take one second.

306
00:22:36,870 --> 00:22:40,680
这样做的原因是服务器太慢了
And the reason for that is that the server is so slow

307
00:22:40,740 --> 00:22:48,360
与从服务器上等待下一个分段的时间相比
that this client is not spending significant CPU processing each of the responses

308
00:22:48,560 --> 00:22:53,070
（本地）客户端不用消耗大量的CPU资源去处理每一个响应
compared to how long its spending waiting for the next chunk from the server.

309
00:22:53,070 --> 00:22:57,920
服务器需要整整1秒才能返回几百字节的数据
The server takes a full second to return just a few hundred bytes of data

310
00:22:58,380 --> 00:23:03,540
而客户端所做的只是将这些数据块插入到一个列表中
and all the client is doing is appending those chunks to a list.

311
00:23:03,540 --> 00:23:07,360
因此 客户端几乎没有CPU开销
So the client is spending almost no CPU

312
00:23:07,440 --> 00:23:13,440
而在绝大多数时间内都是在等待I/O
with spending overwhelmingly the majority of its time waiting for i/o.

313
00:23:13,891 --> 00:23:18,660
这就是异步优化的应用场景
So,this is the sort of thing that async is optimized for.

314
00:23:18,660 --> 00:23:26,500
我们可以用一个简单的框架来做几十个甚至上百个并发的请求
We can do probably dozens or even hundreds of simultaneous requests with a simple framework like this one.

315
00:23:26,780 --> 00:23:33,750
而不用在运算上损失大量的时间
and not lose significant amounts of time on computation,

316
00:23:33,751 --> 00:23:39,660
它非常高效 因为它不需要保持空闲线程就可以达到同样的效果
and it's very efficient because it doesn't have to hold open idle threads In order to do that.

317
00:23:41,760 --> 00:23:43,140
这很好
So that's great.

318
00:23:43,141 --> 00:23:44,190
它非常高效
It's very efficient,

319
00:23:44,191 --> 00:23:52,230
但你也会发现 与简单的初始get函数相比，现在就是一团乱麻
but you'll also see that it's kind of a mess compared to a very simple initial implementation of Get,

320
00:23:52,231 --> 00:23:55,530
我们现在写了一堆乱七八糟的东西
we've now created a whole bunch of mess.

321
00:23:55,531 --> 00:23:57,480
我们现在需要三个函数
We now need three functions where

322
00:23:57,481 --> 00:23:58,830
原来只需要一个
before we only had one.

323
00:24:00,030 --> 00:24:01,440
这三个函数
These three functions.

324
00:24:02,760 --> 00:24:07,740
关于它们的特别之处在于 每当一个函数退出时
What's particularly about about them is that each time a function exits,

325
00:24:07,741 --> 00:24:17,100
它失去了所有的局部变量，例如s、request和chunks
it loses all of its local variables *right so s and request and chunks

326
00:24:17,500 --> 00:24:26,280
当一个回调函数完成时，需要将下一个回调注册到调用链中
each time one of these callbacks completes and registers the next callback in the chain to be executed.

327
00:24:26,281 --> 00:24:34,080
它必须手动将它的状态复制到一个闭包中 这样就可以在调用链的下一个回调中使用这个状态
It has to manually copy its state into a closure so that that state is available to the next call back in the chain.

328
00:24:35,280 --> 00:24:44,460
语言提供给我们的基础设施，比如堆栈和局部变量
The normal facilities that the language provides to us in a stack and in local variables,

329
00:24:44,461 --> 00:24:48,690
在我们的异步框架中，必须手动重新创建它们
we have to manually recreate that stuff in our async framework.

330
00:24:48,691 --> 00:24:56,850
在维持I/O状态时，语言特性对我们来说基本上没有帮助
The language is basically no help to us here in terms of maintaining state across IO operations.

331
00:24:58,410 --> 00:25:01,680
所以问题的解决方案来到了下一个阶段
So the solution to this is the next phase.

332
00:25:01,681 --> 00:25:03,270
协程
It's coroutines.

333
00:25:04,440 --> 00:25:08,820
协程建立在Future类上
And coroutines are built on Future.

334
00:25:10,410 --> 00:25:15,030
这是我们稍后在介绍python生成器时看到的类
Which is a class that we'll see in a second on python generators.

335
00:25:16,710 --> 00:25:20,070
我们稍后将会看到另一个叫做Task的类
And on another class that we'll see in a moment called Task.

336
00:25:21,240 --> 00:25:24,570
现在很多协程的概念
Now there are a bunch of kinds of things called coroutines.

337
00:25:24,571 --> 00:25:26,670
协程这个概念其实很早就有了
coroutines are very old idea.

338
00:25:26,671 --> 00:25:31,540
协程在不同的语言中有不同的实现
There are many kinds of implementations of coroutines in many languages

339
00:25:32,812 --> 00:25:36,120
在Python3的asyncio中
in Python3 asyncio

340
00:25:36,121 --> 00:25:38,100
当我们说协程的时候
what we mean when we say coroutines is,

341
00:25:39,900 --> 00:25:43,680
指的是基于生成器的协程
Generator based coroutines.

342
00:25:45,840 --> 00:25:49,350
Greenlet在Python3.5中也被称作协程
Greenlet are also called coroutines in Python3.5.

343
00:25:49,351 --> 00:25:56,850
现在有了新的原生协程 可以利用新的async和await关键字
There are now new things called native coroutines that can take advantage of the new async and await keywords.

344
00:25:56,851 --> 00:26:00,480
它们本质上是基于生成器的语法糖
They're essentially syntactic sugar on top of generators.

345
00:26:00,481 --> 00:26:04,200
所以如果你理解了我们之后讨论的内容
So if you understand the discussion they were going to have right now,

346
00:26:04,201 --> 00:26:09,630
就能同时了解Python3.5中原生协程的工作方式
you'll understand how the Python3.5 native coroutines work as well,

347
00:26:09,631 --> 00:26:13,530
尽管它们是内置在解释器里而不是直接用生成器写的
although they're built into the interpreter rather than built out of generators,

348
00:26:13,531 --> 00:26:14,550
这是我们现在要做的（用生成器实现）
the way we're going to do right now.

349
00:26:16,830 --> 00:26:17,250
所以
So.

350
00:26:18,720 --> 00:26:21,930
我们首先需要的是一个future类
The first thing that we need is a future class.

351
00:26:22,830 --> 00:26:25,590
稍后，你们会明白为什么它很有用
And you'll see why in a little bit this is useful

352
00:26:25,591 --> 00:26:29,760
我先把它写出来
but for the moment I'm just going to present it,

353
00:26:29,761 --> 00:26:34,350
你现在只需要相信这将会是一个有用的东西
and you'll just have to trust me that this is going to be a useful thing,

354
00:26:34,351 --> 00:26:41,160
future类代表着一些我们正在等待但尚未完成的事件
so a future represents some pending event that we're were waiting for.

355
00:26:42,240 --> 00:26:48,900
它有一个事件发生时将要被执行的回调列表
It has a list of callbacks that will be executed when that event occurs,

356
00:26:48,901 --> 00:26:53,880
当事件发生时，会调用resolve函数，
and when that event occurs, somebody's going to call resolve and the future will.

357
00:26:57,960 --> 00:27:02,160
future类会执行所有等待该事件的回调
Execute all of the callbacks that were waiting for that event.

358
00:27:02,161 --> 00:27:03,480
这就是我们的future类
So that's our future class.

359
00:27:04,650 --> 00:27:12,360
我们要简单地修改代码，而不是直接用selector来注册和回调
And we're going to do this simple transformation where instead of register and callbacks directly with the selector,

360
00:27:12,361 --> 00:27:14,100
我们要注册futures类
we're going to register futures instead.

361
00:27:24,630 --> 00:27:29,190
所以我们将回调添加到future的回调列表中
So we add the callback to the list of callbacks.

362
00:27:29,191 --> 00:27:33,330
等待这个future来执行回调 而不是直接注册回调
waiting for this future to be resolved and instead of registering the callback directly.

363
00:27:34,290 --> 00:27:35,790
我们注册future
We register the future instead.

364
00:27:37,560 --> 00:27:42,210
这里也做相同操作
And I have to do the same thing here.

365
00:27:45,480 --> 00:27:46,500
最后
And finally,

366
00:27:46,501 --> 00:27:51,030
我们必须再做一次麻烦的重构
we have to do that same laborious transformation.

367
00:27:54,691 --> 00:27:57,060
在我们注册回调的三个地方
in the three places where we had registered callbacks,

368
00:27:57,061 --> 00:28:00,720
我们现在给futures加入回调，并对futures进行了注册
we're now adding callbacks to futures and registering the future instead.

369
00:28:02,010 --> 00:28:05,280
这意味着在我们的事件循环中
And that means that down here in our event loop.

370
00:28:06,540 --> 00:28:11,520
data不再是回调，而是future对象
The event that data is no longer a callback its future,

371
00:28:11,521 --> 00:28:12,990
所以我们不直接调用它
and so we don't call it directly.

372
00:28:12,991 --> 00:28:15,330
而是调用它的resolve方法
Instead,we say future.resolve.

373
00:28:16,620 --> 00:28:19,140
所以你可以预测一下
So, you can expect,

374
00:28:19,141 --> 00:28:22,620
进行简单的修改之后，很可能得到正确的结果
with such a simple transformation that had probably got it right,

375
00:28:22,621 --> 00:28:26,130
看上去我做到了
and it looks like I did so.

376
00:28:26,131 --> 00:28:31,440
到目前为止，我们所做的一切都把代码变的又杂乱又冗长
All we've done so far is made our code even worse,  even more messy and long,

377
00:28:31,441 --> 00:28:35,340
程序的性能和之前的一样
and we have simply got the same performance that we had before.

378
00:28:36,570 --> 00:28:44,640
所以下一步就是用future类和生成器来实现协程
So the next step is going to be to somehow use these futures with generators to start to implement coroutines.

379
00:28:46,980 --> 00:28:51,980
所以我要快速复习一下生成器
So I'm going to do a quick little refresher about Generators.

380
00:28:52,100 --> 00:28:55,620
生成器有一些难以理解的特性
cause there's a few confusing things about them.

381
00:28:55,621 --> 00:28:59,070
即使对经验丰富的python程序员来说也是如此
Even for veteran python programs.

382
00:29:00,510 --> 00:29:05,320
生成器是用生成器函数创建的
So a generator is created with a generator function

383
00:29:05,563 --> 00:29:12,870
生成器函数是任何包含的yield表达式的函数
and a generator function is any function that contains the yield statement.

384
00:29:13,980 --> 00:29:16,890
所以这个生成器函数将会打印start和1
So this generator function is going to print start yield one.

385
00:29:18,660 --> 00:29:19,200
Middle
Middle.

386
00:29:20,580 --> 00:29:21,060
还有2
Two.

387
00:29:23,370 --> 00:29:24,060
最后打印done
And then it's done.

388
00:29:25,920 --> 00:29:31,530
生成器函数的有趣之处在于 当你执行它时
And the funny thing about a generator function is that when you execute it,

389
00:29:31,531 --> 00:29:32,940
它实际上并没有运行它的代码
it doesn't actually run its code.

390
00:29:33,990 --> 00:29:36,120
它没有打印start middle或done
It didn't print start middle or done

391
00:29:36,320 --> 00:29:40,720
而是创建了一个生成器对象
Instead,it created a generator object

392
00:29:41,200 --> 00:29:50,520
这个生成器对象包含一个代码对象,即用来表示这些内容的字节码（co_code）
and this generator object contains a code object *that's the byte code that represents this stuff.

393
00:29:51,450 --> 00:29:52,080
然后
And?

394
00:29:53,130 --> 00:29:59,481
它有44个字节
It's got forty four bytes

395
00:29:59,481 --> 00:30:02,820
生成器自身也有一个栈帧
and the generator also has a stack frame.

396
00:30:03,930 --> 00:30:05,610
它有一个指令指针
And that's got an instruction pointer,

397
00:30:05,611 --> 00:30:07,890
初始值为-1
and it begins his negative one,

398
00:30:07,891 --> 00:30:11,700
也就是说它还没有执行任何指令
meaning that it hasn't executed any instructions yet.

399
00:30:12,690 --> 00:30:16,530
这就是为什么我们没有看到这些print语句的输出
And that's why we didn't actually see any of these prints statements is being executed.

400
00:30:17,850 --> 00:30:22,470
运行一个生成器的方法是对它调用next函数
So the way to run a generator is to call him next on it.

401
00:30:23,730 --> 00:30:25,320
如果你这样做
And if you do that,

402
00:30:25,321 --> 00:30:30,720
然后你会看到它执行了最初的一些字节码
then you'll see that it executes its first few bites of byte code,

403
00:30:30,720 --> 00:30:32,520
所以它打印start
so it prints start

404
00:30:32,680 --> 00:30:36,780
1 实际上是next语句的返回值
and one is actually the return value of the next statement

405
00:30:36,920 --> 00:30:42,360
因为next()的返回值由next执行的yield语句决定
because the return value of next is whichever yield is next executed.

406
00:30:43,350 --> 00:30:50,340
现在 指令指针暂停在第13个字节处
And the instruction pointer is now paused at thirteen bites into the forty four bytes of bytecode.

407
00:30:51,510 --> 00:30:54,222
所以如果我们再次调用next
So if we call next again

408
00:30:54,222 --> 00:31:00,960
我要保存它的返回值 这样你就能看到它打印出middle
this time,I'm going to assign its return value so that you can see that a prints middle.

409
00:31:02,640 --> 00:31:05,640
但它返回2
But it returns two.

410
00:31:06,600 --> 00:31:11,550
这是下一个yield语句传递出的值
Which was the value passed into the next yield statement.

411
00:31:12,900 --> 00:31:17,040
现在我们的堆栈指针(口误)
And now our stack pointer....

412
00:31:17,041 --> 00:31:17,400
对不起
Sorry,

413
00:31:17,401 --> 00:31:20,340
我们的指示指针来到第28字节
our instruction pointer is at twenty eight of forty four.

414
00:31:21,570 --> 00:31:24,840
如果我们再次调用next
And if we call next one more time.

415
00:31:25,830 --> 00:31:28,950
然后我们将看到停止迭代异常
Then we'll raise stop iteration exception,

416
00:31:28,951 --> 00:31:30,150
这说明
which indicates that

417
00:31:31,050 --> 00:31:38,640
它已经完成了 lasti指针已经被删除了
It's done executing and the lasti pointer has actually been deleted.

418
00:31:40,380 --> 00:31:46,740
这就是生成器如何在Python2.5及之前版本的中工作的
So that's how a generator works in all versions of Python going back two point five.

419
00:31:49,020 --> 00:31:52,530
那么我们如何用它来实现协程呢
So how do we use that to create a coroutine?

420
00:31:54,600 --> 00:31:55,020
嗯
Well,

421
00:31:55,021 --> 00:31:56,250
先做一个设想
here's the promise.

422
00:31:57,810 --> 00:31:59,670
我们的想法是这样的
The promise is going to be that.

423
00:32:00,870 --> 00:32:02,790
这个get函数
This get function.

424
00:32:04,950 --> 00:32:10,260
需要创建一个闭包 以捕获他的局部变量
Which currently has to create a closure that captures his local variables.

425
00:32:12,030 --> 00:32:13,920
将其命名为callback
Names that closure callback.

426
00:32:14,940 --> 00:32:20,580
向future增加回调 然后注册future到selector
adds that callback to the future and then registers that future with the selector.

427
00:32:21,930 --> 00:32:25,380
这个回调完全可以简化
This can be simplified to not require a call back at all.

428
00:32:26,940 --> 00:32:29,640
所以我要删除回调
So I'm going to delete the callback.

429
00:32:29,641 --> 00:32:31,710
删除回调主体
I'm going to delete the callbacks body.

430
00:32:34,020 --> 00:32:39,080
但我们需要暂停直至socket可写
But we need to pause until s is writable

431
00:32:39,200 --> 00:32:47,400
在我们注销它之前，这里是可写的。当socket可写时，就可以调用send
somehow here before we unregistered it and then rely on the socket to be writable so that we can call send on it

432
00:32:47,760 --> 00:32:51,870
我们的想法是
and the promise is that somehow,

433
00:32:51,871 --> 00:32:53,490
通过yield f
by yielding F,

434
00:32:53,491 --> 00:32:54,960
这个我们刚刚创建的future对象
the future that we just created.

435
00:32:56,490 --> 00:33:05,010
我们可以用某种方式暂停这个生成器 直到我们感兴趣的事件发生
Somehow we can pause this generator until the event that we said we were interested in has occurred.

436
00:33:07,950 --> 00:33:11,610
如果我们认为这个设想可行
And if we believe that this promise is true.

437
00:33:12,630 --> 00:33:20,850
然后 我们可以将两个函数合并成包含yield语句的单一生成器函数
Then we can combine what had been two functions into a single generator function that contains a yield statement.

438
00:33:22,740 --> 00:33:28,740
但这个设想还没有实现,因为如果我运行这个
But the promise is not going to be fulfilled just yet because if I run this,

439
00:33:28,741 --> 00:33:30,210
它将花费0秒
it's going to take zero seconds.

440
00:33:30,211 --> 00:33:31,710
它没有输出
It has no output,

441
00:33:31,711 --> 00:33:33,030
没有实现想要的效果
and it doesn't do any work.

442
00:33:34,800 --> 00:33:35,820
为什么呢
So why is that?

443
00:33:35,821 --> 00:33:36,660
这里发生了什么
What happened here?

444
00:33:38,640 --> 00:33:39,210
嗯
Well,

445
00:33:39,211 --> 00:33:42,030
回想一下 当你执行一个生成器函数时
recall that when you execute a generator function,

446
00:33:42,031 --> 00:33:46,500
它会返回生成器，实际上并不运行它的任何代码
it returns a generator doesn't actually run any of its code.

447
00:33:46,501 --> 00:33:49,920
现在我在这里添加了一个yield语句
So now that I've added a yield statement here to get,

448
00:33:49,921 --> 00:33:51,810
这意味着这里的get语句
that means that get here.

449
00:33:54,360 --> 00:33:55,830
只返回了一个生成器
Just returns a generator.

450
00:33:57,660 --> 00:33:59,670
实际上什么都没做
doesn't actually do anything,

451
00:33:59,671 --> 00:34:00,570
这里也是一样
and the same here.

452
00:34:01,800 --> 00:34:09,090
那么我们要怎么执行它呢
So how are we going to execute it?

453
00:34:09,091 --> 00:34:10,650
如何对它执行next方法呢
How do we call next on it?

454
00:34:12,660 --> 00:34:22,140
这就是这个基于协程的异步框架的第三个部分：Task类
So that is the third piece of this puzzle of this coroutine based async framework is the task class.

455
00:34:23,370 --> 00:34:24,480
Task类
Task class.

456
00:34:26,250 --> 00:34:31,200
它负责在生成器上调用next
It's responsible for calling next on generators.

457
00:34:32,340 --> 00:34:34,980
我们来看看它是什么样的
So let's see what that looks like.

458
00:34:34,981 --> 00:34:37,230
同时使用future和task类时
And in the case of both future and task,

459
00:34:37,231 --> 00:34:45,150
现在写的这些内容非常简单，或者说过于简单了，而且实现并不完善
these are incredibly simple and oversimplified and buggy incomplete implementations of these ideas.

460
00:34:45,151 --> 00:34:48,990
不过这些想法在许多框架中得到了充分体现
These ideas are fully expressed in a number of frameworks,

461
00:34:48,991 --> 00:35:00,210
尤其是tornado和python3.4标准库中的asyncio
notably tornado and now in asyncio in the python3.4 standard library.

462
00:35:01,590 --> 00:35:08,100
所以我的丐版Task类的实现如下：
So my dumb version of the task class is going to look like.

463
00:35:09,540 --> 00:35:12,900
我们将用生成器初始化它
We're going to initialize it with a generator.

464
00:35:14,610 --> 00:35:15,600
我将保存它
I will save that.

465
00:35:17,280 --> 00:35:20,790
然后我们会有一个叫做Step的函数
And then we'll have a function called Step,

466
00:35:20,791 --> 00:35:24,360
这个术语是从asyncio那里借来的
and this terminology is borrowed from a asyncio.

467
00:35:24,361 --> 00:35:28,320
step函数的任务就是在生成器上调用next
What step does his calls next on the generator.

468
00:35:30,180 --> 00:35:35,100
生成器将会yield一个future对象
And since the generator,
it's going to yield a future.

469
00:35:36,870 --> 00:35:40,770
这就变成了next()的返回值
So that's going to become the return value of next.

470
00:35:40,771 --> 00:35:43,710
我们来捕获它
So let's capture that.

471
00:35:46,020 --> 00:35:46,680
然后
And then.

472
00:35:48,330 --> 00:35:51,000
当这个future执行完回调时 我们想要达成什么目的？
What do we want to happen when this future is resolved?

473
00:35:51,930 --> 00:35:56,790
我们需要给future增加一些回调
We need to add some kind of callback to the future,

474
00:35:56,790 --> 00:35:59,820
这是我们想要在future就绪时执行的动作
something that we want to happen once the future is ready

475
00:35:59,960 --> 00:36:07,470
让我们把self.step作为回调
and let's just pass self dot step in as the callback.

476
00:36:07,471 --> 00:36:09,900
所以一旦这个future完成之后
So once this future is resolved,

477
00:36:09,901 --> 00:36:13,470
就会回到这里 然后再次对self.gen执行next
we'll just come right back into here and we'll call next and self.gen again.

478
00:36:15,000 --> 00:36:18,330
当再次对self.gen执行next时
when we call next on self.gen again,

479
00:36:18,331 --> 00:36:20,760
程序这将在这里恢复执行
that's going to resume here.

480
00:36:24,420 --> 00:36:28,650
因此我们知道我们可以注销socket文件号
And therefore we know that we can unregister the sockets file number,

481
00:36:28,651 --> 00:36:30,000
现在socket是可写的
and that s is now writable.

482
00:36:31,350 --> 00:36:35,520
所以如果我们运行它 它仍然不会起作用
So if we run this still not going to work.

483
00:36:37,110 --> 00:36:38,730
原因是
The reason for that is.

484
00:36:41,160 --> 00:36:45,060
我们需要对self.step做一个初始的调用
That we need to make an initial call the self.step,

485
00:36:45,061 --> 00:36:54,090
我们给self.gen做了一个初始的调用(预激)这样我们就启动了get函数
so that we make an initial call to self.gen so that we get the get function started,

486
00:36:54,091 --> 00:36:55,950
它会连接socket 等等
and it will connect the socket and so on.

487
00:36:55,951 --> 00:36:58,830
我们在这里改一下
So let's just do that right here.

488
00:36:58,831 --> 00:36:59,640
在构造函数中
In the constructor.

489
00:37:02,490 --> 00:37:09,870
然后是这个修改的最后一步，下面这里
And then the final step of this conversion is going to be down here,

490
00:37:09,871 --> 00:37:14,900
我们需要用task把这些get调用包起来
where we need to wrap each of these calls in a task

491
00:37:15,000 --> 00:37:18,150
当get返回一个生成器时，task对象会把它包起来
so when get returns a generator, the task wraps it

492
00:37:19,740 --> 00:37:23,840
保存到self.gen中，然后调用self.step
Signs it to self.gen and calls self.step

493
00:37:23,920 --> 00:37:34,500
之后就会调用next，真正地执行代码直至第一个yield语句
and that will call next and that will actually begin this thing executing up until the first yield statement

494
00:37:34,501 --> 00:37:35,700
如果我运行这个
So if I run this.

495
00:37:38,340 --> 00:37:39,120
在某种程度上
In a way,

496
00:37:39,121 --> 00:37:41,190
你会看到我们已经有些进步了
you will see the way we make progress.

497
00:37:42,150 --> 00:37:45,570
因为我们在这里抛出了一个停止迭代异常
Because we raise a stop iteration exception here.

498
00:37:47,190 --> 00:37:49,380
所以这确实是个好消息
So that that actually that's good news,

499
00:37:49,381 --> 00:37:55,800
因为这意味着这个get生成器实际上已经运行到结束了
because it means that this get generator has actually been run to completion.

500
00:37:55,801 --> 00:37:59,700
它完成了它所要做的工作
It's done the work that it set out to do.

501
00:37:59,701 --> 00:38:01,410
所以
so.

502
00:38:01,411 --> 00:38:02,370
如果我们
if we.

503
00:38:04,080 --> 00:38:04,980
catch一下异常
Catch that.

504
00:38:05,940 --> 00:38:07,140
我们想在这里做什么
What do we want to do here?

505
00:38:07,141 --> 00:38:07,470
嗯
Well,

506
00:38:07,471 --> 00:38:08,430
task完成了
the task is done.

507
00:38:08,431 --> 00:38:10,110
直接返回
So let's just return.

508
00:38:11,340 --> 00:38:12,930
如果我们执行这个版本
And if we execute this version.

509
00:38:14,370 --> 00:38:15,540
实际上已经成功了
It actually completes.

510
00:38:16,530 --> 00:38:22,800
吼啊 我们还有一些零散的回调
So this is fantastic now we've still got a few stray callbacks.

511
00:38:23,670 --> 00:38:24,630
所以
So.

512
00:38:25,620 --> 00:38:28,980
我们可以删去这些，在这里做同样的修改
We can get rid of those the same transformation that we did here.

513
00:38:30,330 --> 00:38:32,430
所以在这里做同样的操作
So we're just going to do it down here again as well,

514
00:38:32,431 --> 00:38:33,330
所以我们要
so we're going to.

515
00:38:33,331 --> 00:38:34,950
我们再也不需要这个调用了
We don't need this call back any more.

516
00:38:35,940 --> 00:38:37,500
你不需要把它加到future中
You don't need to add it to the future.

517
00:38:38,460 --> 00:38:46,680
我们仍然需要说明我们关注的事件，并注册future对象
We do still need to say what event we're interested in and register the future to be resolved when that event occurs,

518
00:38:46,681 --> 00:38:50,010
但是我们可以删除回调定义
but we can delete the callback definition.

519
00:38:51,060 --> 00:38:55,710
因为我们在之前的同一个函数中
Since we're still in the same function as we were in before,

520
00:38:55,711 --> 00:38:59,010
我们不需要一个冗余的全局声明
we don't need a redundant global statement.

521
00:39:00,270 --> 00:39:06,480
如果我们简单地yield我们新定义的future
And if we simply yield this new future that we created,

522
00:39:06,481 --> 00:39:07,440
这意味着
that means that.

523
00:39:08,760 --> 00:39:09,420
到目前为止
By now,

524
00:39:09,421 --> 00:39:13,710
当task恢复的时候
by the time the task resolve.. resumes us,

525
00:39:13,711 --> 00:39:14,880
这个socket现在是可读的
the socket is now readable.

526
00:39:17,970 --> 00:39:21,570
这是最后一个回调
And here we've got our last of the callback.

527
00:39:21,571 --> 00:39:22,800
我们可以把它删掉
so we can delete that.

528
00:39:24,000 --> 00:39:29,460
我们可以yield我们的future 而不是注册一个回调
And we can yield our future instead of registering a callback.

529
00:39:36,720 --> 00:39:42,180
当我们收到下一个分块时 我们要做什么
What do we want to do once we have received the next chunk?

530
00:39:42,181 --> 00:39:42,780
换句话说
In other words,

531
00:39:42,781 --> 00:39:45,390
当socket再次处于可读状态
once the socket is readable again?

532
00:39:46,681 --> 00:39:50,460
我们想要得到下一个分块，对吧？
we want to receive the next chunk right？

533
00:39:50,460 --> 00:39:54,120
所以我们最后要做的是
so what we're going to end up doing is

534
00:39:54,240 --> 00:40:05,130
借鉴在教程刚开始的时候写的死循环
we're going to end up reproducing the same while true loop that we originally had in the olden days at the beginning of this talk,

535
00:40:05,131 --> 00:40:08,100
那时我们只写了一个简单的阻塞get函数
when we were writing a simple blocking get.

536
00:40:09,060 --> 00:40:10,830
所以它看起来是这样的
So that's going to look something like.

537
00:40:14,070 --> 00:40:18,180
我们要把这个放在循环中
We're going to put this within the loop.

538
00:40:19,650 --> 00:40:22,680
每次执行循环时
And each time through the loop we say,

539
00:40:22,681 --> 00:40:25,890
我想从socket上读取数据
I want to read from the socket,

540
00:40:25,891 --> 00:40:28,140
所以等待这个future执行完毕
so wait for this future to be resolved.

541
00:40:29,130 --> 00:40:32,370
然后从selector中注销socket
And then unregistered the socket from the selector.

542
00:40:32,371 --> 00:40:33,120
得到当前的分块
get the chunk.

543
00:40:34,050 --> 00:40:40,860
如果有分块，那就加入到列表中 这个部分是多余的
And if there is any then added to the list and this stuff is now extra.

544
00:40:42,690 --> 00:40:46,110
这个循环会重复 在这里重复做这些
The loop will just repeat and do that stuff again up here,

545
00:40:46,111 --> 00:40:47,520
如果没有分块
and if there's no chunk.

546
00:40:47,521 --> 00:40:48,420
这意味着
That means that.

547
00:40:50,070 --> 00:40:51,960
我们已经接收完服务器响应
We're done reading the server response,

548
00:40:51,961 --> 00:40:53,640
所以我们可以
and so we can.

549
00:40:55,260 --> 00:40:56,460
连接各个分块
Join the body up,

550
00:40:56,461 --> 00:40:59,850
打印第一行 减去任务数
print the first line decrement the tasks count,

551
00:40:59,851 --> 00:41:02,940
从现在开始 我们又回到了一个无限循环
and since now we're in an infinite loop again.

552
00:41:02,941 --> 00:41:05,370
在这里 我们需要立即返回
here we need to return as soon as we're done.

553
00:41:07,740 --> 00:41:08,160
现在
Now,

554
00:41:08,161 --> 00:41:10,290
如果一切顺利 我运行这个
if all goes well and I run this,

555
00:41:10,291 --> 00:41:14,340
它仍然只花了一秒
then it still takes one second.

556
00:41:14,341 --> 00:41:19,440
它还是做了所有的工作
it still does all the work that it was asked to do

557
00:41:19,800 --> 00:41:26,250
我们可以把它扩展到能够执行大量的任务而不损失任何性能
and we can still scale this out to a large number of tasks without any loss of performance,

558
00:41:26,251 --> 00:41:32,160
因为发起10个或15个协程的资源消耗实在是太低廉了
because launching ten fifteen coroutines is incredibly cheap,

559
00:41:32,161 --> 00:41:36,360
大概只和一堆回调差不多
it's roughly as cheap as a bunch of callbacks.

560
00:41:37,440 --> 00:41:40,520
所以协程差不多是几种办法中最好的
So coroutines are kind of the best of both *worlds.

561
00:41:40,660 --> 00:41:44,980
资源消耗和回调一样少，比线程更是不知道少到哪里去了
they're about as cheap as callbacks they're much cheaper than threads

562
00:41:45,240 --> 00:41:50,580
我在我的系统上测量了一个协程..
on my system, I measured that a coroutine takes...

563
00:41:51,540 --> 00:41:57,150
大约需要6K的内存，而线程需要30K
About six K of memory versus about thirty K of memory for a thread,

564
00:41:57,151 --> 00:42:04,740
此外 我做了一个小实验：我有可以启动超过十万个协程
and furthermore I did a little experiment and found that I was capable of launching over a hundred thousand coroutines.

565
00:42:04,741 --> 00:42:12,030
它们的限制仅仅是Python进程允许分配的内存总量
Their limited only by the amount of ram that the Python process is allowed to allocate.

566
00:42:12,930 --> 00:42:14,100
对比线程
versus Threads,

567
00:42:14,101 --> 00:42:18,030
除了简单的内存限制之外 线程还受到其他限制
which are subject to other limits beside simply memory limits.

568
00:42:18,031 --> 00:42:24,630
各种用户和操作系统限制了一个进程被允许启动线程数量
There are various user and operating system limits on the number of threads that a *process is allowed to start with.

569
00:42:24,631 --> 00:42:29,670
这个问题在很多情况下都很难解决
which are difficult in various ways to work around,

570
00:42:29,670 --> 00:42:34,900
线程占用空间和操作系统的数据结构，以及操作系统调度器
and they take up space and operating system data structures and the operating system scheduler

571
00:42:35,020 --> 00:42:39,180
最终导致它们的开销变得非常大
that eventually causes their overhead to become quite significant.

572
00:42:40,350 --> 00:42:49,240
他们所做的一切只是在等待一些缓慢的I/O操作。这实际上不需要非常多的CPU资源
All they're doing is waiting around for some sort of slow IO operations that aren't actually going to require very much CPU。

573
00:42:49,300 --> 00:42:55,020
相较于协程在这个程序中的应用
so compared to coroutines for a application like this,

574
00:42:55,020 --> 00:42:59,380
这将花费很少的时间用于CPU计算
that's going to spend very little time doing computation

575
00:42:59,540 --> 00:43:08,010
并且绝大多数时间都花在等待一个缓慢的服务器或者 客户端的缓慢socket上
and overwhelmingly spending its time waiting for a slow server or a slow client at the other end of the socket.

576
00:43:08,011 --> 00:43:11,580
在这种情况下协程有效率的多
Coroutines are much more efficient for this kind of thing,

577
00:43:11,581 --> 00:43:16,290
但是和回调相比 它们的简单得多 因为
but compared to call backs their lot simpler because.

578
00:43:17,460 --> 00:43:23,250
你可以把协程的所有的代码放在一个函数里
You can put all of the code for a coroutine in one function,

579
00:43:23,251 --> 00:43:29,250
所以你不需要声明并注册整个调用链
so you don't have to declare and register a whole chain of callbacks.

580
00:43:29,251 --> 00:43:34,170
你可以重复使用你的局部变量 就像你原来的习惯
And you can just reuse your local variables the same way that  you have always done.

581
00:43:36,270 --> 00:43:47,130
这就是Tornado或asyncio风格，这些基于协程的异步框架的开端。
So that's the beginning of Tornado style or async i/o style coroutine based async framework.

582
00:43:50,130 --> 00:43:52,710
如果你想了解更多
So if you want to know more about this,

583
00:43:52,710 --> 00:43:57,840
访问bit.ly/coroutines 我创建了一个页面
go to bit.ly/coroutines so I've have created a landing page for you there

584
00:43:57,980 --> 00:44:03,090
你可以在那里看到我刚才写的代码
that'll link you out to a version of the code that I wrote just now,

585
00:44:03,090 --> 00:44:07,740
那里也可以看到我和Guido(Python之父)合写的一章
as well as link you to a chapter that I wrote with Guido van Rossum

586
00:44:07,780 --> 00:44:12,840
这章将会出现在开源应用程序架构系列的下一本书中
that will appear in the next book in the architecture of Open source Application series.

587
00:44:12,841 --> 00:44:25,500
这一章深入地介绍了在Python3.4的标准库中，基于生成器的协程的实现细节
and that chapter goes into far more detail about how generator based coroutines are implemented in asyncio on Python3.4 standard library,

588
00:44:25,501 --> 00:44:36,820
特别是它详细描述协程如何利用基于python3的生成器特性
and especially it goes into how coroutines take advantage of generator features that are specific to python3

589
00:44:37,380 --> 00:44:43,560
以及asyncio库中如何运用异步队列类
and how a asynchronous queue class that's included in asyncio,

590
00:44:43,561 --> 00:44:52,350
以一种惯用线程的工作者非常熟悉的方式来使用协程
can be used to coordinate coroutines in a way that's very familiar to people who are used to using threads.

591
00:44:53,580 --> 00:44:55,530
提醒一下
And as a reminder,

592
00:44:55,531 --> 00:45:00,210
如果你想和我这样的人在一家开源公司工作
if you want to work with people like me at a opensource company,

593
00:45:00,211 --> 00:45:05,400
非常热情、多元、充实以及有技术挑战的工作
that's very warm and diversity has really fulfilling and technically challenging jobs.

594
00:45:05,401 --> 00:45:07,080
Mongodb正在招聘
Mongo db is hiring.

595
00:45:07,081 --> 00:45:11,070
我们在纽约的帕罗奥多和世界各地都设有办事处
We have offices in New York in Palo Alto and worldwide.

596
00:45:11,071 --> 00:45:14,160
访问bit.ly/mongo-jobs
Go to bit.ly/mongo-jobs.

597
00:45:14,161 --> 00:45:15,090
我将很荣幸与你共事
I would love to work with you.

