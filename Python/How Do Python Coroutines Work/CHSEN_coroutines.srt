1
00:00:04,380 --> 00:00:08,130
大家好，我是A. Jesse Jiryu Davis
Hi, I'm A. Jesse Jiryu Davis

2
00:00:08,131 --> 00:00:12,660
我将解释Python协程是如何工作的
and I'm going to tell you how Python coroutines work.

3
00:00:14,520 --> 00:00:15,540
介绍一下我自己
Little about me,

4
00:00:15,541 --> 00:00:25,980
我是MongoDB的一名高级工程师，职责是为MongoDB写Python和C的驱动。
I work for a MongoDB,I'm a staff engineer, there work on the Python and the C drivers for MongoDB.

5
00:00:25,981 --> 00:00:32,100
是的,我们正在招聘。我强烈推荐来MongoDB工作
Yes, we are hiring and I highly recommend working for MongoDB.

6
00:00:32,101 --> 00:00:40,440
访问Mongo-jobs（https://www.mongodb.com/careers）了解所有的工作机会
You can go to Mongo-jobs to see all of the jobs that we've got open.

7
00:00:41,400 --> 00:00:44,580
如果你想了解更多关于这个视频的信息
And if you want more information about this talk,

8
00:00:44,581 --> 00:00:49,710
我在bit.ly/coroutines中新增了一个页面
I've set up a landing pages at bit.ly/coroutines

9
00:00:49,711 --> 00:00:56,370
你可以在链接里找到本视频的代码
You can find links there to the code that I'm going to write right now,

10
00:00:56,370 --> 00:01:05,640
同时，在即将发布的《开源应用程序架构》书中
and also to a chapter in the upcoming architecture of open source applications book

11
00:01:05,940 --> 00:01:16,050
我和Guido(Python创始人)合著了一章，其中深入地阐述了python协程工作的细节
that I co-wrote with Guido Van Rossum that goes into far more depth and is a very detailed exposition of python coroutines work.

12
00:01:17,160 --> 00:01:22,830
这个演示的主题是
So the agenda for this demo is going to be a

13
00:01:26,550 --> 00:01:29,880
基于回调的异步框架
callback-based async framework,

14
00:01:29,881 --> 00:01:35,400
写完之后，我们会看到它非常有效，但也有些混乱
and once we've written that we're going to see that it's very efficient but also kind of a mess,

15
00:01:35,401 --> 00:01:42,540
所以我们最后要把它改写成一个基于协程的框架
and so we're going to adapt that to a coroutine based framework instead.

16
00:01:44,220 --> 00:01:48,720
因此 从一个基于回调的异步框架入手
So to begin with a callback based async framework,

17
00:01:48,721 --> 00:01:51,990
它使用非阻塞套接字
It uses non-blocking sockets.

18
00:01:52,980 --> 00:01:54,810
使用回调函数
uses the callbacks,

19
00:01:54,811 --> 00:01:55,560
当然
of course,

20
00:01:55,561 --> 00:01:58,980
它还使用一个事件循环
and it also uses an event loop.

21
00:02:00,420 --> 00:02:02,850
至于协程
And as for coroutines,

22
00:02:02,851 --> 00:02:05,460
到时候再说吧
well, we'll cross that bridge when we come to it.

23
00:02:06,510 --> 00:02:09,000
编码之前有一些准备工作
So a little bit of setup,

24
00:02:09,001 --> 00:02:14,490
我写了一个简单的web服务器(Github代码中的server.py)
I've written a simple web server and.

25
00:02:18,750 --> 00:02:21,060
它可以响应http请求
It can respond to an HTTP request.

26
00:02:22,440 --> 00:02:27,510
我为本地的python会议"PyGotham"写了这篇文章
I wrote this for a local python conference PyGotham 2015,

27
00:02:27,511 --> 00:02:32,730
所以你可以看到它向所有那些了不起的人们致意
so you can see that it says hello to all of the incredible people there.

28
00:02:32,731 --> 00:02:37,020
这个框架的另一个有趣之处是它有些迟缓
And the other interesting thing about this framework is its kind of slow.

29
00:02:38,520 --> 00:02:42,300
这个web服务器返回非常简单的响应
This web server returns very simple response,

30
00:02:42,301 --> 00:02:47,610
但我增加了一些代码 所以服务器要花差不多一秒钟的时间响应
but I've coded it so that it takes almost a second to reply.

31
00:02:47,611 --> 00:02:50,550
*这非常重要
And so that's going to end up being very important,

32
00:02:50,551 --> 00:02:54,390
因为这是最适合用异步优化的场景：
because that's the sort of thing that async is optimized for.

33
00:02:54,391 --> 00:03:00,450
与速度太慢的服务器或者客户端有效率地通信
Is for talking too slow servers or slow clients efficiently.

34
00:03:02,490 --> 00:03:04,380
让我们看看
So let's see,

35
00:03:04,381 --> 00:03:11,280
我们怎样才能以典型的python方式获取URL
how would we fetch a URL in the kind of typical python way.

36
00:03:14,610 --> 00:03:19,620
所以我们先导入socket
so we would need to import socket right?

37
00:03:21,240 --> 00:03:22,350
然后
And?

38
00:03:30,660 --> 00:03:34,110
绑定到合适的域名和端口
Connected to the proper domain and port.

39
00:03:35,640 --> 00:03:36,900
格式化一个请求
we format a request

40
00:03:48,870 --> 00:03:50,580
把它发送到服务器
then we would send it to the server.

41
00:03:51,750 --> 00:03:54,270
我用的python3环境
And I'm going to do this in Python 3

42
00:03:54,271 --> 00:03:59,820
所以对那些通过网络传输的所有内容进行编码是很重要的
and so it's important to encode everything that we're going to send over the wire.

43
00:03:59,821 --> 00:04:00,000
哦
Oh,

44
00:04:00,001 --> 00:04:02,130
另一个需要记住的重要的事情是
and the other important thing to remember is that.

45
00:04:04,590 --> 00:04:12,750
每个HTTP请求头部以两个回车换行符分隔
Each HTTP requests end in a double carriage return to a new line

46
00:04:12,751 --> 00:04:19,350
所以一旦我们发送了请求就会收到响应 它会以分块的形式返回给我们
so once we've sent the request were going to receive the response and that'll come back to us in chunks.

47
00:04:19,351 --> 00:04:23,310
所以我们要把它们收集到一个列表中
so we're just going to collect those in a list.

48
00:04:28,650 --> 00:04:30,810
收集最多1000个分块(口胡)
Receive them up to a thousand chunks

49
00:04:30,811 --> 00:04:33,210
一次接收1000字节
a thousand bytes at a time,

50
00:04:33,211 --> 00:04:35,400
只要我们接收完一个分块
and as long as we've got a chunk.

51
00:04:39,450 --> 00:04:44,070
就将它加到列表中，如果我们得到一个空的块
will append it to the list and if we get an empty chunk,

52
00:04:44,071 --> 00:04:46,320
我们就知道服务器把我们挂起了
then we know that the server is hung up on us.

53
00:04:46,321 --> 00:04:49,860
所以数据就接收完毕了
so our reception is complete,

54
00:04:49,861 --> 00:04:52,920
所以消息体(body)将会是
and so the body is going to be....

55
00:04:56,160 --> 00:04:59,640
我们将用空字节类型来连接所有的块
We'll use the empty bye to join all the chunks.

56
00:05:00,750 --> 00:05:03,900
然后我们会解码
And then we'll decode that.

57
00:05:05,820 --> 00:05:07,290
默认是utf-8
The utf-8 by default.

58
00:05:08,490 --> 00:05:17,280
然后我们把消息体的第一行打印出来
And then let's just prints the first line of the body.

59
00:05:19,980 --> 00:05:21,480
所以
So,

60
00:05:21,481 --> 00:05:23,130
因为我们在死循环中
and since we're in an infinite loop,

61
00:05:23,131 --> 00:05:24,270
我们需要返回
we need to return,

62
00:05:24,270 --> 00:05:29,260
这就是我们的get函数。如果我们get参数/foo 
so that's our get function and if we get that path Foo

63
00:05:29,540 --> 00:05:39,450
运行程序,可以看到响应的第一行是http 200 OK
and if I run this, you'll see that the first line of the response is an http 200 OK.

64
00:05:40,980 --> 00:05:41,580
然后
And?

65
00:05:42,480 --> 00:05:43,560
让我们看看
Let's also see.

66
00:05:45,180 --> 00:05:46,320
整个过程的运行时间
How long that took

67
00:06:00,600 --> 00:06:04,380
这需要大约一秒钟的时间 因为还有Python解释器的一点开销
So it takes about a second because there's a little bit of overhead in the Python interpreter.

68
00:06:05,490 --> 00:06:11,070
这种方法的问题是 如果我们想要访问两个url
the problem with this approach is that if we want to get 2 Urls,

69
00:06:11,071 --> 00:06:15,420
就需要两秒钟 因为我们是串行地获取URL
it's going to take two seconds because we get them serially.

70
00:06:17,070 --> 00:06:24,630
典型方法是在两个线程上启动这两个get操作
And the typical approach to this might be to launch these two operations on two threads,

71
00:06:24,631 --> 00:06:31,230
但如果我们等待数百个缓慢的请求，效率可能会变得非常低
but that might become inefficient if we're waiting for hundreds of slow requests,

72
00:06:31,231 --> 00:06:34,770
因为我们不得不为这些请求创建数百个线程
and we have to spawn hundreds of threads for them.

73
00:06:34,771 --> 00:06:36,960
有很多的开销是不必要的
There's a lot of overhead though it's not necessary,

74
00:06:36,961 --> 00:06:41,400
所以我们将尝试写一个异步的框架来代替它
so we're going to try out making an async framework to do it instead,

75
00:06:41,401 --> 00:06:49,050
这样我们就不需要为了执行数百次缓慢的I/O请求而创建数百个线程了
so that we don't have to spawn hundreds of threads in order to do hundreds of slow i/o operations,

76
00:06:49,051 --> 00:06:51,360
我们想要比这更有效率的办法
we want to be more efficient than that.

77
00:06:51,361 --> 00:06:51,930
所以
So.

78
00:06:53,070 --> 00:07:00,750
异步框架可以使用非阻塞套接字，python中实现非阻塞的基本框架非常简单
A async framework could uses non-blocking sockets and in python making socket non blocking is very simple.

79
00:07:01,770 --> 00:07:04,800
如果我们运行程序，将会发生什么
Now what's going to happen if we run this?

80
00:07:05,880 --> 00:07:07,950
我们会得到一个异常，因为
We're going to get an exception because.

81
00:07:09,540 --> 00:07:15,390
一个非阻塞套接字的意思是任何会阻塞的操作
A non blocking socket what that means is any operation that would block,

82
00:07:15,391 --> 00:07:22,080
就像连接操作，要么立即成功 要么抛出异常
like connecting,either succeeds immediately or raises an exception.

83
00:07:22,081 --> 00:07:22,350
对
Right.

84
00:07:22,351 --> 00:07:23,790
它是不允许阻塞的
It's not allowed to block.

85
00:07:23,791 --> 00:07:27,030
不允许一直等待直到程序成功完成操作
it's not allowed to wait for success.

86
00:07:28,050 --> 00:07:34,140
所以我们需要一些方法来等待它完成
So we need some way to wait for that to complete.

87
00:07:35,490 --> 00:07:37,410
我们用Python来做这个
And the way we do that in Python.

88
00:07:38,550 --> 00:07:39,090
嗯
Well,

89
00:07:39,091 --> 00:07:39,630
首先
first of all,

90
00:07:39,631 --> 00:07:47,370
我们可以先忽略这个错误
we can just ignore that error.

91
00:07:48,510 --> 00:08:00,000
但这不会让我们走得太远因为一旦我们试着发送套接字的东西就会说它还没有连接起来因为当我们调用connect时
But that's not going to get us very far because as soon as we tried to send something of the socket is going to say that it's not connected yet right because when we called connect,

92
00:08:00,001 --> 00:08:02,790
这个旋钮开始了操作
the knob blocking socket began the operation.

93
00:08:02,791 --> 00:08:05,130
但它并没有等待平均完成
But it didn't wait for the average to complete.

94
00:08:05,131 --> 00:08:06,900
所以我们还没有准备好发送它
And so we're not ready to send it yet.

95
00:08:07,860 --> 00:08:12,870
那么我们怎么知道什么时候我们准备好发送一个操作呢
So how do we know when we're ready to send an operation?

96
00:08:14,220 --> 00:08:15,450
嗯
Well,

97
00:08:15,451 --> 00:08:16,620
python3
python three.

98
00:08:19,050 --> 00:08:21,570
有一个叫做选择器的方便模块
There's this handy module called selectors.

99
00:08:22,590 --> 00:08:23,160
然后呢
And?

100
00:08:24,360 --> 00:08:28,350
在每一个操作系统中
In every operating system since time immemorial,

101
00:08:28,351 --> 00:08:34,440
有一些方法可以在非阻塞套接字上等待某些事件
there has been some way to wait for some event on a non blocking socket.

102
00:08:34,441 --> 00:08:35,100
最初
Originally,

103
00:08:35,101 --> 00:08:37,860
有系统调用select
there was the system calls select,

104
00:08:37,861 --> 00:08:39,060
随着时间的推移
and then over time,

105
00:08:39,061 --> 00:08:43,260
越来越多的可伸缩版本的select已经被发明出来了
more and more scalable versions of select have been invented.

106
00:08:43,261 --> 00:08:46,080
就像在Linux上的投票一样
Like poll on Linux,

107
00:08:46,081 --> 00:08:50,460
他在windows上对Bsd和MacK队列进行了投票
he poll on Bsd and Mac K queue on windows.

108
00:08:50,461 --> 00:08:52,860
有这些Ios完成端口
There is these Ios completion ports.

109
00:08:54,210 --> 00:08:56,400
Python三点四的优点是
The nice thing about Python three point four.

110
00:08:57,990 --> 00:09:03,390
你可以问它一个默认选择器
Is that you can just ask it for a default selector,

111
00:09:03,391 --> 00:09:07,200
它会计算出你的跑步和给你什么
and it will figure out what your running and give you.

112
00:09:08,280 --> 00:09:10,890
最有效的选择器
The most efficient selector.

113
00:09:12,300 --> 00:09:14,160
对于你的平台
For your platform,

114
00:09:14,161 --> 00:09:16,620
所以我们要做一个这样的
so we'll make one of those and.

115
00:09:18,120 --> 00:09:21,000
在我们试着在插座上发送任何东西之前
Before we try to send anything on the socket.

116
00:09:22,170 --> 00:09:24,840
我们将等待它是可读的
We're going to wait for it to be readable.

117
00:09:24,841 --> 00:09:28,380
我们会等着它准备好要讲的东西
We're going to wait for it to be ready for something to be said,

118
00:09:28,381 --> 00:09:30,300
为了做到这一点
so to do that,

119
00:09:30,301 --> 00:09:34,230
我们注册了套接字文件号
we register the sockets file number,

120
00:09:34,231 --> 00:09:36,810
它只是一个整数
which is just an integer.

121
00:09:36,811 --> 00:09:38,820
它只是一个文件描述符
it's just a file descriptor.

122
00:09:38,821 --> 00:09:48,780
我们是否会告诉被选中的人这是一个他们感兴趣的文件号以及我们感兴趣的特定事件
Are we going to tell the selected that this is a file number they were interested in events on and the specific event that we're interested in.

123
00:09:48,781 --> 00:09:53,430
我们想知道什么时候插座是可写的和爱国的吗
Is we want to know when the socket is writable and patriotic?

124
00:09:53,431 --> 00:09:57,840
可以自动为我们导入那个常数吗
Can auto import that constant for us and?

125
00:09:59,340 --> 00:10:06,480
我们要做的下一件事是 到目前为止我们所做的一切都表明我对这个文件描述符感兴趣
The next thing we do so all we have done so far said I'm interested in this event on this file descriptor.

126
00:10:06,481 --> 00:10:13,080
然后 如果我们调用select 它会等待我们要求的事件发生
And then if we call select that will wait for some event that we've asked about to happen.

127
00:10:14,130 --> 00:10:15,120
所以
So,

128
00:10:15,121 --> 00:10:16,620
一旦这种情况发生
once that happens,

129
00:10:16,621 --> 00:10:20,160
我们可以不登记文件号码
we can unregistered the file number.

130
00:10:21,510 --> 00:10:22,830
在这一点上
And by this point.

131
00:10:24,990 --> 00:10:25,860
s是合理的
s is reasonable.

132
00:10:27,930 --> 00:10:31,560
这意味着我们可以合法地调用发送
So that means that we can legally now call send on it.

133
00:10:31,561 --> 00:10:33,000
如果我现在调用这个
So if I call this now.

134
00:10:35,070 --> 00:10:38,040
你会看到我越过这条线
You'll see that I get past this line,

135
00:10:38,041 --> 00:10:45,090
但是现在我们在这里抛出一个异常因为这个套接字是可写的
but now we're throwing an exception down here because the socket is writable,

136
00:10:45,091 --> 00:10:52,170
但是它还没有变得可读 我们还没有等待服务器开始发送它的响应
but it hasn't become readable yet We haven't waited for the server to start sending its response.

137
00:10:53,490 --> 00:10:55,140
所以为了等待
So in order to wait for that,

138
00:10:55,141 --> 00:10:59,550
我们必须再做一次同样的舞蹈
we have to do the same dance again,

139
00:10:59,551 --> 00:11:01,830
这一次我们对权利不感兴趣
and this time we're not interested in right.

140
00:11:01,831 --> 00:11:04,320
能力对可读性很感兴趣
Ability were interested in readability.

141
00:11:04,321 --> 00:11:08,580
所以我们有两条石油格言的输入
So we have two Petro motto inputs that we.

142
00:11:10,170 --> 00:11:12,030
再等一遍
Wait for it again,

143
00:11:12,031 --> 00:11:15,960
一旦这个调用完成
and once this call completes,

144
00:11:15,961 --> 00:11:17,610
那我们就没有登记了
then we'll unregistered.

145
00:11:18,930 --> 00:11:20,370
文件号
The file number,

146
00:11:20,371 --> 00:11:25,170
现在我们可以接收到如果我运行这段代码 它就完成了
and now we're allowed to receive so if I run this code now it completes,

147
00:11:25,171 --> 00:11:29,640
但我们还没有真正想要的东西还花了两秒钟
but we haven't really want anything right still took two seconds.

148
00:11:29,641 --> 00:11:33,060
我们只是把代码弄得一团糟
We just kind of made a small mess in our code.

149
00:11:33,061 --> 00:11:37,590
但我们还没有获得任何效率提升
But we haven't gained any efficiency improvements yet.

150
00:11:43,200 --> 00:11:44,640
那么下一步是什么呢
So what's the next step?

151
00:11:46,410 --> 00:11:47,910
我们之后的下一步
The next step after we've.

152
00:11:48,930 --> 00:11:51,990
开始使用非阻塞套接字
Started to use non blocking sockets,

153
00:11:51,991 --> 00:11:53,490
是回叫
is callbacks.

154
00:11:55,080 --> 00:11:56,520
我将解释它是如何工作的
So I'll explain how that works.

155
00:11:57,600 --> 00:12:07,410
回调是一种允许多个操作同时等待眼睛操作的方法
Callbacks are a way of allowing multiple operations to here waiting concurrently for eye operations.

156
00:12:11,760 --> 00:12:12,540
首先
To begin with,

157
00:12:12,541 --> 00:12:13,350
这是
this get.

158
00:12:14,370 --> 00:12:16,530
当它开始连接时
When it starts connecting,

159
00:12:16,531 --> 00:12:17,730
它需要
it needs to.

160
00:12:19,110 --> 00:12:23,610
一旦套接字可写 注册回调将被执行
Register callback to be executed once the socket is writable,

161
00:12:23,611 --> 00:12:33,930
然后它需要返回 这样工作就可以开始得到另一个欧元当我们在等待连接这个插座的时候
and then it needs to return so that work can begin on getting the other euro while we're waiting to connect this socket right,

162
00:12:33,931 --> 00:12:38,460
为了通过这两秒钟 我们需要某种类型的并发性
we need some sort of concurrency in order to get past this two seconds.

163
00:12:39,870 --> 00:12:41,190
我们来看看它是如何工作的
So let's see how that would work.

164
00:12:42,510 --> 00:12:46,260
我们可以先写回那个调用的主体
We can begin by writing the body of that call back,

165
00:12:46,261 --> 00:12:47,820
所以我把它叫做连接
so I'm gonna call it connected.

166
00:12:47,821 --> 00:12:49,080
这将会执行
This is going to execute.

167
00:12:50,190 --> 00:12:54,810
一旦套接字连接起来 它就会执行下一步
Once the socket is connected and it's going to do the next step.

168
00:12:55,980 --> 00:12:56,340
屁股
Butt.

169
00:12:57,840 --> 00:12:58,410
问题是
The problem is,

170
00:12:58,411 --> 00:13:01,410
你可以看到 写得很高的魅力正在失去它的思想
you can see that written up high charm is sort of losing its mind,

171
00:13:01,411 --> 00:13:10,950
因为在这个新函数中有两个变量没有被绑定因为我们在这里创建了它们
because there's two variables that are not bound in this new function because we created them up here in.

172
00:13:12,330 --> 00:13:17,400
这两个变量是s和request
And the two variables are s and request.

173
00:13:17,401 --> 00:13:21,360
假设这些都是通过某种方式传递的
So let's say that those are passed into connected somehow.

174
00:13:23,340 --> 00:13:27,240
这将会是
And that somehow is going to be.

175
00:13:27,241 --> 00:13:33,330
我们将使用一个登陆器来创建一个闭包来捕获这两个值
We're going to use a lander to create a closure to capture those two values.

176
00:13:33,331 --> 00:13:35,160
所以我们要创建一个Lambda
so we'll create a Lambda.

177
00:13:36,300 --> 00:13:43,440
我们会说 调用Lambda执行与套接字和请求连接
And we'll say that calling the Lambda executes connected with the socket and the request,

178
00:13:43,441 --> 00:13:46,440
我们把这个叫做诽谤回调
and we'll call this slander callback.

179
00:13:48,210 --> 00:13:50,520
现在我们怎么处理这个回叫
Now what do we do with this callback?

180
00:13:50,521 --> 00:13:54,060
选择器国防部寄存器
Well selector Dod register,

181
00:13:54,061 --> 00:13:55,350
它有这个特别的
it has this special.

182
00:13:56,490 --> 00:13:57,120
隐藏
Hidden.

183
00:13:58,860 --> 00:14:00,870
而不是B
Argument instead of a B side,

184
00:14:00,871 --> 00:14:03,210
它被称为数据
and it's called data,

185
00:14:03,211 --> 00:14:05,940
所以我们要把它传递给调用者
so we're going to pass to the called again.

186
00:14:05,941 --> 00:14:08,160
他的数据 因为这是Python
his data because this is Python,

187
00:14:08,161 --> 00:14:08,820
魁北克
the Quebec.

188
00:14:09,750 --> 00:14:15,120
数据可以是任何东西 所以我们要把亚特兰大作为数据
The data can be anything so we're going to pass in Atlanta as the data.

189
00:14:17,370 --> 00:14:17,940
然后呢
And?

190
00:14:19,950 --> 00:14:24,510
我们要等到连接被调用 实际上没有注册那个电话号码
We're going to wait until connected is called to actually unregistered that phone number.

191
00:14:24,511 --> 00:14:25,470
现在
Now,

192
00:14:25,471 --> 00:14:26,970
如果我们这样做
if we do this.

193
00:14:30,450 --> 00:14:32,130
不幸的是
Unfortunately,

194
00:14:32,131 --> 00:14:33,720
我们实际上并没有完成任何工作
we don't actually get any work done.

195
00:14:34,860 --> 00:14:36,840
因为我们的回调从来没有真正执行过
Because our callback is never actually executed.

196
00:14:37,830 --> 00:14:48,930
那么我们如何确保这个回调实际上是在它等待的事件被执行的时候运行呢
So how do we make sure that this callback is actually run once the event that it's waiting for has been executed?

197
00:14:48,931 --> 00:14:53,250
好吧 我们需要的是各种同步框架的第三部分
Well for that we need the third part of various sync framework.

198
00:14:53,251 --> 00:14:54,570
我们需要一个活动
We need an event.

199
00:14:56,550 --> 00:14:58,170
简单地把它切下来
Simply to cut that down here.

200
00:15:00,450 --> 00:15:05,130
Kit将首先运行它会启动一个套接字连接
Kit is going to run first and it's going to start a socket connecting,

201
00:15:05,131 --> 00:15:10,230
然后它会注册一个回调 当套接字是可写的时候就会执行
and then it's going to register a callback to be executed when the socket is writable.

202
00:15:10,231 --> 00:15:12,030
一旦食物完成了
and once food has done that,

203
00:15:12,031 --> 00:15:14,160
它回来了 邓巴也做了同样的事情
it returns and Dunbar does the same thing.

204
00:15:14,161 --> 00:15:19,740
现在我们要讲的是 非阻塞的套接字是开放的 在连接的过程中
So now we've got to say non blocking sockets that are open and in the midst of connected,

205
00:15:19,741 --> 00:15:24,450
它们都已经在选择器中注册了
and they've both been registered with the selector.

206
00:15:24,451 --> 00:15:25,710
所以我要跑了
So I'm going to run.

207
00:15:26,700 --> 00:15:27,480
泥土
A dirt,

208
00:15:27,481 --> 00:15:29,550
简单的小事件循环
simple little event loop here,

209
00:15:29,551 --> 00:15:30,750
但它会说
but it's going to say.

210
00:15:31,770 --> 00:15:33,780
选择器点选择
Selector dot select.

211
00:15:35,130 --> 00:15:41,490
现在让我们通过这里的deBugger 看看选择实际返回的是什么
Now let's run this through the de Bugger here and see what select actually returns.

212
00:15:41,491 --> 00:15:44,610
所以我设置了一个断点
So I set a break point,

213
00:15:44,611 --> 00:15:47,820
现在我们有了这个事件列表
and now we've got this events list,

214
00:15:47,821 --> 00:15:49,980
如果我检查一下
and if I inspect that,

215
00:15:49,981 --> 00:15:51,960
你会看到它是一个列表
you'll see that it's a list.

216
00:15:51,961 --> 00:15:53,580
它有两个元素
It's got two elements,

217
00:15:53,581 --> 00:15:56,640
我们来看看第一个元素是什么
and let's see what that first element is.

218
00:15:56,641 --> 00:15:58,260
它有
It's got.

219
00:15:58,261 --> 00:16:00,450
它是一个有两个值的块茎
It's a tuber with two values.

220
00:16:00,451 --> 00:16:02,130
第二个值不是很有趣
A second value isn't very interesting.

221
00:16:02,131 --> 00:16:06,990
这只是我们一开始传递的面具
This is just the mask that we passed in at first,

222
00:16:06,991 --> 00:16:11,040
它等于事件的正确值
and it's equal to the event right value.

223
00:16:11,041 --> 00:16:15,840
但我们已经知道了 因为那是我们唯一感兴趣的事情
but we already knew that because that was the only event that we were interested in.

224
00:16:15,841 --> 00:16:18,960
它是小管的第一个元素
It's this first element of the tubule.

225
00:16:18,961 --> 00:16:22,530
这个选择器关键的东西很有趣
This selector key thing that's really interesting,

226
00:16:22,531 --> 00:16:28,920
当我调用寄存器时 你会看到我传递的数据值
and you'll see that the data value that I passed in when I called register.

227
00:16:28,921 --> 00:16:37,410
我们在这个事件列表中得到了这个结果它的内容是我注册为回调的亚特兰大
We're getting that back out in this events list and its contents is that Atlanta that I registered as the callback so.

228
00:16:38,670 --> 00:16:39,390
让我们
Let's.

229
00:16:40,950 --> 00:16:41,550
执行
Executed?

230
00:16:43,440 --> 00:16:44,910
这是四个事件
So four event.

231
00:16:46,140 --> 00:16:48,000
以及掩模事件
And mask events.

232
00:16:49,380 --> 00:16:50,940
面具是我们不关心的东西
Mask is the thing we don't care about.

233
00:16:50,941 --> 00:16:51,750
它也是
its too.

234
00:16:51,751 --> 00:16:53,970
它等于完全的事件
It's equal to event outright,

235
00:16:53,971 --> 00:16:55,890
但是这个事件
but this event here.

236
00:16:59,610 --> 00:17:03,210
它的数据字段是我们最初的回调
Its data field is the callback that we originally.

237
00:17:04,440 --> 00:17:06,390
注册了 所以我要叫它CV
registered so I'm going to call that CV,

238
00:17:06,391 --> 00:17:08,040
然后我就叫它
and then I'm just going to call it.

239
00:17:09,600 --> 00:17:14,760
所以如果我现在运行这个 而不是一个断点 看看会发生什么 这样它就可以进入
So if I run this now instead a break point here and see what happens so it can step in.

240
00:17:15,690 --> 00:17:18,360
你会发现我们进入了大满贯赛事
And you'll see that we step into the slam to hear it.

241
00:17:18,361 --> 00:17:23,520
而登陆器呼叫连接和连接是用套接字执行的
And the lander calls connected and connected is executed with the socket.

242
00:17:24,540 --> 00:17:26,910
请求
And the request,

243
00:17:26,911 --> 00:17:27,870
哪个是get
which is get?

244
00:17:29,460 --> 00:17:30,990
我们运行这个
So we run this.

245
00:17:33,300 --> 00:17:38,700
我们将会看到 我们需要在这里做同样的转换来获得特别提款权
We'll see that we need to do the same transformation down here for SDR receive.

246
00:17:40,650 --> 00:17:41,700
我们来做一下
So let's do that.

247
00:17:44,040 --> 00:17:45,270
我们可以说
And we can say.

248
00:17:48,750 --> 00:17:49,710
回调
The callback.

249
00:17:51,120 --> 00:17:52,440
因为当套接字是可写的
For when the socket is writable,

250
00:17:52,441 --> 00:17:59,100
我们会称它为可读 和连接需要的方式是一样的
we're going to call it readable and the same way that connected needed to take thee.

251
00:18:00,780 --> 00:18:09,330
在以前的kolbeck中作为参数可用的变量 在本例中是可读的仍然需要套接字
Variables that had been available in the previous kolbeck as arguments so does readable in this case still needs the socket.

252
00:18:09,331 --> 00:18:11,340
它不需要请求 我们已经完成了
It doesn't need request we're done with that,

253
00:18:11,341 --> 00:18:13,350
但它确实需要一个块的列表
but it does need the list of chunks.

254
00:18:14,790 --> 00:18:19,050
所以它会把这两个作为参数
So it's going to take those two as arguments,

255
00:18:19,051 --> 00:18:21,930
当它被执行时
and when it's executed,

256
00:18:21,931 --> 00:18:25,500
它知道s在这个时候是可读的
it knows that s is readable by this time.

257
00:18:26,580 --> 00:18:27,330
所以它可以加
So it can add,

258
00:18:27,331 --> 00:18:31,710
注册它的文件描述符并接收一辆卡车
register its file descriptor and receive a truck.

259
00:18:31,711 --> 00:18:33,150
我们知道这一块
And we know that a chunk.

260
00:18:34,110 --> 00:18:34,740
嗯
Well,

261
00:18:34,741 --> 00:18:39,720
我们知道这不会引发异常 因为select调用
we know that this won't raise an exception because the select call.

262
00:18:40,710 --> 00:18:45,870
下面这里说 我们在这个插座上等待的任何东西都准备好了
Down here said that whatever we're waiting for on this socket is ready.

263
00:18:46,800 --> 00:18:48,570
所以我们不会扔掉
So we won't throw away.

264
00:18:49,680 --> 00:18:53,250
资源不可用或任何异常
Resource unavailable or whatever that exception was.

265
00:18:54,330 --> 00:18:58,710
数据块将包含一些内容 或者服务器已经关闭
The chunk will either contain something or if the server has closed,

266
00:18:58,711 --> 00:19:00,420
与卡车的连接是空的
the connection than truck is empty.

267
00:19:00,421 --> 00:19:01,410
我们知道我们已经做完了
And we know that we're done.

268
00:19:03,840 --> 00:19:06,150
在这里
So up here,

269
00:19:06,151 --> 00:19:08,220
这意味着我们不调用select
that means that we don't call select,

270
00:19:08,221 --> 00:19:12,300
因为这是事件循环的工作
because that's the event loops job,

271
00:19:12,301 --> 00:19:15,150
但我们确实需要创建回调
but we do need to create the callback.

272
00:19:16,020 --> 00:19:20,940
所以它和我们之前创建的回叫非常相似
So it's going to be very similar to the callback that we created before it's gotta.

273
00:19:20,941 --> 00:19:24,240
是亚特兰大的一个封闭的压力
Be a closure stress by Atlanta,

274
00:19:24,241 --> 00:19:25,650
当我们执行它的时候
and when we execute it.

275
00:19:27,030 --> 00:19:29,730
我们要把插座和卡车
We're going to pass it the socket and the trucks,

276
00:19:29,731 --> 00:19:31,890
这不再是一个循环
and this is no longer a loop.

277
00:19:31,891 --> 00:19:32,940
我们只是注册
We just register.

278
00:19:35,970 --> 00:19:37,890
回调一次 然后我们就做完了
The callback once and then we're done.

279
00:19:40,050 --> 00:19:41,340
这意味着
And that means that,

280
00:19:41,341 --> 00:19:42,780
既然我们不再有一段时间了
since we no longer have a while,

281
00:19:42,781 --> 00:19:45,900
真正的循环
true loop that down here,

282
00:19:45,901 --> 00:19:47,640
如果我们有一块
if we have a chunk,

283
00:19:47,641 --> 00:19:51,600
我们需要等待剩下的部分
we need to wait for the remaining chunks,

284
00:19:51,601 --> 00:19:52,950
所以我们不能就这样离开这里
so we can't just leave here.

285
00:19:52,951 --> 00:19:53,730
我们得走了
We need to go.

286
00:19:55,800 --> 00:19:59,190
返回等于另一个闭包
Call back equals yet another closure,

287
00:19:59,191 --> 00:20:16,590
这将会引起第二个调用或者是对这个可读函数的另一个调用它会再次注册一个选择器来重新注册我们在这里注册的套接字然后这个返回调用不再需要
and that's going to cause a second call or an anther call to this readable function again and will register that again with a selector to re registered the socket that we unregistered up here and then this return calls no longer necessary.

288
00:20:18,120 --> 00:20:19,440
如果我们运行这个
So if we run this.

289
00:20:21,150 --> 00:20:22,020
我们会看到的
We'll see that.

290
00:20:23,700 --> 00:20:26,220
我们的两个请求现在都完成了
Both of our requests now complete.

291
00:20:26,221 --> 00:20:27,540
这太棒了
So that's fantastic,

292
00:20:27,541 --> 00:20:29,070
但不幸的是
but unfortunately.

293
00:20:30,120 --> 00:20:36,870
我们看不到她的最终输出 因为我们在这个狂野的树圈里
We don't see her final output because we're in this wild tree loop,

294
00:20:36,871 --> 00:20:42,060
所以在这个选择器上被阻塞了因为没有什么可以做的了
so were blocked here on this selector because there's nothing left to do,

295
00:20:42,061 --> 00:20:44,430
但是我们还没有让循环完成
but we haven't told the loop to complete,

296
00:20:44,431 --> 00:20:46,440
如果我们点击这里
and if we hit stop here,

297
00:20:46,441 --> 00:20:47,160
我们会看到的
we'll see that.

298
00:20:49,020 --> 00:20:49,740
这条线是
This line is,

299
00:20:49,741 --> 00:20:50,220
事实上
in fact,

300
00:20:50,221 --> 00:20:50,910
我们被困住了
where we're stuck.

301
00:20:53,040 --> 00:21:02,280
所以我认为现在完成这个循环的正确方法是找出所有工作完成后 然后退出循环
So I think that the right way to complete this loop now is to somehow figure out when all work is complete and then exit the loop.

302
00:21:02,281 --> 00:21:06,540
所以我要说的是 有一些任务
So I'm going to say that there is some number of tasks.

303
00:21:07,470 --> 00:21:08,310
这是
That are.

304
00:21:09,300 --> 00:21:10,500
总是在飞行中
Always in flight.

305
00:21:12,540 --> 00:21:13,890
首先
To begin with,

306
00:21:13,891 --> 00:21:14,850
没有
there are none.

307
00:21:16,140 --> 00:21:17,970
无论何时我们打电话
And whenever we call yet.

308
00:21:24,450 --> 00:21:24,960
这一切
It all.

309
00:21:28,260 --> 00:21:28,740
增量
Increment,

310
00:21:28,741 --> 00:21:29,970
任务的数量
the number of tasks.

311
00:21:30,990 --> 00:21:37,770
当我们读完服务器的响应时
And when we have finished reading a response from a server.

312
00:21:40,290 --> 00:21:43,110
那么是时候了
Then it's time to.

313
00:21:44,280 --> 00:21:45,150
有文件记录
Documented?

314
00:21:47,250 --> 00:21:54,000
所以当我们叫食物的时候把任务增加到一个 当我们叫被禁止的时候
So when we call get food that increments the tasks to one and when we call get barred,

315
00:21:54,001 --> 00:21:56,010
这也增加了它
that increments it too,

316
00:21:56,011 --> 00:21:56,550
然后
and then,

317
00:21:56,551 --> 00:21:59,520
当回调的每一个链都运行时
as each of the chains of callbacks runs,

318
00:21:59,521 --> 00:22:00,420
完成
to completion,

319
00:22:00,421 --> 00:22:02,010
这是一种伤害和任务
a detriment and tasks.

320
00:22:02,011 --> 00:22:04,590
直到这个事件循环
Until this event loop.

321
00:22:06,660 --> 00:22:07,830
抓住牙医
Seize the dentist,

322
00:22:07,831 --> 00:22:08,910
0和
says Zero and.

323
00:22:10,500 --> 00:22:12,150
如果我们运行这个
If we run this,

324
00:22:12,151 --> 00:22:20,820
然后我们会看到这两个请求都完成了 奇迹般地只花了一秒钟
then we'll see that both of the requests complete and miraculously it's only taken one second,

325
00:22:20,821 --> 00:22:22,080
不太好
not too.

326
00:22:22,081 --> 00:22:24,300
我们可以做到
and we can do.

327
00:22:26,040 --> 00:22:26,400
哦
Oops.

328
00:22:29,580 --> 00:22:35,940
更多的并发请求 它只需要一秒
Many more of these concurrent requests and it will still only take one second.

329
00:22:36,870 --> 00:22:41,700
这样做的原因是服务器太慢了 以至于这个客户端
And the reason for that is that the server is so slow that this client.

330
00:22:42,750 --> 00:22:53,070
与从服务器上等待下一段时间的花费相比 它不会花费大量的CP处理每一个响应
is not spending significant CP processing each of the responses compared to how long its spending waiting for the next chunk from the server.

331
00:22:53,071 --> 00:23:03,540
服务器需要一个完整的秒才能返回几百字节的数据 而客户端所做的就是将这些数据块向上排列到一个列表中
The server takes a full second to return just a few hundred bytes of data and all the client is doing is upending those chunks to a list.

332
00:23:03,541 --> 00:23:10,920
因此 客户花费几乎没有CP的数据绝大多数时间都在支出
So the data that the client is spending almost no CP with spending overwhelmingly the majority of its time.

333
00:23:10,921 --> 00:23:13,890
等着我
waiting for I am so,

334
00:23:13,891 --> 00:23:18,660
这是一个水槽为之优化的东西
this is the sort of thing that a sink is optimized for.

335
00:23:18,661 --> 00:23:28,230
我们可以用一个简单的框架来做几十个甚至上百个并发的请求 而不是这样
We can do probably dozens or even hundreds of simultaneous requests with a simple framework like this one and not.

336
00:23:29,850 --> 00:23:33,750
在计算上损失大量的时间
Lose significant amounts of time on computation,

337
00:23:33,751 --> 00:23:38,610
它非常高效 因为它不需要保持空闲线程
and it's very efficient because it doesn't have to hold open idle threads.

338
00:23:38,611 --> 00:23:39,660
为了做到这一点
In order to do that.

339
00:23:41,760 --> 00:23:43,140
这很好
So that's great.

340
00:23:43,141 --> 00:23:44,190
它非常高效
It's very efficient,

341
00:23:44,191 --> 00:23:52,230
但你也会发现 与简单的初始实现相比 它是一团乱麻
but you'll also see that it's kind of a mess compared to a very simple initial implementation of Get,

342
00:23:52,231 --> 00:23:55,530
我们现在制造了一堆乱七八糟的东西
we've now created a whole bunch of mess.

343
00:23:55,531 --> 00:23:57,480
我们现在需要三个函数
We now need three functions where,

344
00:23:57,481 --> 00:23:58,830
在我们只有一个之前
before we only had one.

345
00:24:00,030 --> 00:24:01,440
这三个函数
These three functions.

346
00:24:02,760 --> 00:24:07,740
关于它们的特别之处在于 每当一个函数退出时
What's particularly about about them is that each time a function exits,

347
00:24:07,741 --> 00:24:13,980
它失去了所有的局部变量s和请求
it loses all of its local variables right so s and request.

348
00:24:15,480 --> 00:24:26,280
每次回调函数中的一个都完成并注册到要执行的链中的下一个调用
and chunks each time one of these callbacks completes and registers the next call back in the chain to be executed.

349
00:24:26,281 --> 00:24:34,080
它必须手动将它的状态复制到一个闭包中 这样就可以在链的下一个调用中使用这个状态
It has to manually copy its state into a closure so that that state is available to the next call back in the chain.

350
00:24:35,280 --> 00:24:44,460
语言在堆栈和局部变量中提供给我们的常规设备
The normal facilities that the language provides to us in a stack and in local variables,

351
00:24:44,461 --> 00:24:47,310
我们必须手动重新创建这些东西
we have to manually recreate that stuff.

352
00:24:47,311 --> 00:24:48,690
在我们的赛车框架中
In our racing framework.

353
00:24:48,691 --> 00:24:56,850
在爱荷华州的运作中 这种语言对我们来说基本上没有帮助
The language is basically no help to us here in terms of maintaining state across Iowa operations.

354
00:24:58,410 --> 00:25:01,680
所以这个问题的解决方案是下一个阶段
So the solution to this is the next phase.

355
00:25:01,681 --> 00:25:03,270
是窗帘
It's curtains.

356
00:25:04,440 --> 00:25:07,230
窗帘是建立在上面的
And curtains are built on.

357
00:25:08,190 --> 00:25:08,820
未来
Future.

358
00:25:10,410 --> 00:25:15,030
这是我们稍后会在python生成器中看到的类
Which is a class that we'll see in a second on python generators.

359
00:25:16,710 --> 00:25:20,070
在另一个课堂上我们将会看到一个叫做任务的课程
And on another class that we'll see in a moment called Task.

360
00:25:21,240 --> 00:25:24,570
现在有一大堆的东西叫做co例程
Now there are a bunch of kinds of things called co routines.

361
00:25:24,571 --> 00:25:26,670
涂料是非常古老的观念
Coatings are very old idea.

362
00:25:26,671 --> 00:25:29,580
勇气的实现有很多种
There are many kinds of implementations of courage.

363
00:25:29,581 --> 00:25:33,390
在很多语言中 在Python里
teens in many languages in Python,

364
00:25:33,391 --> 00:25:35,010
三个在亚齐
three and in Aceh,

365
00:25:35,011 --> 00:25:35,340
安哥拉
Angola.

366
00:25:35,341 --> 00:25:36,120
哦
Oh,

367
00:25:36,121 --> 00:25:38,100
当我们说勇气的时候
what we mean when we say courage,

368
00:25:38,101 --> 00:25:38,970
意思是
means is.

369
00:25:39,900 --> 00:25:41,580
基于发电机的
Generator based.

370
00:25:42,900 --> 00:25:43,680
胡萝卜素
Carotenes.

371
00:25:45,840 --> 00:25:49,350
格陵兰岛也被称为三点五年的常规和影响
Greenland's are also called co routines and impact on three point five.

372
00:25:49,351 --> 00:25:56,850
现在有了新的东西 叫做本地代码例程 可以利用新的饮食和权重关键字
There are now new things called native code routines that can take advantage of the new eating and weight keywords.

373
00:25:56,851 --> 00:26:00,480
它们本质上是在发电机上面的语法糖
They're essentially syntactic sugar on top of generators.

374
00:26:00,481 --> 00:26:04,200
所以如果你理解他们现在将要讨论的内容
So if you understand the discussion they were going to have right now,

375
00:26:04,201 --> 00:26:06,390
您将了解Python的三个要点
you'll understand how the Python three point.

376
00:26:06,391 --> 00:26:09,630
5个本地代码例程也可以工作
five native code routines work as well,

377
00:26:09,631 --> 00:26:13,530
尽管它们是内置在解释器里而不是用发电机制造的
although they're built into the interpreter rather than built out of generators,

378
00:26:13,531 --> 00:26:14,550
这是我们现在要做的
the way we're going to do right now.

379
00:26:16,830 --> 00:26:17,250
所以
So.

380
00:26:18,720 --> 00:26:21,930
我们首先需要的是一个未来的课程
The first thing that we need is a future class.

381
00:26:22,830 --> 00:26:24,780
你们会看到为什么
And you'll see why in a little bit,

382
00:26:24,781 --> 00:26:25,590
这很有用
this is useful,

383
00:26:25,591 --> 00:26:29,760
但是现在我要展示的是
but for the moment I'm just going to presented,

384
00:26:29,761 --> 00:26:34,350
你只需要相信我这将会是一个有用的东西
and you'll just have to trust me that this is going to be a useful thing,

385
00:26:34,351 --> 00:26:40,260
因此 未来代表着一些悬而未决的事件
so a future represents some pending event.

386
00:26:40,261 --> 00:26:41,160
他们在等着
They were waiting for.

387
00:26:42,240 --> 00:26:44,730
它有一个将被执行的回调列表
It has a list of callbacks that will be executed.

388
00:26:46,890 --> 00:26:48,900
当这个事件发生时
When that event occurs,

389
00:26:48,901 --> 00:26:50,070
当这个事件发生时
and when that event occurs,

390
00:26:50,071 --> 00:26:53,880
有人会说决心 未来会
somebody's going to call resolve and the future will.

391
00:26:57,960 --> 00:27:02,160
执行所有等待该事件的回调
Execute all of the callbacks that were waiting for that event.

392
00:27:02,161 --> 00:27:03,480
这就是我们未来的课程
So that's our future class.

393
00:27:04,650 --> 00:27:12,360
我们要做这个简单的变换而不是直接用选择器来注册和回调
And we're going to do this simple transformation where instead of register and callbacks directly with the selector,

394
00:27:12,361 --> 00:27:14,100
我们要注册期货
we're going to register futures instead.

395
00:27:24,630 --> 00:27:29,190
所以我们将回调添加到回调的列表中
So we add the callback to the list of callbacks.

396
00:27:29,191 --> 00:27:33,330
等待这个未来的解决 而不是直接注册回调
waiting for this future to be resolved and instead of registering the callback directly.

397
00:27:34,290 --> 00:27:35,790
我们把未来登记在册
We register the future instead.

398
00:27:37,560 --> 00:27:40,200
我也要做同样的事情
And I have to do the same thing.

399
00:27:41,820 --> 00:27:42,210
这里
Here.

400
00:27:45,480 --> 00:27:46,500
最后
And finally,

401
00:27:46,501 --> 00:27:47,430
我们必须这样做
we have to do.

402
00:27:48,390 --> 00:27:51,030
同样艰辛的转变
That same laborious transformation.

403
00:27:53,250 --> 00:27:54,450
在这里
Here,

404
00:27:54,451 --> 00:27:54,690
所以
so,

405
00:27:54,691 --> 00:27:57,060
在我们注册回调的三个地方
in the three places where we had registered callbacks,

406
00:27:57,061 --> 00:28:00,720
我们现在加入了对期货的回调 并对未来进行了登记
we're now adding callbacks to futures and registering the future instead.

407
00:28:02,010 --> 00:28:05,280
这意味着在我们的事件循环中
And that means that down here in our event loop.

408
00:28:06,540 --> 00:28:11,520
数据不再是对其未来的呼唤
The event that data is no longer a call back its future,

409
00:28:11,521 --> 00:28:12,990
所以我们不直接叫它
and so we don't call it directly.

410
00:28:12,991 --> 00:28:13,470
相反
Instead,

411
00:28:13,471 --> 00:28:15,330
我们说了我们的决心
we say futured our resolve.

412
00:28:16,620 --> 00:28:17,220
所以
So.

413
00:28:18,300 --> 00:28:19,140
你可以期待
You can expect,

414
00:28:19,141 --> 00:28:22,620
有了这样一个简单的转变 很可能是正确的
with such a simple transformation that had probably got it right,

415
00:28:22,621 --> 00:28:26,130
看起来我是这样做的
and it looks like I did so.

416
00:28:26,131 --> 00:28:28,290
到目前为止 我们所做的一切都是为了她的代码
All we've done so far as made her code.

417
00:28:28,291 --> 00:28:29,340
更糟糕的是
even worse,

418
00:28:29,341 --> 00:28:31,440
更加混乱和漫长
even more messy and long,

419
00:28:31,441 --> 00:28:35,340
我们得到的结果和之前的一样
and we have simply got the same performance that we had before.

420
00:28:36,570 --> 00:28:44,640
所以下一步就是用这些期货和发电机来开始实施飓风
So the next step is going to be to somehow use these futures with generators to start to implement hurricanes.

421
00:28:46,980 --> 00:28:49,470
所以我要快速复习一下
So I'm going to do a quick little refresher about.

422
00:28:51,060 --> 00:28:55,620
发电机造成了一些令人困惑的事情
Generators cause there's a few confusing things about them.

423
00:28:55,621 --> 00:28:59,070
即使是经验丰富的python程序
Even for veteran python programs.

424
00:29:00,510 --> 00:29:04,590
生成器是用生成器创建的
So a generator is created with a generator,

425
00:29:04,591 --> 00:29:06,120
函数和生成器
function and a generator.

426
00:29:06,121 --> 00:29:08,610
函数是任何包含的函数
Function is any function that contains.

427
00:29:10,650 --> 00:29:12,870
收益表
The yield statement.

428
00:29:13,980 --> 00:29:15,810
所以这个生成器函数将会打印
So this generator function is going to print,

429
00:29:15,811 --> 00:29:16,890
开始生产1
start yield one.

430
00:29:18,660 --> 00:29:19,200
中间
Middle.

431
00:29:20,580 --> 00:29:21,060
还有
Too.

432
00:29:23,370 --> 00:29:24,060
然后就完成了
And then it's done.

433
00:29:25,920 --> 00:29:31,530
生成器函数的有趣之处在于 当你执行它时
And the funny thing about a generator function is that when you execute it,

434
00:29:31,531 --> 00:29:32,940
它实际上并没有运行它的代码
it doesn't actually run its code.

435
00:29:33,990 --> 00:29:34,830
它没有打印
It didn't print,

436
00:29:34,831 --> 00:29:37,080
从中间开始 或者做相反的事情
start middle or done instead.

437
00:29:38,280 --> 00:29:43,380
它创建了一个生成器对象和这个生成器对象
It created a generator object and this generator object.

438
00:29:44,340 --> 00:29:50,520
包含一个代码对象来设置表示这些东西的字节码
Contains a code object sets the byte code that represents this stuff.

439
00:29:51,450 --> 00:29:52,080
然后呢
And?

440
00:29:53,130 --> 00:29:54,420
它有
It's got.

441
00:29:58,110 --> 00:30:02,820
40个字节 生成器也有一个堆栈框架
Forty four bytes and the generator also has a stack frame.

442
00:30:03,930 --> 00:30:05,610
它有一个指令指针
And that's got an instruction pointer,

443
00:30:05,611 --> 00:30:07,890
它开始了他的负1
and it begins his negative one,

444
00:30:07,891 --> 00:30:11,700
也就是说它还没有执行任何指令
meaning that it hasn't executed any instructions yet.

445
00:30:12,690 --> 00:30:15,330
这就是为什么我们没有看到这些指纹的原因
And that's why we didn't actually see any of these prints.

446
00:30:15,331 --> 00:30:16,530
大坝正在被执行
Dam is being executed.

447
00:30:17,850 --> 00:30:19,020
那么去哪里呢
So the way to?

448
00:30:20,190 --> 00:30:22,470
运行一个生成器就是在它旁边调用它
Run a generator is to call him next on it.

449
00:30:23,730 --> 00:30:25,320
如果你这样做
And if you do that,

450
00:30:25,321 --> 00:30:30,720
然后你会看到它执行了最初的几段字节码
then you'll see that it executes its first few bites of byte code,

451
00:30:30,721 --> 00:30:42,360
所以它打印开始 一个实际上是下一个语句的返回值因为下一个语句的返回值是下一个执行的结果
so it prints start and one is actually the return value of the next statement because the return value of next is whichever yield his next executed.

452
00:30:43,350 --> 00:30:50,340
现在 指令指针被暂停了13次 进入了40个字节的Baker
And the instruction pointer is now paused at thirteen bites into the forty four bytes of Baker.

453
00:30:51,510 --> 00:30:54,660
所以如果我们下次再打电话
So if we call next again this time,

454
00:30:54,661 --> 00:31:00,960
我要在它的返回值上签名 这样你就能看到一个中间的王子
I'm going to sign its return value so that you can see that a prince middle.

455
00:31:02,640 --> 00:31:03,900
但它又回来了
But it returns.

456
00:31:05,190 --> 00:31:05,640
还有
Too.

457
00:31:06,600 --> 00:31:11,550
这是传递到下一个yield语句的值
Which was the value passed into the next yield statement.

458
00:31:12,900 --> 00:31:17,040
现在我们的堆栈指针
And now our stack pointer.

459
00:31:17,041 --> 00:31:17,400
对不起
Sorry,

460
00:31:17,401 --> 00:31:20,340
我们的指示指针是四十四的二十八
our instruction pointer is at twenty eight of forty four.

461
00:31:21,570 --> 00:31:24,840
如果我们再打一次电话
And if we call next one more time.

462
00:31:25,830 --> 00:31:28,950
然后我们将提高停止迭代异常
Then we'll raise stop iteration exception,

463
00:31:28,951 --> 00:31:30,150
这说明了什么
which indicates that?

464
00:31:31,050 --> 00:31:38,640
它已经完成了 最后一个指针已经被删除了
It's done executing and the last I pointer has actually been deleted.

465
00:31:40,380 --> 00:31:46,740
这就是生成器如何在二点五版本的Python中工作的
So that's how a generator works in all versions of Python going back two point five.

466
00:31:49,020 --> 00:31:52,530
那么我们如何用它来制作窗帘呢
So how do we use that to create a curtain?

467
00:31:54,600 --> 00:31:55,020
嗯
Well,

468
00:31:55,021 --> 00:31:56,250
这是我的承诺
here's the promise.

469
00:31:57,810 --> 00:31:59,670
我们的承诺是这样的
The promise is going to be that.

470
00:32:00,870 --> 00:32:02,790
这是函数
This get function.

471
00:32:04,950 --> 00:32:10,260
它现在必须创建一个闭包 以捕获他的局部变量
Which currently has to create a closure that captures his local variables.

472
00:32:12,030 --> 00:32:13,920
关闭调用的名称
Names that closure call back.

473
00:32:14,940 --> 00:32:20,580
向未来返回的广告 然后用选择器注册未来
Ads that call back to the future and then registers that future with the selector.

474
00:32:21,930 --> 00:32:25,380
这可以简化为不需要回电话
This can be simplified to not require a call back at all.

475
00:32:26,940 --> 00:32:29,640
所以我要离开回调
So I'm going to leave the callback.

476
00:32:29,641 --> 00:32:31,710
我要删除回调主体
I'm going to delete the callbacks body.

477
00:32:34,020 --> 00:32:35,520
但我们需要
But we need to.

478
00:32:36,720 --> 00:32:37,830
暂停
Pause until,

479
00:32:37,831 --> 00:32:48,540
在我们未注册之前 在这里是可写的 然后依靠套接字是可读的 这样我们就可以在它上面调用发送
as is writable somehow here before we unregistered and then rely on the socket to be readable so that we can call send on it and.

480
00:32:50,040 --> 00:32:51,870
我们的承诺是
The promise is that somehow,

481
00:32:51,871 --> 00:32:53,490
通过F
by yielding F,

482
00:32:53,491 --> 00:32:54,960
我们刚刚创造的未来
the future that we just created.

483
00:32:56,490 --> 00:33:05,010
我们可以暂停这个生成器 直到我们说我们感兴趣的事件发生
Somehow we can pause this generator until the event that we said we were interested in has occurred.

484
00:33:07,950 --> 00:33:11,610
如果我们相信这个承诺是真的
And if we believe that this promise is true.

485
00:33:12,630 --> 00:33:20,850
然后 我们可以将两个函数合并成一个包含yield语句的单一生成函数
Then we can combine what had been two functions into a single generative function that contains a yield statement.

486
00:33:22,740 --> 00:33:23,040
屁股
Butt.

487
00:33:24,180 --> 00:33:28,740
这个承诺还没有实现 因为如果我运行这个
The promise is not going to be fulfilled just yet because if I run this,

488
00:33:28,741 --> 00:33:30,210
它将花费0秒
it's going to take zero seconds.

489
00:33:30,211 --> 00:33:31,710
它没有输出
It has no output,

490
00:33:31,711 --> 00:33:33,030
它没有做功
and it doesn't do any work.

491
00:33:34,800 --> 00:33:35,820
为什么呢
So why is that?

492
00:33:35,821 --> 00:33:36,660
这里发生了什么
What happened here?

493
00:33:38,640 --> 00:33:39,210
嗯
Well,

494
00:33:39,211 --> 00:33:42,030
回想一下 当你执行一个生成器函数时
recall that when you execute a generator function,

495
00:33:42,031 --> 00:33:42,600
它会返回
it returns.

496
00:33:42,601 --> 00:33:46,500
生成器实际上并不运行它的任何代码
A generator doesn't actually run any of its code.

497
00:33:46,501 --> 00:33:49,920
现在我在这里添加了一个yield语句
So now that I've added a yield statement here to get,

498
00:33:49,921 --> 00:33:51,810
这意味着到达这里
that means that get here.

499
00:33:54,360 --> 00:33:55,830
只需要返回一个生成器
Just returns a generator.

500
00:33:57,660 --> 00:33:59,670
什么都不做
doesn't actually do anything,

501
00:33:59,671 --> 00:34:00,570
这里也是一样
and the same here.

502
00:34:01,800 --> 00:34:04,380
那么我们要怎么做呢
So how are we going to?

503
00:34:07,590 --> 00:34:09,090
执行它
Execute it?

504
00:34:09,091 --> 00:34:10,650
我们怎么称呼它呢
How do we call next on it?

505
00:34:12,660 --> 00:34:19,620
这就是这个问题的第三个部分
So that is the third piece of this puzzle of this co.

506
00:34:19,621 --> 00:34:22,140
基于例程的基本框架是任务
Routine based basic framework is the task.

507
00:34:23,370 --> 00:34:24,480
测试类
The test class.

508
00:34:26,250 --> 00:34:31,200
它负责在发电机上调用next
It's responsible for calling next on generators.

509
00:34:32,340 --> 00:34:34,980
我们来看看它是什么样的
So let's see what that looks like.

510
00:34:34,981 --> 00:34:37,230
在未来和任务的情况下
And in the case of both future and task,

511
00:34:37,231 --> 00:34:45,150
这些想法非常简单 过于简单 而且不完整
these are incredibly simple and oversimplified and buggy incomplete implementations of these ideas.

512
00:34:45,151 --> 00:34:48,990
这些想法在许多框架中得到了充分的表达
These ideas are fully expressed in a number of frameworks,

513
00:34:48,991 --> 00:34:51,990
尤其是龙卷风和现在的情况
notably tornado and now in.

514
00:34:53,160 --> 00:34:56,670
我在python里踱步
Pacing I owe in the python.

515
00:34:57,600 --> 00:35:00,210
标准库的3点
Three point for the standard library.

516
00:35:01,590 --> 00:35:08,100
所以我的任务类的哑版本会是这样的
So my dumb version of the task class is going to look like.

517
00:35:09,540 --> 00:35:12,900
我们将用生成器初始化它
We're going to initialize it with a generator.

518
00:35:14,610 --> 00:35:15,600
我将保存它
I will save that.

519
00:35:17,280 --> 00:35:20,790
然后我们会有一个叫做Step的函数
And then we'll have a function called Step,

520
00:35:20,791 --> 00:35:24,360
这个术语是从桑丘那里借来的
and this terminology is borrowed from a Sancho.

521
00:35:24,361 --> 00:35:28,320
他下一步在发电机上的呼叫是什么
What step does his calls next on the generator?

522
00:35:30,180 --> 00:35:32,940
从发电机开始
And since the generator,

523
00:35:32,941 --> 00:35:35,100
它将会产生一个未来
it's going to yield a future.

524
00:35:36,870 --> 00:35:40,770
这就变成了下一个的返回值
So that's going to become the return value of next.

525
00:35:40,771 --> 00:35:43,710
我们来捕获它
So let's capture that.

526
00:35:46,020 --> 00:35:46,680
然后
And then.

527
00:35:48,330 --> 00:35:51,000
当这个未来得到解决时 我们想要发生什么
What do we want to happen when this future is resolved?

528
00:35:51,930 --> 00:35:56,790
我们需要给未来增加一些电话
We need to add some kind of call back to the future,

529
00:35:56,791 --> 00:36:00,570
这是我们想要在未来做好的事情
something that we want to happen once the future is ready and.

530
00:36:02,700 --> 00:36:07,470
让我们把self step作为回调
Let's just pass self dot step in as the callback.

531
00:36:07,471 --> 00:36:09,900
所以一旦这个未来得到解决
So once this future is resolved,

532
00:36:09,901 --> 00:36:13,470
就会回到这里 然后再来 自我怀疑再次出现
will just come right back into here and will come next and self doubt turn again.

533
00:36:15,000 --> 00:36:18,330
我们会再打电话给自己
Will we call next and self de Jean again,

534
00:36:18,331 --> 00:36:20,760
这将在这里继续
that's going to resume here.

535
00:36:24,420 --> 00:36:28,650
因此我们知道我们可以注册套接字文件号
And therefore we know that we can and register the sockets file number,

536
00:36:28,651 --> 00:36:30,000
而现在的情况是可信的
and that s is now credible.

537
00:36:31,350 --> 00:36:35,520
所以如果我们运行它 它仍然不会起作用
So if we run this still not going to work.

538
00:36:37,110 --> 00:36:38,730
这样做的原因是
The reason for that is.

539
00:36:41,160 --> 00:36:45,060
我们需要做一个初始的调用自我那一步
That we need to make an initial call the self that step,

540
00:36:45,061 --> 00:36:45,390
说
said,

541
00:36:45,391 --> 00:36:46,590
爸爸
Dad,

542
00:36:46,591 --> 00:36:54,090
我们给self做了一个初始的调用 这样我们就得到了启动函数
we make an initial call to self that Jen so that we get the get function started,

543
00:36:54,091 --> 00:36:55,950
它会连接套接字 等等
and it will connect the socket and so on.

544
00:36:55,951 --> 00:36:58,830
我们在这里做一下
So let's just do that right here.

545
00:36:58,831 --> 00:36:59,640
在构造函数中
In the constructor.

546
00:37:02,490 --> 00:37:03,720
然后是最后一步
And then the final step.

547
00:37:05,520 --> 00:37:09,870
这个转换将会在下面
Of this conversion is going to be down here,

548
00:37:09,871 --> 00:37:11,520
我们需要包装的地方
where we need to wrap.

549
00:37:13,020 --> 00:37:17,010
在一个任务中 每一个调用 当返回一个生成器时
Each of these calls in a task so when get returns a generator,

550
00:37:17,011 --> 00:37:17,550
任务
the task,

551
00:37:17,551 --> 00:37:18,150
拉普说
Rapp said.

552
00:37:19,740 --> 00:37:33,360
香肠的标志 叫self step 我将会调用它 它实际上会开始这个东西直到第一个产量
Signs of sausage and calls self dot step and I will call next in that will actually begin this thing executing up until the first yield.

553
00:37:33,361 --> 00:37:34,500
斯蒂芬
Stephen.

554
00:37:34,501 --> 00:37:35,700
如果我运行这个
So if I run this.

555
00:37:38,340 --> 00:37:39,120
在某种程度上
In a way,

556
00:37:39,121 --> 00:37:41,190
你会看到我们取得进步的方式
you will see the way we make progress.

557
00:37:42,150 --> 00:37:45,570
因为我们在这里提出了一个停止迭代异常
Because we raise a stop iteration exception here.

558
00:37:47,190 --> 00:37:49,380
所以这确实是个好消息
So that that actually that's good news,

559
00:37:49,381 --> 00:37:55,800
因为这意味着这个get生成器实际上已经运行到完成了
because it means that this get generator has actually been run to completion.

560
00:37:55,801 --> 00:37:59,700
它完成了它所要做的工作
It's done the work that it set out to do.

561
00:37:59,701 --> 00:38:01,410
所以
so.

562
00:38:01,411 --> 00:38:02,370
如果我们
if we.

563
00:38:04,080 --> 00:38:04,980
抓住它
Catch that.

564
00:38:05,940 --> 00:38:07,140
我们想在这里做什么
What do we want to do here?

565
00:38:07,141 --> 00:38:07,470
嗯
Well,

566
00:38:07,471 --> 00:38:08,430
任务完成了
the task is done.

567
00:38:08,431 --> 00:38:10,110
让我们返回
So let's just return.

568
00:38:11,340 --> 00:38:12,930
如果我们执行这个版本
And if we execute this version.

569
00:38:14,370 --> 00:38:15,540
它实际上完成了
It actually completes.

570
00:38:16,530 --> 00:38:22,800
这太棒了 我们还有一些零散的回调
So this is fantastic now we've still got a few stray callbacks.

571
00:38:23,670 --> 00:38:24,630
所以
So.

572
00:38:25,620 --> 00:38:28,980
我们可以消去这些和我们在这里做的变换
We can get rid of those the same transformation that we did here.

573
00:38:30,330 --> 00:38:32,430
所以我们也要把它写下来
So we're just going to do it down here again as well,

574
00:38:32,431 --> 00:38:33,330
所以我们要
so we're going to.

575
00:38:33,331 --> 00:38:34,950
我们再也不需要这个电话了
We don't need this call back any more.

576
00:38:35,940 --> 00:38:37,500
你不需要把它加到未来
You don't need to add it to the future.

577
00:38:38,460 --> 00:38:46,680
我们仍然需要说出我们感兴趣的事件并注册未来当事件发生时
We do still need to say what event we're interested in and register the future to be resolved when that event occurs,

578
00:38:46,681 --> 00:38:50,010
但是我们可以删除回调定义
but we can delete the callback definition.

579
00:38:51,060 --> 00:38:55,710
因为我们的函数和之前的一样
Since we're still in the same function as we were in before,

580
00:38:55,711 --> 00:38:59,010
我们不需要一个冗余的全局声明
we don't need a redundant global statement.

581
00:39:00,270 --> 00:39:06,480
如果我们简单地创造出我们创造的新未来
And if we simply yield this new future that we created,

582
00:39:06,481 --> 00:39:07,440
这意味着
that means that.

583
00:39:08,760 --> 00:39:09,420
到目前为止
By now,

584
00:39:09,421 --> 00:39:13,710
当任务解决的时候
by the time the task resolve resumes us,

585
00:39:13,711 --> 00:39:14,880
这个套接字现在是可读的
the socket is now readable.

586
00:39:17,970 --> 00:39:21,570
这是最后一个回调
And here we've got our last of the callback.

587
00:39:21,571 --> 00:39:22,800
我们可以把它删掉
so we can delete that.

588
00:39:24,000 --> 00:39:29,460
我们可以实现我们的未来 而不是注册一个回调
And we can yield our future instead of registering a callback.

589
00:39:31,470 --> 00:39:33,510
啊
And ah.

590
00:39:36,720 --> 00:39:42,180
当我们收到下一个查克时 我们想做什么
What do we want to do once we have received the next Chuck?

591
00:39:42,181 --> 00:39:42,780
换句话说
In other words,

592
00:39:42,781 --> 00:39:45,390
一旦套接字再次被写出来
once the socket is writable again?

593
00:39:46,380 --> 00:39:46,680
嗯
Well,

594
00:39:46,681 --> 00:39:50,460
我们想要得到下一个杰克
we want to receive the next jack right,

595
00:39:50,461 --> 00:40:01,020
所以我们最后要做的是 我们最终会复制原来在d里的真实循环
so what we're going to end up doing is we're going to end up reproducing the same while true loop that we originally had in d.

596
00:40:02,610 --> 00:40:05,130
在演讲开始的时候
Olden days at the beginning of this talk,

597
00:40:05,131 --> 00:40:08,100
当我们写一个简单的阻塞时
when we were writing a simple blocking yet.

598
00:40:09,060 --> 00:40:10,830
所以它看起来是这样的
So that's going to look something like.

599
00:40:14,070 --> 00:40:15,330
我们要
We're going to.

600
00:40:16,800 --> 00:40:18,180
把这个放在循环中
Put this within the loop.

601
00:40:19,650 --> 00:40:22,680
每次通过循环 我们会说
And each time through the loop we say,

602
00:40:22,681 --> 00:40:25,890
我想从插座上读取数据
I want to read from the socket,

603
00:40:25,891 --> 00:40:28,140
所以等待这个未来的解决
so wait for this future to be resolved.

604
00:40:29,130 --> 00:40:32,370
然后从选择器中取消套接字
And then unregistered the socket from the selector.

605
00:40:32,371 --> 00:40:33,120
得到那块
get the chunk.

606
00:40:34,050 --> 00:40:40,860
如果有任何东西被添加到列表中 这个东西现在是额外的
And if there is any then added to the list and this stuff is now extra.

607
00:40:42,690 --> 00:40:46,110
这个循环会重复 在这里重复做这些
The loop will just repeat and do that stuff again up here,

608
00:40:46,111 --> 00:40:47,520
如果没有查克
and if there's no chuck.

609
00:40:47,521 --> 00:40:48,420
这意味着
That means that.

610
00:40:50,070 --> 00:40:51,960
我们已经阅读了服务器响应
We're done reading the server response,

611
00:40:51,961 --> 00:40:53,640
所以我们可以
and so we can.

612
00:40:55,260 --> 00:40:56,460
把身体连接起来
Join the body up,

613
00:40:56,461 --> 00:40:59,850
打印第一行 减少任务数
print the first line decrement the tasks count,

614
00:40:59,851 --> 00:41:02,940
从现在开始 我们又回到了一个无限循环
and since now we're in an infinite loop again.

615
00:41:02,941 --> 00:41:05,370
在这里 我们需要尽快返回
here we need to return as soon as we're done.

616
00:41:07,740 --> 00:41:08,160
现在
Now,

617
00:41:08,161 --> 00:41:10,290
如果一切顺利 我运行这个
if all goes well and I run this,

618
00:41:10,291 --> 00:41:14,340
然后它仍然需要一秒
then it still takes one second.

619
00:41:14,341 --> 00:41:16,590
它仍然在做所有的工作
it still does all the work that it was.

620
00:41:17,850 --> 00:41:26,250
当被要求做的时候 我们仍然可以把它扩展到大量的任务而不损失任何性能
Asked to do and we can still scale this out to a large number of tasks without any loss of performance,

621
00:41:26,251 --> 00:41:32,160
因为发射10个15个窗帘实在是太便宜了
because launching ten fifteen curtains is incredibly cheap,

622
00:41:32,161 --> 00:41:34,080
它的价格大概和
it's roughly as cheap as.

623
00:41:35,160 --> 00:41:36,360
一堆回叫
A bunch of callbacks.

624
00:41:37,440 --> 00:41:46,140
所以很酷的例程是两个世界中最好的 他最便宜的回调比我的系统上的线程要便宜得多
So cool routines are kind of the best of both worlds there about his cheapest callbacks are much cheaper than threads on my system,

625
00:41:46,141 --> 00:41:50,580
我测量了一个co例程
I measured that a co routine takes.

626
00:41:51,540 --> 00:41:57,150
大约6K的内存和30个线程的内存
About six K of memory versus about thirty cave memory for a thread,

627
00:41:57,151 --> 00:42:04,740
此外 我做了一个小实验 发现我有能力启动超过十万个常规程序
and furthermore I did a little experiment and found that I was capable of launching over a hundred thousand co routines.

628
00:42:04,741 --> 00:42:12,030
它们的限制仅仅是允许Python进程分配的ram数量
Their limited only by the amount of ram that the Python process is allowed to allocate.

629
00:42:12,930 --> 00:42:14,100
丝丝太太
Mrs Threads,

630
00:42:14,101 --> 00:42:18,030
除了简单的内存限制之外 它还受到其他限制
which are subject to other limits beside simply memory limits.

631
00:42:18,031 --> 00:42:24,630
有各种用户和操作系统限制了进程被允许开始的线程数量
There are various user and operating system limits on the number of threads that a process is allowed to start with.

632
00:42:24,631 --> 00:42:24,960
她
Her.

633
00:42:26,490 --> 00:42:29,670
在不同的工作方式下
Difficult in various ways to work around,

634
00:42:29,671 --> 00:42:39,030
它们占用了空间和操作系统数据结构和操作系统调度器 最终导致它们的开销变得非常重要
and they take up space and operating system data structures and the operating system scheduler that eventually causes their overhead to become quite significant.

635
00:42:40,350 --> 00:42:55,020
他们所做的一切都是在等待爱荷华州的一些缓慢的行动它们实际上需要非常多的sepia所以与这种应用的煤例程相比
All they're doing is waiting around for some sort of slow Iowa operations that are actually going to require very much sepia so compared to coal routines for a application like this,

636
00:42:55,021 --> 00:43:08,010
这将花费很少的时间进行计算 并且绝大多数时间都花在等待一个缓慢的服务器或者在套接字的另一端的慢客户机上
that's going to spend very little time doing computation and overwhelmingly spending its time waiting for a slow server or a slow client at the other end of the socket.

637
00:43:08,011 --> 00:43:11,580
在这种情况下 Co例程更有效率
Co routines are much more efficient for this kind of thing,

638
00:43:11,581 --> 00:43:16,290
但是和回叫相比 它们的简单得多 因为
but compared to call backs their lot simpler because.

639
00:43:17,460 --> 00:43:23,250
你可以把所有的代码放在一个函数里
You can put all of the code for a coating in one function,

640
00:43:23,251 --> 00:43:29,250
所以你不需要声明并注册整个回调函数链
so you don't have to declare and register a whole chain of callbacks.

641
00:43:29,251 --> 00:43:34,170
你可以重复使用你的局部变量 就像你经常遇到的麻烦一样
And you can just reuse your local variables the same way that trouble you have always done.

642
00:43:36,270 --> 00:43:42,870
这就是龙卷风的开始或者是水槽的开始
So that's the beginning of Tornado style or a sink.

643
00:43:42,871 --> 00:43:47,130
基于Ios风格的同步框架
Ios Style Co routine based a sync framework.

644
00:43:50,130 --> 00:43:52,710
如果你想了解更多
So if you want to know more about this,

645
00:43:52,711 --> 00:44:03,090
去斜杠的co例程为你创建了一个登陆页面它会把你链接到我刚才写的代码的一个版本
go to bitterly slash co routines have created a landing page for you there that'll link you out to a version of the code that I wrote just now,

646
00:44:03,091 --> 00:44:12,840
我和吉多范罗斯姆一起写了一章 这一章将会出现在开源应用程序架构的下一本书中
as well as link you to a chapter that I wrote with Guido van Rossum that will appear in the next book in the architecture of Open source Application Serious.

647
00:44:12,841 --> 00:44:22,710
这一章更详细地介绍了如何在水槽中实现基于发电机的涂层
and that chapter goes into far more detail about how generator based coatings are implemented in a sink.

648
00:44:22,711 --> 00:44:25,500
我在一个标准的图书馆里养了一只宠物
I owned a pet on three point for a standard library,

649
00:44:25,501 --> 00:44:29,250
特别是它涉及到如何
and especially it goes into how.

650
00:44:30,270 --> 00:44:32,430
Co例程利用了
Co routines take advantage of.

651
00:44:33,450 --> 00:44:43,560
特定于python3的生成器特性以及在任何场景中包含的同步队列类
Generator features that are specific to python three and how a synchronous queue class that's included in any scenario,

652
00:44:43,561 --> 00:44:52,350
可以用一种对习惯使用线程的人非常熟悉的方式来协调日常工作
can be used to coordinate co routines in a way that's very familiar to people who are used to using threads.

653
00:44:53,580 --> 00:44:55,530
作为一个提醒
And as a reminder,

654
00:44:55,531 --> 00:45:00,210
如果你想和我这样的人在一家opensource公司工作
if you want to work with people like me at a opensource company,

655
00:45:00,211 --> 00:45:05,400
这是非常温暖的 多样性有真正的实现和技术挑战的工作
that's very warm and diversity has really fulfilling and technically challenging jobs.

656
00:45:05,401 --> 00:45:07,080
Mongodb正在招聘
Mongo db is hiring.

657
00:45:07,081 --> 00:45:11,070
我们在纽约的帕罗奥图和世界各地都设有办事处
We have offices in New York in Palo Alto and worldwide.

658
00:45:11,071 --> 00:45:14,160
去bewdley 砍去商店
Go to bewdley slash mongo dashed shops.

659
00:45:14,161 --> 00:45:15,090
我很想和你一起工作
I would love to work with you.

